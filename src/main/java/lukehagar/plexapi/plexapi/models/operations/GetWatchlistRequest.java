/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package lukehagar.plexapi.plexapi.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;
import lukehagar.plexapi.plexapi.utils.SpeakeasyMetadata;
import lukehagar.plexapi.plexapi.utils.Utils;

public class GetWatchlistRequest {

    /**
     * Filter
     */
    @SpeakeasyMetadata("pathParam:style=simple,explode=false,name=filter")
    private PathParamFilter filter;

    /**
     * In the format "field:dir". Available fields are "watchlistedAt" (Added At),
     * "titleSort" (Title), "originallyAvailableAt" (Release Date), or "rating" (Critic Rating).
     * "dir" can be "asc" or "desc"
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=sort")
    private Optional<? extends String> sort;

    /**
     * The type of library to filter. Can be "movie" or "show", or all if not present.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=libtype")
    private Optional<? extends Libtype> libtype;

    /**
     * The number of items to return. If not specified, all items will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=maxresults")
    private Optional<? extends Integer> maxresults;

    /**
     * include collections in the results
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=includeCollections")
    private Optional<? extends IncludeCollections> includeCollections;

    /**
     * include external media in the results
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=includeExternalMedia")
    private Optional<? extends IncludeExternalMedia> includeExternalMedia;

    /**
     * User Token
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=X-Plex-Token")
    private String xPlexToken;

    /**
     * The index of the first item to return. If not specified, the first item will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=X-Plex-Container-Start")
    private Optional<? extends Integer> xPlexContainerStart;

    /**
     * The number of items to return. If not specified, all items will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=X-Plex-Container-Size")
    private Optional<? extends Integer> xPlexContainerSize;

    @JsonCreator
    public GetWatchlistRequest(
            PathParamFilter filter,
            Optional<? extends String> sort,
            Optional<? extends Libtype> libtype,
            Optional<? extends Integer> maxresults,
            Optional<? extends IncludeCollections> includeCollections,
            Optional<? extends IncludeExternalMedia> includeExternalMedia,
            String xPlexToken,
            Optional<? extends Integer> xPlexContainerStart,
            Optional<? extends Integer> xPlexContainerSize) {
        Utils.checkNotNull(filter, "filter");
        Utils.checkNotNull(sort, "sort");
        Utils.checkNotNull(libtype, "libtype");
        Utils.checkNotNull(maxresults, "maxresults");
        Utils.checkNotNull(includeCollections, "includeCollections");
        Utils.checkNotNull(includeExternalMedia, "includeExternalMedia");
        Utils.checkNotNull(xPlexToken, "xPlexToken");
        Utils.checkNotNull(xPlexContainerStart, "xPlexContainerStart");
        Utils.checkNotNull(xPlexContainerSize, "xPlexContainerSize");
        this.filter = filter;
        this.sort = sort;
        this.libtype = libtype;
        this.maxresults = maxresults;
        this.includeCollections = includeCollections;
        this.includeExternalMedia = includeExternalMedia;
        this.xPlexToken = xPlexToken;
        this.xPlexContainerStart = xPlexContainerStart;
        this.xPlexContainerSize = xPlexContainerSize;
    }
    
    public GetWatchlistRequest(
            PathParamFilter filter,
            String xPlexToken) {
        this(filter, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), xPlexToken, Optional.empty(), Optional.empty());
    }

    /**
     * Filter
     */
    @JsonIgnore
    public PathParamFilter filter() {
        return filter;
    }

    /**
     * In the format "field:dir". Available fields are "watchlistedAt" (Added At),
     * "titleSort" (Title), "originallyAvailableAt" (Release Date), or "rating" (Critic Rating).
     * "dir" can be "asc" or "desc"
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> sort() {
        return (Optional<String>) sort;
    }

    /**
     * The type of library to filter. Can be "movie" or "show", or all if not present.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Libtype> libtype() {
        return (Optional<Libtype>) libtype;
    }

    /**
     * The number of items to return. If not specified, all items will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Integer> maxresults() {
        return (Optional<Integer>) maxresults;
    }

    /**
     * include collections in the results
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<IncludeCollections> includeCollections() {
        return (Optional<IncludeCollections>) includeCollections;
    }

    /**
     * include external media in the results
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<IncludeExternalMedia> includeExternalMedia() {
        return (Optional<IncludeExternalMedia>) includeExternalMedia;
    }

    /**
     * User Token
     */
    @JsonIgnore
    public String xPlexToken() {
        return xPlexToken;
    }

    /**
     * The index of the first item to return. If not specified, the first item will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Integer> xPlexContainerStart() {
        return (Optional<Integer>) xPlexContainerStart;
    }

    /**
     * The number of items to return. If not specified, all items will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Integer> xPlexContainerSize() {
        return (Optional<Integer>) xPlexContainerSize;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Filter
     */
    public GetWatchlistRequest withFilter(PathParamFilter filter) {
        Utils.checkNotNull(filter, "filter");
        this.filter = filter;
        return this;
    }

    /**
     * In the format "field:dir". Available fields are "watchlistedAt" (Added At),
     * "titleSort" (Title), "originallyAvailableAt" (Release Date), or "rating" (Critic Rating).
     * "dir" can be "asc" or "desc"
     * 
     */
    public GetWatchlistRequest withSort(String sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = Optional.ofNullable(sort);
        return this;
    }

    /**
     * In the format "field:dir". Available fields are "watchlistedAt" (Added At),
     * "titleSort" (Title), "originallyAvailableAt" (Release Date), or "rating" (Critic Rating).
     * "dir" can be "asc" or "desc"
     * 
     */
    public GetWatchlistRequest withSort(Optional<? extends String> sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = sort;
        return this;
    }

    /**
     * The type of library to filter. Can be "movie" or "show", or all if not present.
     * 
     */
    public GetWatchlistRequest withLibtype(Libtype libtype) {
        Utils.checkNotNull(libtype, "libtype");
        this.libtype = Optional.ofNullable(libtype);
        return this;
    }

    /**
     * The type of library to filter. Can be "movie" or "show", or all if not present.
     * 
     */
    public GetWatchlistRequest withLibtype(Optional<? extends Libtype> libtype) {
        Utils.checkNotNull(libtype, "libtype");
        this.libtype = libtype;
        return this;
    }

    /**
     * The number of items to return. If not specified, all items will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    public GetWatchlistRequest withMaxresults(int maxresults) {
        Utils.checkNotNull(maxresults, "maxresults");
        this.maxresults = Optional.ofNullable(maxresults);
        return this;
    }

    /**
     * The number of items to return. If not specified, all items will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    public GetWatchlistRequest withMaxresults(Optional<? extends Integer> maxresults) {
        Utils.checkNotNull(maxresults, "maxresults");
        this.maxresults = maxresults;
        return this;
    }

    /**
     * include collections in the results
     * 
     */
    public GetWatchlistRequest withIncludeCollections(IncludeCollections includeCollections) {
        Utils.checkNotNull(includeCollections, "includeCollections");
        this.includeCollections = Optional.ofNullable(includeCollections);
        return this;
    }

    /**
     * include collections in the results
     * 
     */
    public GetWatchlistRequest withIncludeCollections(Optional<? extends IncludeCollections> includeCollections) {
        Utils.checkNotNull(includeCollections, "includeCollections");
        this.includeCollections = includeCollections;
        return this;
    }

    /**
     * include external media in the results
     * 
     */
    public GetWatchlistRequest withIncludeExternalMedia(IncludeExternalMedia includeExternalMedia) {
        Utils.checkNotNull(includeExternalMedia, "includeExternalMedia");
        this.includeExternalMedia = Optional.ofNullable(includeExternalMedia);
        return this;
    }

    /**
     * include external media in the results
     * 
     */
    public GetWatchlistRequest withIncludeExternalMedia(Optional<? extends IncludeExternalMedia> includeExternalMedia) {
        Utils.checkNotNull(includeExternalMedia, "includeExternalMedia");
        this.includeExternalMedia = includeExternalMedia;
        return this;
    }

    /**
     * User Token
     */
    public GetWatchlistRequest withXPlexToken(String xPlexToken) {
        Utils.checkNotNull(xPlexToken, "xPlexToken");
        this.xPlexToken = xPlexToken;
        return this;
    }

    /**
     * The index of the first item to return. If not specified, the first item will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    public GetWatchlistRequest withXPlexContainerStart(int xPlexContainerStart) {
        Utils.checkNotNull(xPlexContainerStart, "xPlexContainerStart");
        this.xPlexContainerStart = Optional.ofNullable(xPlexContainerStart);
        return this;
    }

    /**
     * The index of the first item to return. If not specified, the first item will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    public GetWatchlistRequest withXPlexContainerStart(Optional<? extends Integer> xPlexContainerStart) {
        Utils.checkNotNull(xPlexContainerStart, "xPlexContainerStart");
        this.xPlexContainerStart = xPlexContainerStart;
        return this;
    }

    /**
     * The number of items to return. If not specified, all items will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    public GetWatchlistRequest withXPlexContainerSize(int xPlexContainerSize) {
        Utils.checkNotNull(xPlexContainerSize, "xPlexContainerSize");
        this.xPlexContainerSize = Optional.ofNullable(xPlexContainerSize);
        return this;
    }

    /**
     * The number of items to return. If not specified, all items will be returned.
     * If the number of items exceeds the limit, the response will be paginated.
     * 
     */
    public GetWatchlistRequest withXPlexContainerSize(Optional<? extends Integer> xPlexContainerSize) {
        Utils.checkNotNull(xPlexContainerSize, "xPlexContainerSize");
        this.xPlexContainerSize = xPlexContainerSize;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        GetWatchlistRequest other = (GetWatchlistRequest) o;
        return 
            java.util.Objects.deepEquals(this.filter, other.filter) &&
            java.util.Objects.deepEquals(this.sort, other.sort) &&
            java.util.Objects.deepEquals(this.libtype, other.libtype) &&
            java.util.Objects.deepEquals(this.maxresults, other.maxresults) &&
            java.util.Objects.deepEquals(this.includeCollections, other.includeCollections) &&
            java.util.Objects.deepEquals(this.includeExternalMedia, other.includeExternalMedia) &&
            java.util.Objects.deepEquals(this.xPlexToken, other.xPlexToken) &&
            java.util.Objects.deepEquals(this.xPlexContainerStart, other.xPlexContainerStart) &&
            java.util.Objects.deepEquals(this.xPlexContainerSize, other.xPlexContainerSize);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            filter,
            sort,
            libtype,
            maxresults,
            includeCollections,
            includeExternalMedia,
            xPlexToken,
            xPlexContainerStart,
            xPlexContainerSize);
    }
    
    @Override
    public String toString() {
        return Utils.toString(GetWatchlistRequest.class,
                "filter", filter,
                "sort", sort,
                "libtype", libtype,
                "maxresults", maxresults,
                "includeCollections", includeCollections,
                "includeExternalMedia", includeExternalMedia,
                "xPlexToken", xPlexToken,
                "xPlexContainerStart", xPlexContainerStart,
                "xPlexContainerSize", xPlexContainerSize);
    }
    
    public final static class Builder {
 
        private PathParamFilter filter;
 
        private Optional<? extends String> sort = Optional.empty();
 
        private Optional<? extends Libtype> libtype = Optional.empty();
 
        private Optional<? extends Integer> maxresults = Optional.empty();
 
        private Optional<? extends IncludeCollections> includeCollections = Optional.empty();
 
        private Optional<? extends IncludeExternalMedia> includeExternalMedia = Optional.empty();
 
        private String xPlexToken;
 
        private Optional<? extends Integer> xPlexContainerStart = Optional.empty();
 
        private Optional<? extends Integer> xPlexContainerSize = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Filter
         */
        public Builder filter(PathParamFilter filter) {
            Utils.checkNotNull(filter, "filter");
            this.filter = filter;
            return this;
        }

        /**
         * In the format "field:dir". Available fields are "watchlistedAt" (Added At),
         * "titleSort" (Title), "originallyAvailableAt" (Release Date), or "rating" (Critic Rating).
         * "dir" can be "asc" or "desc"
         * 
         */
        public Builder sort(String sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = Optional.ofNullable(sort);
            return this;
        }

        /**
         * In the format "field:dir". Available fields are "watchlistedAt" (Added At),
         * "titleSort" (Title), "originallyAvailableAt" (Release Date), or "rating" (Critic Rating).
         * "dir" can be "asc" or "desc"
         * 
         */
        public Builder sort(Optional<? extends String> sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = sort;
            return this;
        }

        /**
         * The type of library to filter. Can be "movie" or "show", or all if not present.
         * 
         */
        public Builder libtype(Libtype libtype) {
            Utils.checkNotNull(libtype, "libtype");
            this.libtype = Optional.ofNullable(libtype);
            return this;
        }

        /**
         * The type of library to filter. Can be "movie" or "show", or all if not present.
         * 
         */
        public Builder libtype(Optional<? extends Libtype> libtype) {
            Utils.checkNotNull(libtype, "libtype");
            this.libtype = libtype;
            return this;
        }

        /**
         * The number of items to return. If not specified, all items will be returned.
         * If the number of items exceeds the limit, the response will be paginated.
         * 
         */
        public Builder maxresults(int maxresults) {
            Utils.checkNotNull(maxresults, "maxresults");
            this.maxresults = Optional.ofNullable(maxresults);
            return this;
        }

        /**
         * The number of items to return. If not specified, all items will be returned.
         * If the number of items exceeds the limit, the response will be paginated.
         * 
         */
        public Builder maxresults(Optional<? extends Integer> maxresults) {
            Utils.checkNotNull(maxresults, "maxresults");
            this.maxresults = maxresults;
            return this;
        }

        /**
         * include collections in the results
         * 
         */
        public Builder includeCollections(IncludeCollections includeCollections) {
            Utils.checkNotNull(includeCollections, "includeCollections");
            this.includeCollections = Optional.ofNullable(includeCollections);
            return this;
        }

        /**
         * include collections in the results
         * 
         */
        public Builder includeCollections(Optional<? extends IncludeCollections> includeCollections) {
            Utils.checkNotNull(includeCollections, "includeCollections");
            this.includeCollections = includeCollections;
            return this;
        }

        /**
         * include external media in the results
         * 
         */
        public Builder includeExternalMedia(IncludeExternalMedia includeExternalMedia) {
            Utils.checkNotNull(includeExternalMedia, "includeExternalMedia");
            this.includeExternalMedia = Optional.ofNullable(includeExternalMedia);
            return this;
        }

        /**
         * include external media in the results
         * 
         */
        public Builder includeExternalMedia(Optional<? extends IncludeExternalMedia> includeExternalMedia) {
            Utils.checkNotNull(includeExternalMedia, "includeExternalMedia");
            this.includeExternalMedia = includeExternalMedia;
            return this;
        }

        /**
         * User Token
         */
        public Builder xPlexToken(String xPlexToken) {
            Utils.checkNotNull(xPlexToken, "xPlexToken");
            this.xPlexToken = xPlexToken;
            return this;
        }

        /**
         * The index of the first item to return. If not specified, the first item will be returned.
         * If the number of items exceeds the limit, the response will be paginated.
         * 
         */
        public Builder xPlexContainerStart(int xPlexContainerStart) {
            Utils.checkNotNull(xPlexContainerStart, "xPlexContainerStart");
            this.xPlexContainerStart = Optional.ofNullable(xPlexContainerStart);
            return this;
        }

        /**
         * The index of the first item to return. If not specified, the first item will be returned.
         * If the number of items exceeds the limit, the response will be paginated.
         * 
         */
        public Builder xPlexContainerStart(Optional<? extends Integer> xPlexContainerStart) {
            Utils.checkNotNull(xPlexContainerStart, "xPlexContainerStart");
            this.xPlexContainerStart = xPlexContainerStart;
            return this;
        }

        /**
         * The number of items to return. If not specified, all items will be returned.
         * If the number of items exceeds the limit, the response will be paginated.
         * 
         */
        public Builder xPlexContainerSize(int xPlexContainerSize) {
            Utils.checkNotNull(xPlexContainerSize, "xPlexContainerSize");
            this.xPlexContainerSize = Optional.ofNullable(xPlexContainerSize);
            return this;
        }

        /**
         * The number of items to return. If not specified, all items will be returned.
         * If the number of items exceeds the limit, the response will be paginated.
         * 
         */
        public Builder xPlexContainerSize(Optional<? extends Integer> xPlexContainerSize) {
            Utils.checkNotNull(xPlexContainerSize, "xPlexContainerSize");
            this.xPlexContainerSize = xPlexContainerSize;
            return this;
        }
        
        public GetWatchlistRequest build() {
            return new GetWatchlistRequest(
                filter,
                sort,
                libtype,
                maxresults,
                includeCollections,
                includeExternalMedia,
                xPlexToken,
                xPlexContainerStart,
                xPlexContainerSize);
        }
    }
}

