/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.models.shared.Accepts;
import dev.plexapi.sdk.models.shared.BoolInt;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.SpeakeasyMetadata;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;


public class ReportRequest {
    /**
     * Indicates the client accepts the indicated media types
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=accepts")
    private Optional<? extends Accepts> accepts;

    /**
     * An opaque identifier unique to the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Client-Identifier")
    private Optional<String> clientIdentifier;

    /**
     * The name of the client product
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Product")
    private Optional<String> product;

    /**
     * The version of the client application
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Version")
    private Optional<String> version;

    /**
     * The platform of the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform")
    private Optional<String> platform;

    /**
     * The version of the platform
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform-Version")
    private Optional<String> platformVersion;

    /**
     * A relatively friendly name for the client device
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device")
    private Optional<String> device;

    /**
     * A potentially less friendly identifier for the device model
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Model")
    private Optional<String> model;

    /**
     * The device vendor
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Vendor")
    private Optional<String> deviceVendor;

    /**
     * A friendly name for the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Name")
    private Optional<String> deviceName;

    /**
     * The marketplace on which the client application is distributed
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Marketplace")
    private Optional<String> marketplace;

    /**
     * The details key for the item.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=key")
    private Optional<String> key;

    /**
     * The rating key attribute for the item.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=ratingKey")
    private Optional<String> ratingKey;

    /**
     * The current state of the media.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=state")
    private Optional<? extends State> state;

    /**
     * If playing media from a play queue, the play queue's ID.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=playQueueItemID")
    private Optional<String> playQueueItemID;

    /**
     * The current time offset of playback in ms.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=time")
    private Optional<Long> time;

    /**
     * The total duration of the item in ms.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=duration")
    private Optional<Long> duration;

    /**
     * When state is `stopped`, a flag indicating whether or not the client is going to continue playing anothe item.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=continuing")
    private Optional<? extends BoolInt> continuing;

    /**
     * Used when a sync client comes online and is syncing media timelines, holds the time at which the playback state was last updated.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=updated")
    private Optional<Long> updated;

    /**
     * Also used by sync clients, used to indicate that a timeline is being synced from being offline, as opposed to being "live".
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=offline")
    private Optional<? extends BoolInt> offline;

    /**
     * Time in seconds till first frame is displayed.  Sent only on the first playing timeline request.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=timeToFirstFrame")
    private Optional<Long> timeToFirstFrame;

    /**
     * Time in seconds spent buffering since last request.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=timeStalled")
    private Optional<Long> timeStalled;

    /**
     * Bandwidth in kbps as estimated by the client.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=bandwidth")
    private Optional<Long> bandwidth;

    /**
     * Amount of time in seconds buffered by client.  Omit if computed by `bufferedSize` below.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=bufferedTime")
    private Optional<Long> bufferedTime;

    /**
     * Size in kilobytes of data buffered by client.  Omit if computed by `bufferedTime` above
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=bufferedSize")
    private Optional<Long> bufferedSize;

    /**
     * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Session-Identifier")
    private Optional<String> xPlexSessionIdentifier;

    @JsonCreator
    public ReportRequest(
            Optional<? extends Accepts> accepts,
            Optional<String> clientIdentifier,
            Optional<String> product,
            Optional<String> version,
            Optional<String> platform,
            Optional<String> platformVersion,
            Optional<String> device,
            Optional<String> model,
            Optional<String> deviceVendor,
            Optional<String> deviceName,
            Optional<String> marketplace,
            Optional<String> key,
            Optional<String> ratingKey,
            Optional<? extends State> state,
            Optional<String> playQueueItemID,
            Optional<Long> time,
            Optional<Long> duration,
            Optional<? extends BoolInt> continuing,
            Optional<Long> updated,
            Optional<? extends BoolInt> offline,
            Optional<Long> timeToFirstFrame,
            Optional<Long> timeStalled,
            Optional<Long> bandwidth,
            Optional<Long> bufferedTime,
            Optional<Long> bufferedSize,
            Optional<String> xPlexSessionIdentifier) {
        Utils.checkNotNull(accepts, "accepts");
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        Utils.checkNotNull(product, "product");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(platform, "platform");
        Utils.checkNotNull(platformVersion, "platformVersion");
        Utils.checkNotNull(device, "device");
        Utils.checkNotNull(model, "model");
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        Utils.checkNotNull(deviceName, "deviceName");
        Utils.checkNotNull(marketplace, "marketplace");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(ratingKey, "ratingKey");
        Utils.checkNotNull(state, "state");
        Utils.checkNotNull(playQueueItemID, "playQueueItemID");
        Utils.checkNotNull(time, "time");
        Utils.checkNotNull(duration, "duration");
        Utils.checkNotNull(continuing, "continuing");
        Utils.checkNotNull(updated, "updated");
        Utils.checkNotNull(offline, "offline");
        Utils.checkNotNull(timeToFirstFrame, "timeToFirstFrame");
        Utils.checkNotNull(timeStalled, "timeStalled");
        Utils.checkNotNull(bandwidth, "bandwidth");
        Utils.checkNotNull(bufferedTime, "bufferedTime");
        Utils.checkNotNull(bufferedSize, "bufferedSize");
        Utils.checkNotNull(xPlexSessionIdentifier, "xPlexSessionIdentifier");
        this.accepts = accepts;
        this.clientIdentifier = clientIdentifier;
        this.product = product;
        this.version = version;
        this.platform = platform;
        this.platformVersion = platformVersion;
        this.device = device;
        this.model = model;
        this.deviceVendor = deviceVendor;
        this.deviceName = deviceName;
        this.marketplace = marketplace;
        this.key = key;
        this.ratingKey = ratingKey;
        this.state = state;
        this.playQueueItemID = playQueueItemID;
        this.time = time;
        this.duration = duration;
        this.continuing = continuing;
        this.updated = updated;
        this.offline = offline;
        this.timeToFirstFrame = timeToFirstFrame;
        this.timeStalled = timeStalled;
        this.bandwidth = bandwidth;
        this.bufferedTime = bufferedTime;
        this.bufferedSize = bufferedSize;
        this.xPlexSessionIdentifier = xPlexSessionIdentifier;
    }
    
    public ReportRequest() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty());
    }

    /**
     * Indicates the client accepts the indicated media types
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Accepts> accepts() {
        return (Optional<Accepts>) accepts;
    }

    /**
     * An opaque identifier unique to the client
     */
    @JsonIgnore
    public Optional<String> clientIdentifier() {
        return clientIdentifier;
    }

    /**
     * The name of the client product
     */
    @JsonIgnore
    public Optional<String> product() {
        return product;
    }

    /**
     * The version of the client application
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    /**
     * The platform of the client
     */
    @JsonIgnore
    public Optional<String> platform() {
        return platform;
    }

    /**
     * The version of the platform
     */
    @JsonIgnore
    public Optional<String> platformVersion() {
        return platformVersion;
    }

    /**
     * A relatively friendly name for the client device
     */
    @JsonIgnore
    public Optional<String> device() {
        return device;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    @JsonIgnore
    public Optional<String> model() {
        return model;
    }

    /**
     * The device vendor
     */
    @JsonIgnore
    public Optional<String> deviceVendor() {
        return deviceVendor;
    }

    /**
     * A friendly name for the client
     */
    @JsonIgnore
    public Optional<String> deviceName() {
        return deviceName;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    @JsonIgnore
    public Optional<String> marketplace() {
        return marketplace;
    }

    /**
     * The details key for the item.
     */
    @JsonIgnore
    public Optional<String> key() {
        return key;
    }

    /**
     * The rating key attribute for the item.
     */
    @JsonIgnore
    public Optional<String> ratingKey() {
        return ratingKey;
    }

    /**
     * The current state of the media.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<State> state() {
        return (Optional<State>) state;
    }

    /**
     * If playing media from a play queue, the play queue's ID.
     */
    @JsonIgnore
    public Optional<String> playQueueItemID() {
        return playQueueItemID;
    }

    /**
     * The current time offset of playback in ms.
     */
    @JsonIgnore
    public Optional<Long> time() {
        return time;
    }

    /**
     * The total duration of the item in ms.
     */
    @JsonIgnore
    public Optional<Long> duration() {
        return duration;
    }

    /**
     * When state is `stopped`, a flag indicating whether or not the client is going to continue playing anothe item.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> continuing() {
        return (Optional<BoolInt>) continuing;
    }

    /**
     * Used when a sync client comes online and is syncing media timelines, holds the time at which the playback state was last updated.
     */
    @JsonIgnore
    public Optional<Long> updated() {
        return updated;
    }

    /**
     * Also used by sync clients, used to indicate that a timeline is being synced from being offline, as opposed to being "live".
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> offline() {
        return (Optional<BoolInt>) offline;
    }

    /**
     * Time in seconds till first frame is displayed.  Sent only on the first playing timeline request.
     */
    @JsonIgnore
    public Optional<Long> timeToFirstFrame() {
        return timeToFirstFrame;
    }

    /**
     * Time in seconds spent buffering since last request.
     */
    @JsonIgnore
    public Optional<Long> timeStalled() {
        return timeStalled;
    }

    /**
     * Bandwidth in kbps as estimated by the client.
     */
    @JsonIgnore
    public Optional<Long> bandwidth() {
        return bandwidth;
    }

    /**
     * Amount of time in seconds buffered by client.  Omit if computed by `bufferedSize` below.
     */
    @JsonIgnore
    public Optional<Long> bufferedTime() {
        return bufferedTime;
    }

    /**
     * Size in kilobytes of data buffered by client.  Omit if computed by `bufferedTime` above
     */
    @JsonIgnore
    public Optional<Long> bufferedSize() {
        return bufferedSize;
    }

    /**
     * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
     */
    @JsonIgnore
    public Optional<String> xPlexSessionIdentifier() {
        return xPlexSessionIdentifier;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public ReportRequest withAccepts(Accepts accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = Optional.ofNullable(accepts);
        return this;
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public ReportRequest withAccepts(Optional<? extends Accepts> accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = accepts;
        return this;
    }

    /**
     * An opaque identifier unique to the client
     */
    public ReportRequest withClientIdentifier(String clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = Optional.ofNullable(clientIdentifier);
        return this;
    }


    /**
     * An opaque identifier unique to the client
     */
    public ReportRequest withClientIdentifier(Optional<String> clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = clientIdentifier;
        return this;
    }

    /**
     * The name of the client product
     */
    public ReportRequest withProduct(String product) {
        Utils.checkNotNull(product, "product");
        this.product = Optional.ofNullable(product);
        return this;
    }


    /**
     * The name of the client product
     */
    public ReportRequest withProduct(Optional<String> product) {
        Utils.checkNotNull(product, "product");
        this.product = product;
        return this;
    }

    /**
     * The version of the client application
     */
    public ReportRequest withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }


    /**
     * The version of the client application
     */
    public ReportRequest withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * The platform of the client
     */
    public ReportRequest withPlatform(String platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = Optional.ofNullable(platform);
        return this;
    }


    /**
     * The platform of the client
     */
    public ReportRequest withPlatform(Optional<String> platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = platform;
        return this;
    }

    /**
     * The version of the platform
     */
    public ReportRequest withPlatformVersion(String platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = Optional.ofNullable(platformVersion);
        return this;
    }


    /**
     * The version of the platform
     */
    public ReportRequest withPlatformVersion(Optional<String> platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = platformVersion;
        return this;
    }

    /**
     * A relatively friendly name for the client device
     */
    public ReportRequest withDevice(String device) {
        Utils.checkNotNull(device, "device");
        this.device = Optional.ofNullable(device);
        return this;
    }


    /**
     * A relatively friendly name for the client device
     */
    public ReportRequest withDevice(Optional<String> device) {
        Utils.checkNotNull(device, "device");
        this.device = device;
        return this;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    public ReportRequest withModel(String model) {
        Utils.checkNotNull(model, "model");
        this.model = Optional.ofNullable(model);
        return this;
    }


    /**
     * A potentially less friendly identifier for the device model
     */
    public ReportRequest withModel(Optional<String> model) {
        Utils.checkNotNull(model, "model");
        this.model = model;
        return this;
    }

    /**
     * The device vendor
     */
    public ReportRequest withDeviceVendor(String deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = Optional.ofNullable(deviceVendor);
        return this;
    }


    /**
     * The device vendor
     */
    public ReportRequest withDeviceVendor(Optional<String> deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = deviceVendor;
        return this;
    }

    /**
     * A friendly name for the client
     */
    public ReportRequest withDeviceName(String deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = Optional.ofNullable(deviceName);
        return this;
    }


    /**
     * A friendly name for the client
     */
    public ReportRequest withDeviceName(Optional<String> deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = deviceName;
        return this;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    public ReportRequest withMarketplace(String marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = Optional.ofNullable(marketplace);
        return this;
    }


    /**
     * The marketplace on which the client application is distributed
     */
    public ReportRequest withMarketplace(Optional<String> marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = marketplace;
        return this;
    }

    /**
     * The details key for the item.
     */
    public ReportRequest withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = Optional.ofNullable(key);
        return this;
    }


    /**
     * The details key for the item.
     */
    public ReportRequest withKey(Optional<String> key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    /**
     * The rating key attribute for the item.
     */
    public ReportRequest withRatingKey(String ratingKey) {
        Utils.checkNotNull(ratingKey, "ratingKey");
        this.ratingKey = Optional.ofNullable(ratingKey);
        return this;
    }


    /**
     * The rating key attribute for the item.
     */
    public ReportRequest withRatingKey(Optional<String> ratingKey) {
        Utils.checkNotNull(ratingKey, "ratingKey");
        this.ratingKey = ratingKey;
        return this;
    }

    /**
     * The current state of the media.
     */
    public ReportRequest withState(State state) {
        Utils.checkNotNull(state, "state");
        this.state = Optional.ofNullable(state);
        return this;
    }


    /**
     * The current state of the media.
     */
    public ReportRequest withState(Optional<? extends State> state) {
        Utils.checkNotNull(state, "state");
        this.state = state;
        return this;
    }

    /**
     * If playing media from a play queue, the play queue's ID.
     */
    public ReportRequest withPlayQueueItemID(String playQueueItemID) {
        Utils.checkNotNull(playQueueItemID, "playQueueItemID");
        this.playQueueItemID = Optional.ofNullable(playQueueItemID);
        return this;
    }


    /**
     * If playing media from a play queue, the play queue's ID.
     */
    public ReportRequest withPlayQueueItemID(Optional<String> playQueueItemID) {
        Utils.checkNotNull(playQueueItemID, "playQueueItemID");
        this.playQueueItemID = playQueueItemID;
        return this;
    }

    /**
     * The current time offset of playback in ms.
     */
    public ReportRequest withTime(long time) {
        Utils.checkNotNull(time, "time");
        this.time = Optional.ofNullable(time);
        return this;
    }


    /**
     * The current time offset of playback in ms.
     */
    public ReportRequest withTime(Optional<Long> time) {
        Utils.checkNotNull(time, "time");
        this.time = time;
        return this;
    }

    /**
     * The total duration of the item in ms.
     */
    public ReportRequest withDuration(long duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = Optional.ofNullable(duration);
        return this;
    }


    /**
     * The total duration of the item in ms.
     */
    public ReportRequest withDuration(Optional<Long> duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = duration;
        return this;
    }

    /**
     * When state is `stopped`, a flag indicating whether or not the client is going to continue playing anothe item.
     */
    public ReportRequest withContinuing(BoolInt continuing) {
        Utils.checkNotNull(continuing, "continuing");
        this.continuing = Optional.ofNullable(continuing);
        return this;
    }


    /**
     * When state is `stopped`, a flag indicating whether or not the client is going to continue playing anothe item.
     */
    public ReportRequest withContinuing(Optional<? extends BoolInt> continuing) {
        Utils.checkNotNull(continuing, "continuing");
        this.continuing = continuing;
        return this;
    }

    /**
     * Used when a sync client comes online and is syncing media timelines, holds the time at which the playback state was last updated.
     */
    public ReportRequest withUpdated(long updated) {
        Utils.checkNotNull(updated, "updated");
        this.updated = Optional.ofNullable(updated);
        return this;
    }


    /**
     * Used when a sync client comes online and is syncing media timelines, holds the time at which the playback state was last updated.
     */
    public ReportRequest withUpdated(Optional<Long> updated) {
        Utils.checkNotNull(updated, "updated");
        this.updated = updated;
        return this;
    }

    /**
     * Also used by sync clients, used to indicate that a timeline is being synced from being offline, as opposed to being "live".
     */
    public ReportRequest withOffline(BoolInt offline) {
        Utils.checkNotNull(offline, "offline");
        this.offline = Optional.ofNullable(offline);
        return this;
    }


    /**
     * Also used by sync clients, used to indicate that a timeline is being synced from being offline, as opposed to being "live".
     */
    public ReportRequest withOffline(Optional<? extends BoolInt> offline) {
        Utils.checkNotNull(offline, "offline");
        this.offline = offline;
        return this;
    }

    /**
     * Time in seconds till first frame is displayed.  Sent only on the first playing timeline request.
     */
    public ReportRequest withTimeToFirstFrame(long timeToFirstFrame) {
        Utils.checkNotNull(timeToFirstFrame, "timeToFirstFrame");
        this.timeToFirstFrame = Optional.ofNullable(timeToFirstFrame);
        return this;
    }


    /**
     * Time in seconds till first frame is displayed.  Sent only on the first playing timeline request.
     */
    public ReportRequest withTimeToFirstFrame(Optional<Long> timeToFirstFrame) {
        Utils.checkNotNull(timeToFirstFrame, "timeToFirstFrame");
        this.timeToFirstFrame = timeToFirstFrame;
        return this;
    }

    /**
     * Time in seconds spent buffering since last request.
     */
    public ReportRequest withTimeStalled(long timeStalled) {
        Utils.checkNotNull(timeStalled, "timeStalled");
        this.timeStalled = Optional.ofNullable(timeStalled);
        return this;
    }


    /**
     * Time in seconds spent buffering since last request.
     */
    public ReportRequest withTimeStalled(Optional<Long> timeStalled) {
        Utils.checkNotNull(timeStalled, "timeStalled");
        this.timeStalled = timeStalled;
        return this;
    }

    /**
     * Bandwidth in kbps as estimated by the client.
     */
    public ReportRequest withBandwidth(long bandwidth) {
        Utils.checkNotNull(bandwidth, "bandwidth");
        this.bandwidth = Optional.ofNullable(bandwidth);
        return this;
    }


    /**
     * Bandwidth in kbps as estimated by the client.
     */
    public ReportRequest withBandwidth(Optional<Long> bandwidth) {
        Utils.checkNotNull(bandwidth, "bandwidth");
        this.bandwidth = bandwidth;
        return this;
    }

    /**
     * Amount of time in seconds buffered by client.  Omit if computed by `bufferedSize` below.
     */
    public ReportRequest withBufferedTime(long bufferedTime) {
        Utils.checkNotNull(bufferedTime, "bufferedTime");
        this.bufferedTime = Optional.ofNullable(bufferedTime);
        return this;
    }


    /**
     * Amount of time in seconds buffered by client.  Omit if computed by `bufferedSize` below.
     */
    public ReportRequest withBufferedTime(Optional<Long> bufferedTime) {
        Utils.checkNotNull(bufferedTime, "bufferedTime");
        this.bufferedTime = bufferedTime;
        return this;
    }

    /**
     * Size in kilobytes of data buffered by client.  Omit if computed by `bufferedTime` above
     */
    public ReportRequest withBufferedSize(long bufferedSize) {
        Utils.checkNotNull(bufferedSize, "bufferedSize");
        this.bufferedSize = Optional.ofNullable(bufferedSize);
        return this;
    }


    /**
     * Size in kilobytes of data buffered by client.  Omit if computed by `bufferedTime` above
     */
    public ReportRequest withBufferedSize(Optional<Long> bufferedSize) {
        Utils.checkNotNull(bufferedSize, "bufferedSize");
        this.bufferedSize = bufferedSize;
        return this;
    }

    /**
     * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
     */
    public ReportRequest withXPlexSessionIdentifier(String xPlexSessionIdentifier) {
        Utils.checkNotNull(xPlexSessionIdentifier, "xPlexSessionIdentifier");
        this.xPlexSessionIdentifier = Optional.ofNullable(xPlexSessionIdentifier);
        return this;
    }


    /**
     * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
     */
    public ReportRequest withXPlexSessionIdentifier(Optional<String> xPlexSessionIdentifier) {
        Utils.checkNotNull(xPlexSessionIdentifier, "xPlexSessionIdentifier");
        this.xPlexSessionIdentifier = xPlexSessionIdentifier;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ReportRequest other = (ReportRequest) o;
        return 
            Utils.enhancedDeepEquals(this.accepts, other.accepts) &&
            Utils.enhancedDeepEquals(this.clientIdentifier, other.clientIdentifier) &&
            Utils.enhancedDeepEquals(this.product, other.product) &&
            Utils.enhancedDeepEquals(this.version, other.version) &&
            Utils.enhancedDeepEquals(this.platform, other.platform) &&
            Utils.enhancedDeepEquals(this.platformVersion, other.platformVersion) &&
            Utils.enhancedDeepEquals(this.device, other.device) &&
            Utils.enhancedDeepEquals(this.model, other.model) &&
            Utils.enhancedDeepEquals(this.deviceVendor, other.deviceVendor) &&
            Utils.enhancedDeepEquals(this.deviceName, other.deviceName) &&
            Utils.enhancedDeepEquals(this.marketplace, other.marketplace) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.ratingKey, other.ratingKey) &&
            Utils.enhancedDeepEquals(this.state, other.state) &&
            Utils.enhancedDeepEquals(this.playQueueItemID, other.playQueueItemID) &&
            Utils.enhancedDeepEquals(this.time, other.time) &&
            Utils.enhancedDeepEquals(this.duration, other.duration) &&
            Utils.enhancedDeepEquals(this.continuing, other.continuing) &&
            Utils.enhancedDeepEquals(this.updated, other.updated) &&
            Utils.enhancedDeepEquals(this.offline, other.offline) &&
            Utils.enhancedDeepEquals(this.timeToFirstFrame, other.timeToFirstFrame) &&
            Utils.enhancedDeepEquals(this.timeStalled, other.timeStalled) &&
            Utils.enhancedDeepEquals(this.bandwidth, other.bandwidth) &&
            Utils.enhancedDeepEquals(this.bufferedTime, other.bufferedTime) &&
            Utils.enhancedDeepEquals(this.bufferedSize, other.bufferedSize) &&
            Utils.enhancedDeepEquals(this.xPlexSessionIdentifier, other.xPlexSessionIdentifier);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            accepts, clientIdentifier, product,
            version, platform, platformVersion,
            device, model, deviceVendor,
            deviceName, marketplace, key,
            ratingKey, state, playQueueItemID,
            time, duration, continuing,
            updated, offline, timeToFirstFrame,
            timeStalled, bandwidth, bufferedTime,
            bufferedSize, xPlexSessionIdentifier);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ReportRequest.class,
                "accepts", accepts,
                "clientIdentifier", clientIdentifier,
                "product", product,
                "version", version,
                "platform", platform,
                "platformVersion", platformVersion,
                "device", device,
                "model", model,
                "deviceVendor", deviceVendor,
                "deviceName", deviceName,
                "marketplace", marketplace,
                "key", key,
                "ratingKey", ratingKey,
                "state", state,
                "playQueueItemID", playQueueItemID,
                "time", time,
                "duration", duration,
                "continuing", continuing,
                "updated", updated,
                "offline", offline,
                "timeToFirstFrame", timeToFirstFrame,
                "timeStalled", timeStalled,
                "bandwidth", bandwidth,
                "bufferedTime", bufferedTime,
                "bufferedSize", bufferedSize,
                "xPlexSessionIdentifier", xPlexSessionIdentifier);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends Accepts> accepts;

        private Optional<String> clientIdentifier = Optional.empty();

        private Optional<String> product = Optional.empty();

        private Optional<String> version = Optional.empty();

        private Optional<String> platform = Optional.empty();

        private Optional<String> platformVersion = Optional.empty();

        private Optional<String> device = Optional.empty();

        private Optional<String> model = Optional.empty();

        private Optional<String> deviceVendor = Optional.empty();

        private Optional<String> deviceName = Optional.empty();

        private Optional<String> marketplace = Optional.empty();

        private Optional<String> key = Optional.empty();

        private Optional<String> ratingKey = Optional.empty();

        private Optional<? extends State> state = Optional.empty();

        private Optional<String> playQueueItemID = Optional.empty();

        private Optional<Long> time = Optional.empty();

        private Optional<Long> duration = Optional.empty();

        private Optional<? extends BoolInt> continuing;

        private Optional<Long> updated = Optional.empty();

        private Optional<? extends BoolInt> offline;

        private Optional<Long> timeToFirstFrame = Optional.empty();

        private Optional<Long> timeStalled = Optional.empty();

        private Optional<Long> bandwidth = Optional.empty();

        private Optional<Long> bufferedTime = Optional.empty();

        private Optional<Long> bufferedSize = Optional.empty();

        private Optional<String> xPlexSessionIdentifier = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Accepts accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = Optional.ofNullable(accepts);
            return this;
        }

        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Optional<? extends Accepts> accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = accepts;
            return this;
        }


        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(String clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = Optional.ofNullable(clientIdentifier);
            return this;
        }

        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(Optional<String> clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = clientIdentifier;
            return this;
        }


        /**
         * The name of the client product
         */
        public Builder product(String product) {
            Utils.checkNotNull(product, "product");
            this.product = Optional.ofNullable(product);
            return this;
        }

        /**
         * The name of the client product
         */
        public Builder product(Optional<String> product) {
            Utils.checkNotNull(product, "product");
            this.product = product;
            return this;
        }


        /**
         * The version of the client application
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The version of the client application
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }


        /**
         * The platform of the client
         */
        public Builder platform(String platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = Optional.ofNullable(platform);
            return this;
        }

        /**
         * The platform of the client
         */
        public Builder platform(Optional<String> platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = platform;
            return this;
        }


        /**
         * The version of the platform
         */
        public Builder platformVersion(String platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = Optional.ofNullable(platformVersion);
            return this;
        }

        /**
         * The version of the platform
         */
        public Builder platformVersion(Optional<String> platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = platformVersion;
            return this;
        }


        /**
         * A relatively friendly name for the client device
         */
        public Builder device(String device) {
            Utils.checkNotNull(device, "device");
            this.device = Optional.ofNullable(device);
            return this;
        }

        /**
         * A relatively friendly name for the client device
         */
        public Builder device(Optional<String> device) {
            Utils.checkNotNull(device, "device");
            this.device = device;
            return this;
        }


        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(String model) {
            Utils.checkNotNull(model, "model");
            this.model = Optional.ofNullable(model);
            return this;
        }

        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(Optional<String> model) {
            Utils.checkNotNull(model, "model");
            this.model = model;
            return this;
        }


        /**
         * The device vendor
         */
        public Builder deviceVendor(String deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = Optional.ofNullable(deviceVendor);
            return this;
        }

        /**
         * The device vendor
         */
        public Builder deviceVendor(Optional<String> deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = deviceVendor;
            return this;
        }


        /**
         * A friendly name for the client
         */
        public Builder deviceName(String deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = Optional.ofNullable(deviceName);
            return this;
        }

        /**
         * A friendly name for the client
         */
        public Builder deviceName(Optional<String> deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = deviceName;
            return this;
        }


        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(String marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = Optional.ofNullable(marketplace);
            return this;
        }

        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(Optional<String> marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = marketplace;
            return this;
        }


        /**
         * The details key for the item.
         */
        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = Optional.ofNullable(key);
            return this;
        }

        /**
         * The details key for the item.
         */
        public Builder key(Optional<String> key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        /**
         * The rating key attribute for the item.
         */
        public Builder ratingKey(String ratingKey) {
            Utils.checkNotNull(ratingKey, "ratingKey");
            this.ratingKey = Optional.ofNullable(ratingKey);
            return this;
        }

        /**
         * The rating key attribute for the item.
         */
        public Builder ratingKey(Optional<String> ratingKey) {
            Utils.checkNotNull(ratingKey, "ratingKey");
            this.ratingKey = ratingKey;
            return this;
        }


        /**
         * The current state of the media.
         */
        public Builder state(State state) {
            Utils.checkNotNull(state, "state");
            this.state = Optional.ofNullable(state);
            return this;
        }

        /**
         * The current state of the media.
         */
        public Builder state(Optional<? extends State> state) {
            Utils.checkNotNull(state, "state");
            this.state = state;
            return this;
        }


        /**
         * If playing media from a play queue, the play queue's ID.
         */
        public Builder playQueueItemID(String playQueueItemID) {
            Utils.checkNotNull(playQueueItemID, "playQueueItemID");
            this.playQueueItemID = Optional.ofNullable(playQueueItemID);
            return this;
        }

        /**
         * If playing media from a play queue, the play queue's ID.
         */
        public Builder playQueueItemID(Optional<String> playQueueItemID) {
            Utils.checkNotNull(playQueueItemID, "playQueueItemID");
            this.playQueueItemID = playQueueItemID;
            return this;
        }


        /**
         * The current time offset of playback in ms.
         */
        public Builder time(long time) {
            Utils.checkNotNull(time, "time");
            this.time = Optional.ofNullable(time);
            return this;
        }

        /**
         * The current time offset of playback in ms.
         */
        public Builder time(Optional<Long> time) {
            Utils.checkNotNull(time, "time");
            this.time = time;
            return this;
        }


        /**
         * The total duration of the item in ms.
         */
        public Builder duration(long duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = Optional.ofNullable(duration);
            return this;
        }

        /**
         * The total duration of the item in ms.
         */
        public Builder duration(Optional<Long> duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = duration;
            return this;
        }


        /**
         * When state is `stopped`, a flag indicating whether or not the client is going to continue playing anothe item.
         */
        public Builder continuing(BoolInt continuing) {
            Utils.checkNotNull(continuing, "continuing");
            this.continuing = Optional.ofNullable(continuing);
            return this;
        }

        /**
         * When state is `stopped`, a flag indicating whether or not the client is going to continue playing anothe item.
         */
        public Builder continuing(Optional<? extends BoolInt> continuing) {
            Utils.checkNotNull(continuing, "continuing");
            this.continuing = continuing;
            return this;
        }


        /**
         * Used when a sync client comes online and is syncing media timelines, holds the time at which the playback state was last updated.
         */
        public Builder updated(long updated) {
            Utils.checkNotNull(updated, "updated");
            this.updated = Optional.ofNullable(updated);
            return this;
        }

        /**
         * Used when a sync client comes online and is syncing media timelines, holds the time at which the playback state was last updated.
         */
        public Builder updated(Optional<Long> updated) {
            Utils.checkNotNull(updated, "updated");
            this.updated = updated;
            return this;
        }


        /**
         * Also used by sync clients, used to indicate that a timeline is being synced from being offline, as opposed to being "live".
         */
        public Builder offline(BoolInt offline) {
            Utils.checkNotNull(offline, "offline");
            this.offline = Optional.ofNullable(offline);
            return this;
        }

        /**
         * Also used by sync clients, used to indicate that a timeline is being synced from being offline, as opposed to being "live".
         */
        public Builder offline(Optional<? extends BoolInt> offline) {
            Utils.checkNotNull(offline, "offline");
            this.offline = offline;
            return this;
        }


        /**
         * Time in seconds till first frame is displayed.  Sent only on the first playing timeline request.
         */
        public Builder timeToFirstFrame(long timeToFirstFrame) {
            Utils.checkNotNull(timeToFirstFrame, "timeToFirstFrame");
            this.timeToFirstFrame = Optional.ofNullable(timeToFirstFrame);
            return this;
        }

        /**
         * Time in seconds till first frame is displayed.  Sent only on the first playing timeline request.
         */
        public Builder timeToFirstFrame(Optional<Long> timeToFirstFrame) {
            Utils.checkNotNull(timeToFirstFrame, "timeToFirstFrame");
            this.timeToFirstFrame = timeToFirstFrame;
            return this;
        }


        /**
         * Time in seconds spent buffering since last request.
         */
        public Builder timeStalled(long timeStalled) {
            Utils.checkNotNull(timeStalled, "timeStalled");
            this.timeStalled = Optional.ofNullable(timeStalled);
            return this;
        }

        /**
         * Time in seconds spent buffering since last request.
         */
        public Builder timeStalled(Optional<Long> timeStalled) {
            Utils.checkNotNull(timeStalled, "timeStalled");
            this.timeStalled = timeStalled;
            return this;
        }


        /**
         * Bandwidth in kbps as estimated by the client.
         */
        public Builder bandwidth(long bandwidth) {
            Utils.checkNotNull(bandwidth, "bandwidth");
            this.bandwidth = Optional.ofNullable(bandwidth);
            return this;
        }

        /**
         * Bandwidth in kbps as estimated by the client.
         */
        public Builder bandwidth(Optional<Long> bandwidth) {
            Utils.checkNotNull(bandwidth, "bandwidth");
            this.bandwidth = bandwidth;
            return this;
        }


        /**
         * Amount of time in seconds buffered by client.  Omit if computed by `bufferedSize` below.
         */
        public Builder bufferedTime(long bufferedTime) {
            Utils.checkNotNull(bufferedTime, "bufferedTime");
            this.bufferedTime = Optional.ofNullable(bufferedTime);
            return this;
        }

        /**
         * Amount of time in seconds buffered by client.  Omit if computed by `bufferedSize` below.
         */
        public Builder bufferedTime(Optional<Long> bufferedTime) {
            Utils.checkNotNull(bufferedTime, "bufferedTime");
            this.bufferedTime = bufferedTime;
            return this;
        }


        /**
         * Size in kilobytes of data buffered by client.  Omit if computed by `bufferedTime` above
         */
        public Builder bufferedSize(long bufferedSize) {
            Utils.checkNotNull(bufferedSize, "bufferedSize");
            this.bufferedSize = Optional.ofNullable(bufferedSize);
            return this;
        }

        /**
         * Size in kilobytes of data buffered by client.  Omit if computed by `bufferedTime` above
         */
        public Builder bufferedSize(Optional<Long> bufferedSize) {
            Utils.checkNotNull(bufferedSize, "bufferedSize");
            this.bufferedSize = bufferedSize;
            return this;
        }


        /**
         * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
         */
        public Builder xPlexSessionIdentifier(String xPlexSessionIdentifier) {
            Utils.checkNotNull(xPlexSessionIdentifier, "xPlexSessionIdentifier");
            this.xPlexSessionIdentifier = Optional.ofNullable(xPlexSessionIdentifier);
            return this;
        }

        /**
         * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
         */
        public Builder xPlexSessionIdentifier(Optional<String> xPlexSessionIdentifier) {
            Utils.checkNotNull(xPlexSessionIdentifier, "xPlexSessionIdentifier");
            this.xPlexSessionIdentifier = xPlexSessionIdentifier;
            return this;
        }

        public ReportRequest build() {
            if (accepts == null) {
                accepts = _SINGLETON_VALUE_Accepts.value();
            }
            if (continuing == null) {
                continuing = _SINGLETON_VALUE_Continuing.value();
            }
            if (offline == null) {
                offline = _SINGLETON_VALUE_Offline.value();
            }

            return new ReportRequest(
                accepts, clientIdentifier, product,
                version, platform, platformVersion,
                device, model, deviceVendor,
                deviceName, marketplace, key,
                ratingKey, state, playQueueItemID,
                time, duration, continuing,
                updated, offline, timeToFirstFrame,
                timeStalled, bandwidth, bufferedTime,
                bufferedSize, xPlexSessionIdentifier);
        }


        private static final LazySingletonValue<Optional<? extends Accepts>> _SINGLETON_VALUE_Accepts =
                new LazySingletonValue<>(
                        "accepts",
                        "\"application/xml\"",
                        new TypeReference<Optional<? extends Accepts>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_Continuing =
                new LazySingletonValue<>(
                        "continuing",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_Offline =
                new LazySingletonValue<>(
                        "offline",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});
    }
}
