/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.models.shared.Accepts;
import dev.plexapi.sdk.models.shared.BoolInt;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.SpeakeasyMetadata;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;


public class GetLibraryMatchesRequest {
    /**
     * Indicates the client accepts the indicated media types
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=accepts")
    private Optional<? extends Accepts> accepts;

    /**
     * An opaque identifier unique to the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Client-Identifier")
    private Optional<String> clientIdentifier;

    /**
     * The name of the client product
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Product")
    private Optional<String> product;

    /**
     * The version of the client application
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Version")
    private Optional<String> version;

    /**
     * The platform of the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform")
    private Optional<String> platform;

    /**
     * The version of the platform
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform-Version")
    private Optional<String> platformVersion;

    /**
     * A relatively friendly name for the client device
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device")
    private Optional<String> device;

    /**
     * A potentially less friendly identifier for the device model
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Model")
    private Optional<String> model;

    /**
     * The device vendor
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Vendor")
    private Optional<String> deviceVendor;

    /**
     * A friendly name for the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Name")
    private Optional<String> deviceName;

    /**
     * The marketplace on which the client application is distributed
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Marketplace")
    private Optional<String> marketplace;

    /**
     * The metadata type to filter by
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=type")
    private Optional<Long> type;


    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=includeFullMetadata")
    private Optional<? extends BoolInt> includeFullMetadata;


    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=includeAncestorMetadata")
    private Optional<? extends BoolInt> includeAncestorMetadata;


    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=includeAlternateMetadataSources")
    private Optional<? extends BoolInt> includeAlternateMetadataSources;

    /**
     * Used for movies, shows, artists, albums, and tracks.  Allowed for various URI schemes, to be defined.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=guid")
    private Optional<String> guid;

    /**
     * The title to filter by or assign
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=title")
    private Optional<String> title;

    /**
     * Used for movies shows, and albums.  Optional.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=year")
    private Optional<Long> year;

    /**
     * Used for movies, episodes, and tracks.  The full path to the media file, used for "cloud-scanning" an item.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=path")
    private Optional<String> path;

    /**
     * Used for episodes and tracks.  The title of the show/artist. Required if `path` isn't passed.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=grandparentTitle")
    private Optional<String> grandparentTitle;

    /**
     * Used for episodes.  The year of the show.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=grandparentYear")
    private Optional<Long> grandparentYear;

    /**
     * Used for episodes and tracks.  The season/album number.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=parentIndex")
    private Optional<Long> parentIndex;

    /**
     * Used for episodes and tracks.  The episode/tracks number in the season/album.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=index")
    private Optional<Long> index;

    /**
     * Used for episodes.  In the format `YYYY-MM-DD`.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=originallyAvailableAt")
    private Optional<String> originallyAvailableAt;

    /**
     * Used for albums and tracks. The artist name for albums or the album name for tracks.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=parentTitle")
    private Optional<String> parentTitle;

    @JsonCreator
    public GetLibraryMatchesRequest(
            Optional<? extends Accepts> accepts,
            Optional<String> clientIdentifier,
            Optional<String> product,
            Optional<String> version,
            Optional<String> platform,
            Optional<String> platformVersion,
            Optional<String> device,
            Optional<String> model,
            Optional<String> deviceVendor,
            Optional<String> deviceName,
            Optional<String> marketplace,
            Optional<Long> type,
            Optional<? extends BoolInt> includeFullMetadata,
            Optional<? extends BoolInt> includeAncestorMetadata,
            Optional<? extends BoolInt> includeAlternateMetadataSources,
            Optional<String> guid,
            Optional<String> title,
            Optional<Long> year,
            Optional<String> path,
            Optional<String> grandparentTitle,
            Optional<Long> grandparentYear,
            Optional<Long> parentIndex,
            Optional<Long> index,
            Optional<String> originallyAvailableAt,
            Optional<String> parentTitle) {
        Utils.checkNotNull(accepts, "accepts");
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        Utils.checkNotNull(product, "product");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(platform, "platform");
        Utils.checkNotNull(platformVersion, "platformVersion");
        Utils.checkNotNull(device, "device");
        Utils.checkNotNull(model, "model");
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        Utils.checkNotNull(deviceName, "deviceName");
        Utils.checkNotNull(marketplace, "marketplace");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(includeFullMetadata, "includeFullMetadata");
        Utils.checkNotNull(includeAncestorMetadata, "includeAncestorMetadata");
        Utils.checkNotNull(includeAlternateMetadataSources, "includeAlternateMetadataSources");
        Utils.checkNotNull(guid, "guid");
        Utils.checkNotNull(title, "title");
        Utils.checkNotNull(year, "year");
        Utils.checkNotNull(path, "path");
        Utils.checkNotNull(grandparentTitle, "grandparentTitle");
        Utils.checkNotNull(grandparentYear, "grandparentYear");
        Utils.checkNotNull(parentIndex, "parentIndex");
        Utils.checkNotNull(index, "index");
        Utils.checkNotNull(originallyAvailableAt, "originallyAvailableAt");
        Utils.checkNotNull(parentTitle, "parentTitle");
        this.accepts = accepts;
        this.clientIdentifier = clientIdentifier;
        this.product = product;
        this.version = version;
        this.platform = platform;
        this.platformVersion = platformVersion;
        this.device = device;
        this.model = model;
        this.deviceVendor = deviceVendor;
        this.deviceName = deviceName;
        this.marketplace = marketplace;
        this.type = type;
        this.includeFullMetadata = includeFullMetadata;
        this.includeAncestorMetadata = includeAncestorMetadata;
        this.includeAlternateMetadataSources = includeAlternateMetadataSources;
        this.guid = guid;
        this.title = title;
        this.year = year;
        this.path = path;
        this.grandparentTitle = grandparentTitle;
        this.grandparentYear = grandparentYear;
        this.parentIndex = parentIndex;
        this.index = index;
        this.originallyAvailableAt = originallyAvailableAt;
        this.parentTitle = parentTitle;
    }
    
    public GetLibraryMatchesRequest() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty());
    }

    /**
     * Indicates the client accepts the indicated media types
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Accepts> accepts() {
        return (Optional<Accepts>) accepts;
    }

    /**
     * An opaque identifier unique to the client
     */
    @JsonIgnore
    public Optional<String> clientIdentifier() {
        return clientIdentifier;
    }

    /**
     * The name of the client product
     */
    @JsonIgnore
    public Optional<String> product() {
        return product;
    }

    /**
     * The version of the client application
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    /**
     * The platform of the client
     */
    @JsonIgnore
    public Optional<String> platform() {
        return platform;
    }

    /**
     * The version of the platform
     */
    @JsonIgnore
    public Optional<String> platformVersion() {
        return platformVersion;
    }

    /**
     * A relatively friendly name for the client device
     */
    @JsonIgnore
    public Optional<String> device() {
        return device;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    @JsonIgnore
    public Optional<String> model() {
        return model;
    }

    /**
     * The device vendor
     */
    @JsonIgnore
    public Optional<String> deviceVendor() {
        return deviceVendor;
    }

    /**
     * A friendly name for the client
     */
    @JsonIgnore
    public Optional<String> deviceName() {
        return deviceName;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    @JsonIgnore
    public Optional<String> marketplace() {
        return marketplace;
    }

    /**
     * The metadata type to filter by
     */
    @JsonIgnore
    public Optional<Long> type() {
        return type;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> includeFullMetadata() {
        return (Optional<BoolInt>) includeFullMetadata;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> includeAncestorMetadata() {
        return (Optional<BoolInt>) includeAncestorMetadata;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> includeAlternateMetadataSources() {
        return (Optional<BoolInt>) includeAlternateMetadataSources;
    }

    /**
     * Used for movies, shows, artists, albums, and tracks.  Allowed for various URI schemes, to be defined.
     */
    @JsonIgnore
    public Optional<String> guid() {
        return guid;
    }

    /**
     * The title to filter by or assign
     */
    @JsonIgnore
    public Optional<String> title() {
        return title;
    }

    /**
     * Used for movies shows, and albums.  Optional.
     */
    @JsonIgnore
    public Optional<Long> year() {
        return year;
    }

    /**
     * Used for movies, episodes, and tracks.  The full path to the media file, used for "cloud-scanning" an item.
     */
    @JsonIgnore
    public Optional<String> path() {
        return path;
    }

    /**
     * Used for episodes and tracks.  The title of the show/artist. Required if `path` isn't passed.
     */
    @JsonIgnore
    public Optional<String> grandparentTitle() {
        return grandparentTitle;
    }

    /**
     * Used for episodes.  The year of the show.
     */
    @JsonIgnore
    public Optional<Long> grandparentYear() {
        return grandparentYear;
    }

    /**
     * Used for episodes and tracks.  The season/album number.
     */
    @JsonIgnore
    public Optional<Long> parentIndex() {
        return parentIndex;
    }

    /**
     * Used for episodes and tracks.  The episode/tracks number in the season/album.
     */
    @JsonIgnore
    public Optional<Long> index() {
        return index;
    }

    /**
     * Used for episodes.  In the format `YYYY-MM-DD`.
     */
    @JsonIgnore
    public Optional<String> originallyAvailableAt() {
        return originallyAvailableAt;
    }

    /**
     * Used for albums and tracks. The artist name for albums or the album name for tracks.
     */
    @JsonIgnore
    public Optional<String> parentTitle() {
        return parentTitle;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public GetLibraryMatchesRequest withAccepts(Accepts accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = Optional.ofNullable(accepts);
        return this;
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public GetLibraryMatchesRequest withAccepts(Optional<? extends Accepts> accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = accepts;
        return this;
    }

    /**
     * An opaque identifier unique to the client
     */
    public GetLibraryMatchesRequest withClientIdentifier(String clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = Optional.ofNullable(clientIdentifier);
        return this;
    }


    /**
     * An opaque identifier unique to the client
     */
    public GetLibraryMatchesRequest withClientIdentifier(Optional<String> clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = clientIdentifier;
        return this;
    }

    /**
     * The name of the client product
     */
    public GetLibraryMatchesRequest withProduct(String product) {
        Utils.checkNotNull(product, "product");
        this.product = Optional.ofNullable(product);
        return this;
    }


    /**
     * The name of the client product
     */
    public GetLibraryMatchesRequest withProduct(Optional<String> product) {
        Utils.checkNotNull(product, "product");
        this.product = product;
        return this;
    }

    /**
     * The version of the client application
     */
    public GetLibraryMatchesRequest withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }


    /**
     * The version of the client application
     */
    public GetLibraryMatchesRequest withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * The platform of the client
     */
    public GetLibraryMatchesRequest withPlatform(String platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = Optional.ofNullable(platform);
        return this;
    }


    /**
     * The platform of the client
     */
    public GetLibraryMatchesRequest withPlatform(Optional<String> platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = platform;
        return this;
    }

    /**
     * The version of the platform
     */
    public GetLibraryMatchesRequest withPlatformVersion(String platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = Optional.ofNullable(platformVersion);
        return this;
    }


    /**
     * The version of the platform
     */
    public GetLibraryMatchesRequest withPlatformVersion(Optional<String> platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = platformVersion;
        return this;
    }

    /**
     * A relatively friendly name for the client device
     */
    public GetLibraryMatchesRequest withDevice(String device) {
        Utils.checkNotNull(device, "device");
        this.device = Optional.ofNullable(device);
        return this;
    }


    /**
     * A relatively friendly name for the client device
     */
    public GetLibraryMatchesRequest withDevice(Optional<String> device) {
        Utils.checkNotNull(device, "device");
        this.device = device;
        return this;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    public GetLibraryMatchesRequest withModel(String model) {
        Utils.checkNotNull(model, "model");
        this.model = Optional.ofNullable(model);
        return this;
    }


    /**
     * A potentially less friendly identifier for the device model
     */
    public GetLibraryMatchesRequest withModel(Optional<String> model) {
        Utils.checkNotNull(model, "model");
        this.model = model;
        return this;
    }

    /**
     * The device vendor
     */
    public GetLibraryMatchesRequest withDeviceVendor(String deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = Optional.ofNullable(deviceVendor);
        return this;
    }


    /**
     * The device vendor
     */
    public GetLibraryMatchesRequest withDeviceVendor(Optional<String> deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = deviceVendor;
        return this;
    }

    /**
     * A friendly name for the client
     */
    public GetLibraryMatchesRequest withDeviceName(String deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = Optional.ofNullable(deviceName);
        return this;
    }


    /**
     * A friendly name for the client
     */
    public GetLibraryMatchesRequest withDeviceName(Optional<String> deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = deviceName;
        return this;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    public GetLibraryMatchesRequest withMarketplace(String marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = Optional.ofNullable(marketplace);
        return this;
    }


    /**
     * The marketplace on which the client application is distributed
     */
    public GetLibraryMatchesRequest withMarketplace(Optional<String> marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = marketplace;
        return this;
    }

    /**
     * The metadata type to filter by
     */
    public GetLibraryMatchesRequest withType(long type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }


    /**
     * The metadata type to filter by
     */
    public GetLibraryMatchesRequest withType(Optional<Long> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    public GetLibraryMatchesRequest withIncludeFullMetadata(BoolInt includeFullMetadata) {
        Utils.checkNotNull(includeFullMetadata, "includeFullMetadata");
        this.includeFullMetadata = Optional.ofNullable(includeFullMetadata);
        return this;
    }


    public GetLibraryMatchesRequest withIncludeFullMetadata(Optional<? extends BoolInt> includeFullMetadata) {
        Utils.checkNotNull(includeFullMetadata, "includeFullMetadata");
        this.includeFullMetadata = includeFullMetadata;
        return this;
    }

    public GetLibraryMatchesRequest withIncludeAncestorMetadata(BoolInt includeAncestorMetadata) {
        Utils.checkNotNull(includeAncestorMetadata, "includeAncestorMetadata");
        this.includeAncestorMetadata = Optional.ofNullable(includeAncestorMetadata);
        return this;
    }


    public GetLibraryMatchesRequest withIncludeAncestorMetadata(Optional<? extends BoolInt> includeAncestorMetadata) {
        Utils.checkNotNull(includeAncestorMetadata, "includeAncestorMetadata");
        this.includeAncestorMetadata = includeAncestorMetadata;
        return this;
    }

    public GetLibraryMatchesRequest withIncludeAlternateMetadataSources(BoolInt includeAlternateMetadataSources) {
        Utils.checkNotNull(includeAlternateMetadataSources, "includeAlternateMetadataSources");
        this.includeAlternateMetadataSources = Optional.ofNullable(includeAlternateMetadataSources);
        return this;
    }


    public GetLibraryMatchesRequest withIncludeAlternateMetadataSources(Optional<? extends BoolInt> includeAlternateMetadataSources) {
        Utils.checkNotNull(includeAlternateMetadataSources, "includeAlternateMetadataSources");
        this.includeAlternateMetadataSources = includeAlternateMetadataSources;
        return this;
    }

    /**
     * Used for movies, shows, artists, albums, and tracks.  Allowed for various URI schemes, to be defined.
     */
    public GetLibraryMatchesRequest withGuid(String guid) {
        Utils.checkNotNull(guid, "guid");
        this.guid = Optional.ofNullable(guid);
        return this;
    }


    /**
     * Used for movies, shows, artists, albums, and tracks.  Allowed for various URI schemes, to be defined.
     */
    public GetLibraryMatchesRequest withGuid(Optional<String> guid) {
        Utils.checkNotNull(guid, "guid");
        this.guid = guid;
        return this;
    }

    /**
     * The title to filter by or assign
     */
    public GetLibraryMatchesRequest withTitle(String title) {
        Utils.checkNotNull(title, "title");
        this.title = Optional.ofNullable(title);
        return this;
    }


    /**
     * The title to filter by or assign
     */
    public GetLibraryMatchesRequest withTitle(Optional<String> title) {
        Utils.checkNotNull(title, "title");
        this.title = title;
        return this;
    }

    /**
     * Used for movies shows, and albums.  Optional.
     */
    public GetLibraryMatchesRequest withYear(long year) {
        Utils.checkNotNull(year, "year");
        this.year = Optional.ofNullable(year);
        return this;
    }


    /**
     * Used for movies shows, and albums.  Optional.
     */
    public GetLibraryMatchesRequest withYear(Optional<Long> year) {
        Utils.checkNotNull(year, "year");
        this.year = year;
        return this;
    }

    /**
     * Used for movies, episodes, and tracks.  The full path to the media file, used for "cloud-scanning" an item.
     */
    public GetLibraryMatchesRequest withPath(String path) {
        Utils.checkNotNull(path, "path");
        this.path = Optional.ofNullable(path);
        return this;
    }


    /**
     * Used for movies, episodes, and tracks.  The full path to the media file, used for "cloud-scanning" an item.
     */
    public GetLibraryMatchesRequest withPath(Optional<String> path) {
        Utils.checkNotNull(path, "path");
        this.path = path;
        return this;
    }

    /**
     * Used for episodes and tracks.  The title of the show/artist. Required if `path` isn't passed.
     */
    public GetLibraryMatchesRequest withGrandparentTitle(String grandparentTitle) {
        Utils.checkNotNull(grandparentTitle, "grandparentTitle");
        this.grandparentTitle = Optional.ofNullable(grandparentTitle);
        return this;
    }


    /**
     * Used for episodes and tracks.  The title of the show/artist. Required if `path` isn't passed.
     */
    public GetLibraryMatchesRequest withGrandparentTitle(Optional<String> grandparentTitle) {
        Utils.checkNotNull(grandparentTitle, "grandparentTitle");
        this.grandparentTitle = grandparentTitle;
        return this;
    }

    /**
     * Used for episodes.  The year of the show.
     */
    public GetLibraryMatchesRequest withGrandparentYear(long grandparentYear) {
        Utils.checkNotNull(grandparentYear, "grandparentYear");
        this.grandparentYear = Optional.ofNullable(grandparentYear);
        return this;
    }


    /**
     * Used for episodes.  The year of the show.
     */
    public GetLibraryMatchesRequest withGrandparentYear(Optional<Long> grandparentYear) {
        Utils.checkNotNull(grandparentYear, "grandparentYear");
        this.grandparentYear = grandparentYear;
        return this;
    }

    /**
     * Used for episodes and tracks.  The season/album number.
     */
    public GetLibraryMatchesRequest withParentIndex(long parentIndex) {
        Utils.checkNotNull(parentIndex, "parentIndex");
        this.parentIndex = Optional.ofNullable(parentIndex);
        return this;
    }


    /**
     * Used for episodes and tracks.  The season/album number.
     */
    public GetLibraryMatchesRequest withParentIndex(Optional<Long> parentIndex) {
        Utils.checkNotNull(parentIndex, "parentIndex");
        this.parentIndex = parentIndex;
        return this;
    }

    /**
     * Used for episodes and tracks.  The episode/tracks number in the season/album.
     */
    public GetLibraryMatchesRequest withIndex(long index) {
        Utils.checkNotNull(index, "index");
        this.index = Optional.ofNullable(index);
        return this;
    }


    /**
     * Used for episodes and tracks.  The episode/tracks number in the season/album.
     */
    public GetLibraryMatchesRequest withIndex(Optional<Long> index) {
        Utils.checkNotNull(index, "index");
        this.index = index;
        return this;
    }

    /**
     * Used for episodes.  In the format `YYYY-MM-DD`.
     */
    public GetLibraryMatchesRequest withOriginallyAvailableAt(String originallyAvailableAt) {
        Utils.checkNotNull(originallyAvailableAt, "originallyAvailableAt");
        this.originallyAvailableAt = Optional.ofNullable(originallyAvailableAt);
        return this;
    }


    /**
     * Used for episodes.  In the format `YYYY-MM-DD`.
     */
    public GetLibraryMatchesRequest withOriginallyAvailableAt(Optional<String> originallyAvailableAt) {
        Utils.checkNotNull(originallyAvailableAt, "originallyAvailableAt");
        this.originallyAvailableAt = originallyAvailableAt;
        return this;
    }

    /**
     * Used for albums and tracks. The artist name for albums or the album name for tracks.
     */
    public GetLibraryMatchesRequest withParentTitle(String parentTitle) {
        Utils.checkNotNull(parentTitle, "parentTitle");
        this.parentTitle = Optional.ofNullable(parentTitle);
        return this;
    }


    /**
     * Used for albums and tracks. The artist name for albums or the album name for tracks.
     */
    public GetLibraryMatchesRequest withParentTitle(Optional<String> parentTitle) {
        Utils.checkNotNull(parentTitle, "parentTitle");
        this.parentTitle = parentTitle;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        GetLibraryMatchesRequest other = (GetLibraryMatchesRequest) o;
        return 
            Utils.enhancedDeepEquals(this.accepts, other.accepts) &&
            Utils.enhancedDeepEquals(this.clientIdentifier, other.clientIdentifier) &&
            Utils.enhancedDeepEquals(this.product, other.product) &&
            Utils.enhancedDeepEquals(this.version, other.version) &&
            Utils.enhancedDeepEquals(this.platform, other.platform) &&
            Utils.enhancedDeepEquals(this.platformVersion, other.platformVersion) &&
            Utils.enhancedDeepEquals(this.device, other.device) &&
            Utils.enhancedDeepEquals(this.model, other.model) &&
            Utils.enhancedDeepEquals(this.deviceVendor, other.deviceVendor) &&
            Utils.enhancedDeepEquals(this.deviceName, other.deviceName) &&
            Utils.enhancedDeepEquals(this.marketplace, other.marketplace) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.includeFullMetadata, other.includeFullMetadata) &&
            Utils.enhancedDeepEquals(this.includeAncestorMetadata, other.includeAncestorMetadata) &&
            Utils.enhancedDeepEquals(this.includeAlternateMetadataSources, other.includeAlternateMetadataSources) &&
            Utils.enhancedDeepEquals(this.guid, other.guid) &&
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.year, other.year) &&
            Utils.enhancedDeepEquals(this.path, other.path) &&
            Utils.enhancedDeepEquals(this.grandparentTitle, other.grandparentTitle) &&
            Utils.enhancedDeepEquals(this.grandparentYear, other.grandparentYear) &&
            Utils.enhancedDeepEquals(this.parentIndex, other.parentIndex) &&
            Utils.enhancedDeepEquals(this.index, other.index) &&
            Utils.enhancedDeepEquals(this.originallyAvailableAt, other.originallyAvailableAt) &&
            Utils.enhancedDeepEquals(this.parentTitle, other.parentTitle);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            accepts, clientIdentifier, product,
            version, platform, platformVersion,
            device, model, deviceVendor,
            deviceName, marketplace, type,
            includeFullMetadata, includeAncestorMetadata, includeAlternateMetadataSources,
            guid, title, year,
            path, grandparentTitle, grandparentYear,
            parentIndex, index, originallyAvailableAt,
            parentTitle);
    }
    
    @Override
    public String toString() {
        return Utils.toString(GetLibraryMatchesRequest.class,
                "accepts", accepts,
                "clientIdentifier", clientIdentifier,
                "product", product,
                "version", version,
                "platform", platform,
                "platformVersion", platformVersion,
                "device", device,
                "model", model,
                "deviceVendor", deviceVendor,
                "deviceName", deviceName,
                "marketplace", marketplace,
                "type", type,
                "includeFullMetadata", includeFullMetadata,
                "includeAncestorMetadata", includeAncestorMetadata,
                "includeAlternateMetadataSources", includeAlternateMetadataSources,
                "guid", guid,
                "title", title,
                "year", year,
                "path", path,
                "grandparentTitle", grandparentTitle,
                "grandparentYear", grandparentYear,
                "parentIndex", parentIndex,
                "index", index,
                "originallyAvailableAt", originallyAvailableAt,
                "parentTitle", parentTitle);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends Accepts> accepts;

        private Optional<String> clientIdentifier = Optional.empty();

        private Optional<String> product = Optional.empty();

        private Optional<String> version = Optional.empty();

        private Optional<String> platform = Optional.empty();

        private Optional<String> platformVersion = Optional.empty();

        private Optional<String> device = Optional.empty();

        private Optional<String> model = Optional.empty();

        private Optional<String> deviceVendor = Optional.empty();

        private Optional<String> deviceName = Optional.empty();

        private Optional<String> marketplace = Optional.empty();

        private Optional<Long> type = Optional.empty();

        private Optional<? extends BoolInt> includeFullMetadata = Optional.empty();

        private Optional<? extends BoolInt> includeAncestorMetadata = Optional.empty();

        private Optional<? extends BoolInt> includeAlternateMetadataSources = Optional.empty();

        private Optional<String> guid = Optional.empty();

        private Optional<String> title = Optional.empty();

        private Optional<Long> year = Optional.empty();

        private Optional<String> path = Optional.empty();

        private Optional<String> grandparentTitle = Optional.empty();

        private Optional<Long> grandparentYear = Optional.empty();

        private Optional<Long> parentIndex = Optional.empty();

        private Optional<Long> index = Optional.empty();

        private Optional<String> originallyAvailableAt = Optional.empty();

        private Optional<String> parentTitle = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Accepts accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = Optional.ofNullable(accepts);
            return this;
        }

        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Optional<? extends Accepts> accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = accepts;
            return this;
        }


        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(String clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = Optional.ofNullable(clientIdentifier);
            return this;
        }

        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(Optional<String> clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = clientIdentifier;
            return this;
        }


        /**
         * The name of the client product
         */
        public Builder product(String product) {
            Utils.checkNotNull(product, "product");
            this.product = Optional.ofNullable(product);
            return this;
        }

        /**
         * The name of the client product
         */
        public Builder product(Optional<String> product) {
            Utils.checkNotNull(product, "product");
            this.product = product;
            return this;
        }


        /**
         * The version of the client application
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The version of the client application
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }


        /**
         * The platform of the client
         */
        public Builder platform(String platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = Optional.ofNullable(platform);
            return this;
        }

        /**
         * The platform of the client
         */
        public Builder platform(Optional<String> platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = platform;
            return this;
        }


        /**
         * The version of the platform
         */
        public Builder platformVersion(String platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = Optional.ofNullable(platformVersion);
            return this;
        }

        /**
         * The version of the platform
         */
        public Builder platformVersion(Optional<String> platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = platformVersion;
            return this;
        }


        /**
         * A relatively friendly name for the client device
         */
        public Builder device(String device) {
            Utils.checkNotNull(device, "device");
            this.device = Optional.ofNullable(device);
            return this;
        }

        /**
         * A relatively friendly name for the client device
         */
        public Builder device(Optional<String> device) {
            Utils.checkNotNull(device, "device");
            this.device = device;
            return this;
        }


        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(String model) {
            Utils.checkNotNull(model, "model");
            this.model = Optional.ofNullable(model);
            return this;
        }

        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(Optional<String> model) {
            Utils.checkNotNull(model, "model");
            this.model = model;
            return this;
        }


        /**
         * The device vendor
         */
        public Builder deviceVendor(String deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = Optional.ofNullable(deviceVendor);
            return this;
        }

        /**
         * The device vendor
         */
        public Builder deviceVendor(Optional<String> deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = deviceVendor;
            return this;
        }


        /**
         * A friendly name for the client
         */
        public Builder deviceName(String deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = Optional.ofNullable(deviceName);
            return this;
        }

        /**
         * A friendly name for the client
         */
        public Builder deviceName(Optional<String> deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = deviceName;
            return this;
        }


        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(String marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = Optional.ofNullable(marketplace);
            return this;
        }

        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(Optional<String> marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = marketplace;
            return this;
        }


        /**
         * The metadata type to filter by
         */
        public Builder type(long type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * The metadata type to filter by
         */
        public Builder type(Optional<Long> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }


        public Builder includeFullMetadata(BoolInt includeFullMetadata) {
            Utils.checkNotNull(includeFullMetadata, "includeFullMetadata");
            this.includeFullMetadata = Optional.ofNullable(includeFullMetadata);
            return this;
        }

        public Builder includeFullMetadata(Optional<? extends BoolInt> includeFullMetadata) {
            Utils.checkNotNull(includeFullMetadata, "includeFullMetadata");
            this.includeFullMetadata = includeFullMetadata;
            return this;
        }


        public Builder includeAncestorMetadata(BoolInt includeAncestorMetadata) {
            Utils.checkNotNull(includeAncestorMetadata, "includeAncestorMetadata");
            this.includeAncestorMetadata = Optional.ofNullable(includeAncestorMetadata);
            return this;
        }

        public Builder includeAncestorMetadata(Optional<? extends BoolInt> includeAncestorMetadata) {
            Utils.checkNotNull(includeAncestorMetadata, "includeAncestorMetadata");
            this.includeAncestorMetadata = includeAncestorMetadata;
            return this;
        }


        public Builder includeAlternateMetadataSources(BoolInt includeAlternateMetadataSources) {
            Utils.checkNotNull(includeAlternateMetadataSources, "includeAlternateMetadataSources");
            this.includeAlternateMetadataSources = Optional.ofNullable(includeAlternateMetadataSources);
            return this;
        }

        public Builder includeAlternateMetadataSources(Optional<? extends BoolInt> includeAlternateMetadataSources) {
            Utils.checkNotNull(includeAlternateMetadataSources, "includeAlternateMetadataSources");
            this.includeAlternateMetadataSources = includeAlternateMetadataSources;
            return this;
        }


        /**
         * Used for movies, shows, artists, albums, and tracks.  Allowed for various URI schemes, to be defined.
         */
        public Builder guid(String guid) {
            Utils.checkNotNull(guid, "guid");
            this.guid = Optional.ofNullable(guid);
            return this;
        }

        /**
         * Used for movies, shows, artists, albums, and tracks.  Allowed for various URI schemes, to be defined.
         */
        public Builder guid(Optional<String> guid) {
            Utils.checkNotNull(guid, "guid");
            this.guid = guid;
            return this;
        }


        /**
         * The title to filter by or assign
         */
        public Builder title(String title) {
            Utils.checkNotNull(title, "title");
            this.title = Optional.ofNullable(title);
            return this;
        }

        /**
         * The title to filter by or assign
         */
        public Builder title(Optional<String> title) {
            Utils.checkNotNull(title, "title");
            this.title = title;
            return this;
        }


        /**
         * Used for movies shows, and albums.  Optional.
         */
        public Builder year(long year) {
            Utils.checkNotNull(year, "year");
            this.year = Optional.ofNullable(year);
            return this;
        }

        /**
         * Used for movies shows, and albums.  Optional.
         */
        public Builder year(Optional<Long> year) {
            Utils.checkNotNull(year, "year");
            this.year = year;
            return this;
        }


        /**
         * Used for movies, episodes, and tracks.  The full path to the media file, used for "cloud-scanning" an item.
         */
        public Builder path(String path) {
            Utils.checkNotNull(path, "path");
            this.path = Optional.ofNullable(path);
            return this;
        }

        /**
         * Used for movies, episodes, and tracks.  The full path to the media file, used for "cloud-scanning" an item.
         */
        public Builder path(Optional<String> path) {
            Utils.checkNotNull(path, "path");
            this.path = path;
            return this;
        }


        /**
         * Used for episodes and tracks.  The title of the show/artist. Required if `path` isn't passed.
         */
        public Builder grandparentTitle(String grandparentTitle) {
            Utils.checkNotNull(grandparentTitle, "grandparentTitle");
            this.grandparentTitle = Optional.ofNullable(grandparentTitle);
            return this;
        }

        /**
         * Used for episodes and tracks.  The title of the show/artist. Required if `path` isn't passed.
         */
        public Builder grandparentTitle(Optional<String> grandparentTitle) {
            Utils.checkNotNull(grandparentTitle, "grandparentTitle");
            this.grandparentTitle = grandparentTitle;
            return this;
        }


        /**
         * Used for episodes.  The year of the show.
         */
        public Builder grandparentYear(long grandparentYear) {
            Utils.checkNotNull(grandparentYear, "grandparentYear");
            this.grandparentYear = Optional.ofNullable(grandparentYear);
            return this;
        }

        /**
         * Used for episodes.  The year of the show.
         */
        public Builder grandparentYear(Optional<Long> grandparentYear) {
            Utils.checkNotNull(grandparentYear, "grandparentYear");
            this.grandparentYear = grandparentYear;
            return this;
        }


        /**
         * Used for episodes and tracks.  The season/album number.
         */
        public Builder parentIndex(long parentIndex) {
            Utils.checkNotNull(parentIndex, "parentIndex");
            this.parentIndex = Optional.ofNullable(parentIndex);
            return this;
        }

        /**
         * Used for episodes and tracks.  The season/album number.
         */
        public Builder parentIndex(Optional<Long> parentIndex) {
            Utils.checkNotNull(parentIndex, "parentIndex");
            this.parentIndex = parentIndex;
            return this;
        }


        /**
         * Used for episodes and tracks.  The episode/tracks number in the season/album.
         */
        public Builder index(long index) {
            Utils.checkNotNull(index, "index");
            this.index = Optional.ofNullable(index);
            return this;
        }

        /**
         * Used for episodes and tracks.  The episode/tracks number in the season/album.
         */
        public Builder index(Optional<Long> index) {
            Utils.checkNotNull(index, "index");
            this.index = index;
            return this;
        }


        /**
         * Used for episodes.  In the format `YYYY-MM-DD`.
         */
        public Builder originallyAvailableAt(String originallyAvailableAt) {
            Utils.checkNotNull(originallyAvailableAt, "originallyAvailableAt");
            this.originallyAvailableAt = Optional.ofNullable(originallyAvailableAt);
            return this;
        }

        /**
         * Used for episodes.  In the format `YYYY-MM-DD`.
         */
        public Builder originallyAvailableAt(Optional<String> originallyAvailableAt) {
            Utils.checkNotNull(originallyAvailableAt, "originallyAvailableAt");
            this.originallyAvailableAt = originallyAvailableAt;
            return this;
        }


        /**
         * Used for albums and tracks. The artist name for albums or the album name for tracks.
         */
        public Builder parentTitle(String parentTitle) {
            Utils.checkNotNull(parentTitle, "parentTitle");
            this.parentTitle = Optional.ofNullable(parentTitle);
            return this;
        }

        /**
         * Used for albums and tracks. The artist name for albums or the album name for tracks.
         */
        public Builder parentTitle(Optional<String> parentTitle) {
            Utils.checkNotNull(parentTitle, "parentTitle");
            this.parentTitle = parentTitle;
            return this;
        }

        public GetLibraryMatchesRequest build() {
            if (accepts == null) {
                accepts = _SINGLETON_VALUE_Accepts.value();
            }

            return new GetLibraryMatchesRequest(
                accepts, clientIdentifier, product,
                version, platform, platformVersion,
                device, model, deviceVendor,
                deviceName, marketplace, type,
                includeFullMetadata, includeAncestorMetadata, includeAlternateMetadataSources,
                guid, title, year,
                path, grandparentTitle, grandparentYear,
                parentIndex, index, originallyAvailableAt,
                parentTitle);
        }


        private static final LazySingletonValue<Optional<? extends Accepts>> _SINGLETON_VALUE_Accepts =
                new LazySingletonValue<>(
                        "accepts",
                        "\"application/xml\"",
                        new TypeReference<Optional<? extends Accepts>>() {});
    }
}
