/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.models.shared.Accepts;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.SpeakeasyMetadata;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;


public class CreateSubscriptionRequest {
    /**
     * Indicates the client accepts the indicated media types
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=accepts")
    private Optional<? extends Accepts> accepts;

    /**
     * An opaque identifier unique to the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Client-Identifier")
    private Optional<String> clientIdentifier;

    /**
     * The name of the client product
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Product")
    private Optional<String> product;

    /**
     * The version of the client application
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Version")
    private Optional<String> version;

    /**
     * The platform of the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform")
    private Optional<String> platform;

    /**
     * The version of the platform
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform-Version")
    private Optional<String> platformVersion;

    /**
     * A relatively friendly name for the client device
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device")
    private Optional<String> device;

    /**
     * A potentially less friendly identifier for the device model
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Model")
    private Optional<String> model;

    /**
     * The device vendor
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Vendor")
    private Optional<String> deviceVendor;

    /**
     * A friendly name for the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Name")
    private Optional<String> deviceName;

    /**
     * The marketplace on which the client application is distributed
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Marketplace")
    private Optional<String> marketplace;

    /**
     * The library section into which we'll grab the media.  Not actually required when the subscription is to a playlist.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=targetLibrarySectionID")
    private Optional<Long> targetLibrarySectionID;

    /**
     * The section location into which to grab.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=targetSectionLocationID")
    private Optional<Long> targetSectionLocationID;

    /**
     * The type of the thing we're subscribing too (e.g. show, season).
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=type")
    private Optional<Long> type;

    /**
     * Hints describing what we're looking for.  Note: The hint `ratingKey` is required for downloading from a PMS remote.
     */
    @SpeakeasyMetadata("queryParam:style=deepObject,explode=true,name=hints")
    private Optional<? extends Hints> hints;

    /**
     * Subscription preferences.
     */
    @SpeakeasyMetadata("queryParam:style=deepObject,explode=true,name=prefs")
    private Optional<? extends CreateSubscriptionQueryParamPrefs> prefs;

    /**
     * Subscription parameters.
     *   - `mediaProviderID`: Required for downloads to indicate which MP the subscription will download into
     *   - `source`: Required for downloads to indicate the source of the downloaded content.
     */
    @SpeakeasyMetadata("queryParam:style=deepObject,explode=true,name=params")
    private Optional<? extends Params> params;

    @JsonCreator
    public CreateSubscriptionRequest(
            Optional<? extends Accepts> accepts,
            Optional<String> clientIdentifier,
            Optional<String> product,
            Optional<String> version,
            Optional<String> platform,
            Optional<String> platformVersion,
            Optional<String> device,
            Optional<String> model,
            Optional<String> deviceVendor,
            Optional<String> deviceName,
            Optional<String> marketplace,
            Optional<Long> targetLibrarySectionID,
            Optional<Long> targetSectionLocationID,
            Optional<Long> type,
            Optional<? extends Hints> hints,
            Optional<? extends CreateSubscriptionQueryParamPrefs> prefs,
            Optional<? extends Params> params) {
        Utils.checkNotNull(accepts, "accepts");
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        Utils.checkNotNull(product, "product");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(platform, "platform");
        Utils.checkNotNull(platformVersion, "platformVersion");
        Utils.checkNotNull(device, "device");
        Utils.checkNotNull(model, "model");
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        Utils.checkNotNull(deviceName, "deviceName");
        Utils.checkNotNull(marketplace, "marketplace");
        Utils.checkNotNull(targetLibrarySectionID, "targetLibrarySectionID");
        Utils.checkNotNull(targetSectionLocationID, "targetSectionLocationID");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(hints, "hints");
        Utils.checkNotNull(prefs, "prefs");
        Utils.checkNotNull(params, "params");
        this.accepts = accepts;
        this.clientIdentifier = clientIdentifier;
        this.product = product;
        this.version = version;
        this.platform = platform;
        this.platformVersion = platformVersion;
        this.device = device;
        this.model = model;
        this.deviceVendor = deviceVendor;
        this.deviceName = deviceName;
        this.marketplace = marketplace;
        this.targetLibrarySectionID = targetLibrarySectionID;
        this.targetSectionLocationID = targetSectionLocationID;
        this.type = type;
        this.hints = hints;
        this.prefs = prefs;
        this.params = params;
    }
    
    public CreateSubscriptionRequest() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty());
    }

    /**
     * Indicates the client accepts the indicated media types
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Accepts> accepts() {
        return (Optional<Accepts>) accepts;
    }

    /**
     * An opaque identifier unique to the client
     */
    @JsonIgnore
    public Optional<String> clientIdentifier() {
        return clientIdentifier;
    }

    /**
     * The name of the client product
     */
    @JsonIgnore
    public Optional<String> product() {
        return product;
    }

    /**
     * The version of the client application
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    /**
     * The platform of the client
     */
    @JsonIgnore
    public Optional<String> platform() {
        return platform;
    }

    /**
     * The version of the platform
     */
    @JsonIgnore
    public Optional<String> platformVersion() {
        return platformVersion;
    }

    /**
     * A relatively friendly name for the client device
     */
    @JsonIgnore
    public Optional<String> device() {
        return device;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    @JsonIgnore
    public Optional<String> model() {
        return model;
    }

    /**
     * The device vendor
     */
    @JsonIgnore
    public Optional<String> deviceVendor() {
        return deviceVendor;
    }

    /**
     * A friendly name for the client
     */
    @JsonIgnore
    public Optional<String> deviceName() {
        return deviceName;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    @JsonIgnore
    public Optional<String> marketplace() {
        return marketplace;
    }

    /**
     * The library section into which we'll grab the media.  Not actually required when the subscription is to a playlist.
     */
    @JsonIgnore
    public Optional<Long> targetLibrarySectionID() {
        return targetLibrarySectionID;
    }

    /**
     * The section location into which to grab.
     */
    @JsonIgnore
    public Optional<Long> targetSectionLocationID() {
        return targetSectionLocationID;
    }

    /**
     * The type of the thing we're subscribing too (e.g. show, season).
     */
    @JsonIgnore
    public Optional<Long> type() {
        return type;
    }

    /**
     * Hints describing what we're looking for.  Note: The hint `ratingKey` is required for downloading from a PMS remote.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Hints> hints() {
        return (Optional<Hints>) hints;
    }

    /**
     * Subscription preferences.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreateSubscriptionQueryParamPrefs> prefs() {
        return (Optional<CreateSubscriptionQueryParamPrefs>) prefs;
    }

    /**
     * Subscription parameters.
     *   - `mediaProviderID`: Required for downloads to indicate which MP the subscription will download into
     *   - `source`: Required for downloads to indicate the source of the downloaded content.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Params> params() {
        return (Optional<Params>) params;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public CreateSubscriptionRequest withAccepts(Accepts accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = Optional.ofNullable(accepts);
        return this;
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public CreateSubscriptionRequest withAccepts(Optional<? extends Accepts> accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = accepts;
        return this;
    }

    /**
     * An opaque identifier unique to the client
     */
    public CreateSubscriptionRequest withClientIdentifier(String clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = Optional.ofNullable(clientIdentifier);
        return this;
    }


    /**
     * An opaque identifier unique to the client
     */
    public CreateSubscriptionRequest withClientIdentifier(Optional<String> clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = clientIdentifier;
        return this;
    }

    /**
     * The name of the client product
     */
    public CreateSubscriptionRequest withProduct(String product) {
        Utils.checkNotNull(product, "product");
        this.product = Optional.ofNullable(product);
        return this;
    }


    /**
     * The name of the client product
     */
    public CreateSubscriptionRequest withProduct(Optional<String> product) {
        Utils.checkNotNull(product, "product");
        this.product = product;
        return this;
    }

    /**
     * The version of the client application
     */
    public CreateSubscriptionRequest withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }


    /**
     * The version of the client application
     */
    public CreateSubscriptionRequest withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * The platform of the client
     */
    public CreateSubscriptionRequest withPlatform(String platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = Optional.ofNullable(platform);
        return this;
    }


    /**
     * The platform of the client
     */
    public CreateSubscriptionRequest withPlatform(Optional<String> platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = platform;
        return this;
    }

    /**
     * The version of the platform
     */
    public CreateSubscriptionRequest withPlatformVersion(String platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = Optional.ofNullable(platformVersion);
        return this;
    }


    /**
     * The version of the platform
     */
    public CreateSubscriptionRequest withPlatformVersion(Optional<String> platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = platformVersion;
        return this;
    }

    /**
     * A relatively friendly name for the client device
     */
    public CreateSubscriptionRequest withDevice(String device) {
        Utils.checkNotNull(device, "device");
        this.device = Optional.ofNullable(device);
        return this;
    }


    /**
     * A relatively friendly name for the client device
     */
    public CreateSubscriptionRequest withDevice(Optional<String> device) {
        Utils.checkNotNull(device, "device");
        this.device = device;
        return this;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    public CreateSubscriptionRequest withModel(String model) {
        Utils.checkNotNull(model, "model");
        this.model = Optional.ofNullable(model);
        return this;
    }


    /**
     * A potentially less friendly identifier for the device model
     */
    public CreateSubscriptionRequest withModel(Optional<String> model) {
        Utils.checkNotNull(model, "model");
        this.model = model;
        return this;
    }

    /**
     * The device vendor
     */
    public CreateSubscriptionRequest withDeviceVendor(String deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = Optional.ofNullable(deviceVendor);
        return this;
    }


    /**
     * The device vendor
     */
    public CreateSubscriptionRequest withDeviceVendor(Optional<String> deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = deviceVendor;
        return this;
    }

    /**
     * A friendly name for the client
     */
    public CreateSubscriptionRequest withDeviceName(String deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = Optional.ofNullable(deviceName);
        return this;
    }


    /**
     * A friendly name for the client
     */
    public CreateSubscriptionRequest withDeviceName(Optional<String> deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = deviceName;
        return this;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    public CreateSubscriptionRequest withMarketplace(String marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = Optional.ofNullable(marketplace);
        return this;
    }


    /**
     * The marketplace on which the client application is distributed
     */
    public CreateSubscriptionRequest withMarketplace(Optional<String> marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = marketplace;
        return this;
    }

    /**
     * The library section into which we'll grab the media.  Not actually required when the subscription is to a playlist.
     */
    public CreateSubscriptionRequest withTargetLibrarySectionID(long targetLibrarySectionID) {
        Utils.checkNotNull(targetLibrarySectionID, "targetLibrarySectionID");
        this.targetLibrarySectionID = Optional.ofNullable(targetLibrarySectionID);
        return this;
    }


    /**
     * The library section into which we'll grab the media.  Not actually required when the subscription is to a playlist.
     */
    public CreateSubscriptionRequest withTargetLibrarySectionID(Optional<Long> targetLibrarySectionID) {
        Utils.checkNotNull(targetLibrarySectionID, "targetLibrarySectionID");
        this.targetLibrarySectionID = targetLibrarySectionID;
        return this;
    }

    /**
     * The section location into which to grab.
     */
    public CreateSubscriptionRequest withTargetSectionLocationID(long targetSectionLocationID) {
        Utils.checkNotNull(targetSectionLocationID, "targetSectionLocationID");
        this.targetSectionLocationID = Optional.ofNullable(targetSectionLocationID);
        return this;
    }


    /**
     * The section location into which to grab.
     */
    public CreateSubscriptionRequest withTargetSectionLocationID(Optional<Long> targetSectionLocationID) {
        Utils.checkNotNull(targetSectionLocationID, "targetSectionLocationID");
        this.targetSectionLocationID = targetSectionLocationID;
        return this;
    }

    /**
     * The type of the thing we're subscribing too (e.g. show, season).
     */
    public CreateSubscriptionRequest withType(long type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }


    /**
     * The type of the thing we're subscribing too (e.g. show, season).
     */
    public CreateSubscriptionRequest withType(Optional<Long> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * Hints describing what we're looking for.  Note: The hint `ratingKey` is required for downloading from a PMS remote.
     */
    public CreateSubscriptionRequest withHints(Hints hints) {
        Utils.checkNotNull(hints, "hints");
        this.hints = Optional.ofNullable(hints);
        return this;
    }


    /**
     * Hints describing what we're looking for.  Note: The hint `ratingKey` is required for downloading from a PMS remote.
     */
    public CreateSubscriptionRequest withHints(Optional<? extends Hints> hints) {
        Utils.checkNotNull(hints, "hints");
        this.hints = hints;
        return this;
    }

    /**
     * Subscription preferences.
     */
    public CreateSubscriptionRequest withPrefs(CreateSubscriptionQueryParamPrefs prefs) {
        Utils.checkNotNull(prefs, "prefs");
        this.prefs = Optional.ofNullable(prefs);
        return this;
    }


    /**
     * Subscription preferences.
     */
    public CreateSubscriptionRequest withPrefs(Optional<? extends CreateSubscriptionQueryParamPrefs> prefs) {
        Utils.checkNotNull(prefs, "prefs");
        this.prefs = prefs;
        return this;
    }

    /**
     * Subscription parameters.
     *   - `mediaProviderID`: Required for downloads to indicate which MP the subscription will download into
     *   - `source`: Required for downloads to indicate the source of the downloaded content.
     */
    public CreateSubscriptionRequest withParams(Params params) {
        Utils.checkNotNull(params, "params");
        this.params = Optional.ofNullable(params);
        return this;
    }


    /**
     * Subscription parameters.
     *   - `mediaProviderID`: Required for downloads to indicate which MP the subscription will download into
     *   - `source`: Required for downloads to indicate the source of the downloaded content.
     */
    public CreateSubscriptionRequest withParams(Optional<? extends Params> params) {
        Utils.checkNotNull(params, "params");
        this.params = params;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreateSubscriptionRequest other = (CreateSubscriptionRequest) o;
        return 
            Utils.enhancedDeepEquals(this.accepts, other.accepts) &&
            Utils.enhancedDeepEquals(this.clientIdentifier, other.clientIdentifier) &&
            Utils.enhancedDeepEquals(this.product, other.product) &&
            Utils.enhancedDeepEquals(this.version, other.version) &&
            Utils.enhancedDeepEquals(this.platform, other.platform) &&
            Utils.enhancedDeepEquals(this.platformVersion, other.platformVersion) &&
            Utils.enhancedDeepEquals(this.device, other.device) &&
            Utils.enhancedDeepEquals(this.model, other.model) &&
            Utils.enhancedDeepEquals(this.deviceVendor, other.deviceVendor) &&
            Utils.enhancedDeepEquals(this.deviceName, other.deviceName) &&
            Utils.enhancedDeepEquals(this.marketplace, other.marketplace) &&
            Utils.enhancedDeepEquals(this.targetLibrarySectionID, other.targetLibrarySectionID) &&
            Utils.enhancedDeepEquals(this.targetSectionLocationID, other.targetSectionLocationID) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.hints, other.hints) &&
            Utils.enhancedDeepEquals(this.prefs, other.prefs) &&
            Utils.enhancedDeepEquals(this.params, other.params);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            accepts, clientIdentifier, product,
            version, platform, platformVersion,
            device, model, deviceVendor,
            deviceName, marketplace, targetLibrarySectionID,
            targetSectionLocationID, type, hints,
            prefs, params);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreateSubscriptionRequest.class,
                "accepts", accepts,
                "clientIdentifier", clientIdentifier,
                "product", product,
                "version", version,
                "platform", platform,
                "platformVersion", platformVersion,
                "device", device,
                "model", model,
                "deviceVendor", deviceVendor,
                "deviceName", deviceName,
                "marketplace", marketplace,
                "targetLibrarySectionID", targetLibrarySectionID,
                "targetSectionLocationID", targetSectionLocationID,
                "type", type,
                "hints", hints,
                "prefs", prefs,
                "params", params);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends Accepts> accepts;

        private Optional<String> clientIdentifier = Optional.empty();

        private Optional<String> product = Optional.empty();

        private Optional<String> version = Optional.empty();

        private Optional<String> platform = Optional.empty();

        private Optional<String> platformVersion = Optional.empty();

        private Optional<String> device = Optional.empty();

        private Optional<String> model = Optional.empty();

        private Optional<String> deviceVendor = Optional.empty();

        private Optional<String> deviceName = Optional.empty();

        private Optional<String> marketplace = Optional.empty();

        private Optional<Long> targetLibrarySectionID = Optional.empty();

        private Optional<Long> targetSectionLocationID = Optional.empty();

        private Optional<Long> type = Optional.empty();

        private Optional<? extends Hints> hints = Optional.empty();

        private Optional<? extends CreateSubscriptionQueryParamPrefs> prefs = Optional.empty();

        private Optional<? extends Params> params = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Accepts accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = Optional.ofNullable(accepts);
            return this;
        }

        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Optional<? extends Accepts> accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = accepts;
            return this;
        }


        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(String clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = Optional.ofNullable(clientIdentifier);
            return this;
        }

        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(Optional<String> clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = clientIdentifier;
            return this;
        }


        /**
         * The name of the client product
         */
        public Builder product(String product) {
            Utils.checkNotNull(product, "product");
            this.product = Optional.ofNullable(product);
            return this;
        }

        /**
         * The name of the client product
         */
        public Builder product(Optional<String> product) {
            Utils.checkNotNull(product, "product");
            this.product = product;
            return this;
        }


        /**
         * The version of the client application
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The version of the client application
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }


        /**
         * The platform of the client
         */
        public Builder platform(String platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = Optional.ofNullable(platform);
            return this;
        }

        /**
         * The platform of the client
         */
        public Builder platform(Optional<String> platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = platform;
            return this;
        }


        /**
         * The version of the platform
         */
        public Builder platformVersion(String platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = Optional.ofNullable(platformVersion);
            return this;
        }

        /**
         * The version of the platform
         */
        public Builder platformVersion(Optional<String> platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = platformVersion;
            return this;
        }


        /**
         * A relatively friendly name for the client device
         */
        public Builder device(String device) {
            Utils.checkNotNull(device, "device");
            this.device = Optional.ofNullable(device);
            return this;
        }

        /**
         * A relatively friendly name for the client device
         */
        public Builder device(Optional<String> device) {
            Utils.checkNotNull(device, "device");
            this.device = device;
            return this;
        }


        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(String model) {
            Utils.checkNotNull(model, "model");
            this.model = Optional.ofNullable(model);
            return this;
        }

        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(Optional<String> model) {
            Utils.checkNotNull(model, "model");
            this.model = model;
            return this;
        }


        /**
         * The device vendor
         */
        public Builder deviceVendor(String deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = Optional.ofNullable(deviceVendor);
            return this;
        }

        /**
         * The device vendor
         */
        public Builder deviceVendor(Optional<String> deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = deviceVendor;
            return this;
        }


        /**
         * A friendly name for the client
         */
        public Builder deviceName(String deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = Optional.ofNullable(deviceName);
            return this;
        }

        /**
         * A friendly name for the client
         */
        public Builder deviceName(Optional<String> deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = deviceName;
            return this;
        }


        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(String marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = Optional.ofNullable(marketplace);
            return this;
        }

        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(Optional<String> marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = marketplace;
            return this;
        }


        /**
         * The library section into which we'll grab the media.  Not actually required when the subscription is to a playlist.
         */
        public Builder targetLibrarySectionID(long targetLibrarySectionID) {
            Utils.checkNotNull(targetLibrarySectionID, "targetLibrarySectionID");
            this.targetLibrarySectionID = Optional.ofNullable(targetLibrarySectionID);
            return this;
        }

        /**
         * The library section into which we'll grab the media.  Not actually required when the subscription is to a playlist.
         */
        public Builder targetLibrarySectionID(Optional<Long> targetLibrarySectionID) {
            Utils.checkNotNull(targetLibrarySectionID, "targetLibrarySectionID");
            this.targetLibrarySectionID = targetLibrarySectionID;
            return this;
        }


        /**
         * The section location into which to grab.
         */
        public Builder targetSectionLocationID(long targetSectionLocationID) {
            Utils.checkNotNull(targetSectionLocationID, "targetSectionLocationID");
            this.targetSectionLocationID = Optional.ofNullable(targetSectionLocationID);
            return this;
        }

        /**
         * The section location into which to grab.
         */
        public Builder targetSectionLocationID(Optional<Long> targetSectionLocationID) {
            Utils.checkNotNull(targetSectionLocationID, "targetSectionLocationID");
            this.targetSectionLocationID = targetSectionLocationID;
            return this;
        }


        /**
         * The type of the thing we're subscribing too (e.g. show, season).
         */
        public Builder type(long type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * The type of the thing we're subscribing too (e.g. show, season).
         */
        public Builder type(Optional<Long> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }


        /**
         * Hints describing what we're looking for.  Note: The hint `ratingKey` is required for downloading from a PMS remote.
         */
        public Builder hints(Hints hints) {
            Utils.checkNotNull(hints, "hints");
            this.hints = Optional.ofNullable(hints);
            return this;
        }

        /**
         * Hints describing what we're looking for.  Note: The hint `ratingKey` is required for downloading from a PMS remote.
         */
        public Builder hints(Optional<? extends Hints> hints) {
            Utils.checkNotNull(hints, "hints");
            this.hints = hints;
            return this;
        }


        /**
         * Subscription preferences.
         */
        public Builder prefs(CreateSubscriptionQueryParamPrefs prefs) {
            Utils.checkNotNull(prefs, "prefs");
            this.prefs = Optional.ofNullable(prefs);
            return this;
        }

        /**
         * Subscription preferences.
         */
        public Builder prefs(Optional<? extends CreateSubscriptionQueryParamPrefs> prefs) {
            Utils.checkNotNull(prefs, "prefs");
            this.prefs = prefs;
            return this;
        }


        /**
         * Subscription parameters.
         *   - `mediaProviderID`: Required for downloads to indicate which MP the subscription will download into
         *   - `source`: Required for downloads to indicate the source of the downloaded content.
         */
        public Builder params(Params params) {
            Utils.checkNotNull(params, "params");
            this.params = Optional.ofNullable(params);
            return this;
        }

        /**
         * Subscription parameters.
         *   - `mediaProviderID`: Required for downloads to indicate which MP the subscription will download into
         *   - `source`: Required for downloads to indicate the source of the downloaded content.
         */
        public Builder params(Optional<? extends Params> params) {
            Utils.checkNotNull(params, "params");
            this.params = params;
            return this;
        }

        public CreateSubscriptionRequest build() {
            if (accepts == null) {
                accepts = _SINGLETON_VALUE_Accepts.value();
            }

            return new CreateSubscriptionRequest(
                accepts, clientIdentifier, product,
                version, platform, platformVersion,
                device, model, deviceVendor,
                deviceName, marketplace, targetLibrarySectionID,
                targetSectionLocationID, type, hints,
                prefs, params);
        }


        private static final LazySingletonValue<Optional<? extends Accepts>> _SINGLETON_VALUE_Accepts =
                new LazySingletonValue<>(
                        "accepts",
                        "\"application/xml\"",
                        new TypeReference<Optional<? extends Accepts>>() {});
    }
}
