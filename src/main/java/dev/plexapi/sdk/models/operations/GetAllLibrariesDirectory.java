/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class GetAllLibrariesDirectory {

    /**
     * Indicates whether syncing is allowed.
     */
    @JsonProperty("allowSync")
    private boolean allowSync;

    /**
     * URL for the background artwork of the media container.
     */
    @JsonProperty("art")
    private String art;

    /**
     * The relative path to the composite media item.
     */
    @JsonProperty("composite")
    private String composite;

    /**
     * UNKNOWN
     */
    @JsonProperty("filters")
    private boolean filters;

    /**
     * Indicates whether the library is currently being refreshed or updated
     */
    @JsonProperty("refreshing")
    private boolean refreshing;

    /**
     * URL for the thumbnail image of the media container.
     */
    @JsonProperty("thumb")
    private String thumb;

    /**
     * The library key representing the unique identifier
     */
    @JsonProperty("key")
    private String key;

    @JsonProperty("type")
    private GetAllLibrariesType type;

    /**
     * The title of the library
     */
    @JsonProperty("title")
    private String title;

    /**
     * The Plex agent used to match and retrieve media metadata.
     */
    @JsonProperty("agent")
    private String agent;

    /**
     * UNKNOWN
     */
    @JsonProperty("scanner")
    private String scanner;

    /**
     * The Plex library language that has been set
     */
    @JsonProperty("language")
    private String language;

    /**
     * The universally unique identifier for the library.
     */
    @JsonProperty("uuid")
    private String uuid;

    /**
     * Unix epoch datetime in seconds
     */
    @JsonProperty("updatedAt")
    private long updatedAt;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<Long> createdAt;

    /**
     * Unix epoch datetime in seconds
     */
    @JsonProperty("scannedAt")
    private long scannedAt;

    /**
     * UNKNOWN
     */
    @JsonProperty("content")
    private boolean content;

    /**
     * UNKNOWN
     */
    @JsonProperty("directory")
    private boolean directory;

    /**
     * The number of seconds since the content was last changed relative to now.
     */
    @JsonProperty("contentChangedAt")
    private int contentChangedAt;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hidden")
    private Optional<? extends Hidden> hidden;

    @JsonProperty("Location")
    private List<GetAllLibrariesLocation> location;

    @JsonCreator
    public GetAllLibrariesDirectory(
            @JsonProperty("allowSync") boolean allowSync,
            @JsonProperty("art") String art,
            @JsonProperty("composite") String composite,
            @JsonProperty("filters") boolean filters,
            @JsonProperty("refreshing") boolean refreshing,
            @JsonProperty("thumb") String thumb,
            @JsonProperty("key") String key,
            @JsonProperty("type") GetAllLibrariesType type,
            @JsonProperty("title") String title,
            @JsonProperty("agent") String agent,
            @JsonProperty("scanner") String scanner,
            @JsonProperty("language") String language,
            @JsonProperty("uuid") String uuid,
            @JsonProperty("updatedAt") long updatedAt,
            @JsonProperty("createdAt") Optional<Long> createdAt,
            @JsonProperty("scannedAt") long scannedAt,
            @JsonProperty("content") boolean content,
            @JsonProperty("directory") boolean directory,
            @JsonProperty("contentChangedAt") int contentChangedAt,
            @JsonProperty("hidden") Optional<? extends Hidden> hidden,
            @JsonProperty("Location") List<GetAllLibrariesLocation> location) {
        Utils.checkNotNull(allowSync, "allowSync");
        Utils.checkNotNull(art, "art");
        Utils.checkNotNull(composite, "composite");
        Utils.checkNotNull(filters, "filters");
        Utils.checkNotNull(refreshing, "refreshing");
        Utils.checkNotNull(thumb, "thumb");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(title, "title");
        Utils.checkNotNull(agent, "agent");
        Utils.checkNotNull(scanner, "scanner");
        Utils.checkNotNull(language, "language");
        Utils.checkNotNull(uuid, "uuid");
        Utils.checkNotNull(updatedAt, "updatedAt");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(scannedAt, "scannedAt");
        Utils.checkNotNull(content, "content");
        Utils.checkNotNull(directory, "directory");
        Utils.checkNotNull(contentChangedAt, "contentChangedAt");
        Utils.checkNotNull(hidden, "hidden");
        Utils.checkNotNull(location, "location");
        this.allowSync = allowSync;
        this.art = art;
        this.composite = composite;
        this.filters = filters;
        this.refreshing = refreshing;
        this.thumb = thumb;
        this.key = key;
        this.type = type;
        this.title = title;
        this.agent = agent;
        this.scanner = scanner;
        this.language = language;
        this.uuid = uuid;
        this.updatedAt = updatedAt;
        this.createdAt = createdAt;
        this.scannedAt = scannedAt;
        this.content = content;
        this.directory = directory;
        this.contentChangedAt = contentChangedAt;
        this.hidden = hidden;
        this.location = location;
    }
    
    public GetAllLibrariesDirectory(
            boolean allowSync,
            String art,
            String composite,
            boolean filters,
            boolean refreshing,
            String thumb,
            String key,
            GetAllLibrariesType type,
            String title,
            String agent,
            String scanner,
            String language,
            String uuid,
            long updatedAt,
            long scannedAt,
            boolean content,
            boolean directory,
            int contentChangedAt,
            List<GetAllLibrariesLocation> location) {
        this(allowSync, art, composite, filters, refreshing, thumb, key, type, title, agent, scanner, language, uuid, updatedAt, Optional.empty(), scannedAt, content, directory, contentChangedAt, Optional.empty(), location);
    }

    /**
     * Indicates whether syncing is allowed.
     */
    @JsonIgnore
    public boolean allowSync() {
        return allowSync;
    }

    /**
     * URL for the background artwork of the media container.
     */
    @JsonIgnore
    public String art() {
        return art;
    }

    /**
     * The relative path to the composite media item.
     */
    @JsonIgnore
    public String composite() {
        return composite;
    }

    /**
     * UNKNOWN
     */
    @JsonIgnore
    public boolean filters() {
        return filters;
    }

    /**
     * Indicates whether the library is currently being refreshed or updated
     */
    @JsonIgnore
    public boolean refreshing() {
        return refreshing;
    }

    /**
     * URL for the thumbnail image of the media container.
     */
    @JsonIgnore
    public String thumb() {
        return thumb;
    }

    /**
     * The library key representing the unique identifier
     */
    @JsonIgnore
    public String key() {
        return key;
    }

    @JsonIgnore
    public GetAllLibrariesType type() {
        return type;
    }

    /**
     * The title of the library
     */
    @JsonIgnore
    public String title() {
        return title;
    }

    /**
     * The Plex agent used to match and retrieve media metadata.
     */
    @JsonIgnore
    public String agent() {
        return agent;
    }

    /**
     * UNKNOWN
     */
    @JsonIgnore
    public String scanner() {
        return scanner;
    }

    /**
     * The Plex library language that has been set
     */
    @JsonIgnore
    public String language() {
        return language;
    }

    /**
     * The universally unique identifier for the library.
     */
    @JsonIgnore
    public String uuid() {
        return uuid;
    }

    /**
     * Unix epoch datetime in seconds
     */
    @JsonIgnore
    public long updatedAt() {
        return updatedAt;
    }

    @JsonIgnore
    public Optional<Long> createdAt() {
        return createdAt;
    }

    /**
     * Unix epoch datetime in seconds
     */
    @JsonIgnore
    public long scannedAt() {
        return scannedAt;
    }

    /**
     * UNKNOWN
     */
    @JsonIgnore
    public boolean content() {
        return content;
    }

    /**
     * UNKNOWN
     */
    @JsonIgnore
    public boolean directory() {
        return directory;
    }

    /**
     * The number of seconds since the content was last changed relative to now.
     */
    @JsonIgnore
    public int contentChangedAt() {
        return contentChangedAt;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Hidden> hidden() {
        return (Optional<Hidden>) hidden;
    }

    @JsonIgnore
    public List<GetAllLibrariesLocation> location() {
        return location;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Indicates whether syncing is allowed.
     */
    public GetAllLibrariesDirectory withAllowSync(boolean allowSync) {
        Utils.checkNotNull(allowSync, "allowSync");
        this.allowSync = allowSync;
        return this;
    }

    /**
     * URL for the background artwork of the media container.
     */
    public GetAllLibrariesDirectory withArt(String art) {
        Utils.checkNotNull(art, "art");
        this.art = art;
        return this;
    }

    /**
     * The relative path to the composite media item.
     */
    public GetAllLibrariesDirectory withComposite(String composite) {
        Utils.checkNotNull(composite, "composite");
        this.composite = composite;
        return this;
    }

    /**
     * UNKNOWN
     */
    public GetAllLibrariesDirectory withFilters(boolean filters) {
        Utils.checkNotNull(filters, "filters");
        this.filters = filters;
        return this;
    }

    /**
     * Indicates whether the library is currently being refreshed or updated
     */
    public GetAllLibrariesDirectory withRefreshing(boolean refreshing) {
        Utils.checkNotNull(refreshing, "refreshing");
        this.refreshing = refreshing;
        return this;
    }

    /**
     * URL for the thumbnail image of the media container.
     */
    public GetAllLibrariesDirectory withThumb(String thumb) {
        Utils.checkNotNull(thumb, "thumb");
        this.thumb = thumb;
        return this;
    }

    /**
     * The library key representing the unique identifier
     */
    public GetAllLibrariesDirectory withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    public GetAllLibrariesDirectory withType(GetAllLibrariesType type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * The title of the library
     */
    public GetAllLibrariesDirectory withTitle(String title) {
        Utils.checkNotNull(title, "title");
        this.title = title;
        return this;
    }

    /**
     * The Plex agent used to match and retrieve media metadata.
     */
    public GetAllLibrariesDirectory withAgent(String agent) {
        Utils.checkNotNull(agent, "agent");
        this.agent = agent;
        return this;
    }

    /**
     * UNKNOWN
     */
    public GetAllLibrariesDirectory withScanner(String scanner) {
        Utils.checkNotNull(scanner, "scanner");
        this.scanner = scanner;
        return this;
    }

    /**
     * The Plex library language that has been set
     */
    public GetAllLibrariesDirectory withLanguage(String language) {
        Utils.checkNotNull(language, "language");
        this.language = language;
        return this;
    }

    /**
     * The universally unique identifier for the library.
     */
    public GetAllLibrariesDirectory withUuid(String uuid) {
        Utils.checkNotNull(uuid, "uuid");
        this.uuid = uuid;
        return this;
    }

    /**
     * Unix epoch datetime in seconds
     */
    public GetAllLibrariesDirectory withUpdatedAt(long updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    public GetAllLibrariesDirectory withCreatedAt(long createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    public GetAllLibrariesDirectory withCreatedAt(Optional<Long> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * Unix epoch datetime in seconds
     */
    public GetAllLibrariesDirectory withScannedAt(long scannedAt) {
        Utils.checkNotNull(scannedAt, "scannedAt");
        this.scannedAt = scannedAt;
        return this;
    }

    /**
     * UNKNOWN
     */
    public GetAllLibrariesDirectory withContent(boolean content) {
        Utils.checkNotNull(content, "content");
        this.content = content;
        return this;
    }

    /**
     * UNKNOWN
     */
    public GetAllLibrariesDirectory withDirectory(boolean directory) {
        Utils.checkNotNull(directory, "directory");
        this.directory = directory;
        return this;
    }

    /**
     * The number of seconds since the content was last changed relative to now.
     */
    public GetAllLibrariesDirectory withContentChangedAt(int contentChangedAt) {
        Utils.checkNotNull(contentChangedAt, "contentChangedAt");
        this.contentChangedAt = contentChangedAt;
        return this;
    }

    public GetAllLibrariesDirectory withHidden(Hidden hidden) {
        Utils.checkNotNull(hidden, "hidden");
        this.hidden = Optional.ofNullable(hidden);
        return this;
    }

    public GetAllLibrariesDirectory withHidden(Optional<? extends Hidden> hidden) {
        Utils.checkNotNull(hidden, "hidden");
        this.hidden = hidden;
        return this;
    }

    public GetAllLibrariesDirectory withLocation(List<GetAllLibrariesLocation> location) {
        Utils.checkNotNull(location, "location");
        this.location = location;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        GetAllLibrariesDirectory other = (GetAllLibrariesDirectory) o;
        return 
            Objects.deepEquals(this.allowSync, other.allowSync) &&
            Objects.deepEquals(this.art, other.art) &&
            Objects.deepEquals(this.composite, other.composite) &&
            Objects.deepEquals(this.filters, other.filters) &&
            Objects.deepEquals(this.refreshing, other.refreshing) &&
            Objects.deepEquals(this.thumb, other.thumb) &&
            Objects.deepEquals(this.key, other.key) &&
            Objects.deepEquals(this.type, other.type) &&
            Objects.deepEquals(this.title, other.title) &&
            Objects.deepEquals(this.agent, other.agent) &&
            Objects.deepEquals(this.scanner, other.scanner) &&
            Objects.deepEquals(this.language, other.language) &&
            Objects.deepEquals(this.uuid, other.uuid) &&
            Objects.deepEquals(this.updatedAt, other.updatedAt) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.scannedAt, other.scannedAt) &&
            Objects.deepEquals(this.content, other.content) &&
            Objects.deepEquals(this.directory, other.directory) &&
            Objects.deepEquals(this.contentChangedAt, other.contentChangedAt) &&
            Objects.deepEquals(this.hidden, other.hidden) &&
            Objects.deepEquals(this.location, other.location);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            allowSync,
            art,
            composite,
            filters,
            refreshing,
            thumb,
            key,
            type,
            title,
            agent,
            scanner,
            language,
            uuid,
            updatedAt,
            createdAt,
            scannedAt,
            content,
            directory,
            contentChangedAt,
            hidden,
            location);
    }
    
    @Override
    public String toString() {
        return Utils.toString(GetAllLibrariesDirectory.class,
                "allowSync", allowSync,
                "art", art,
                "composite", composite,
                "filters", filters,
                "refreshing", refreshing,
                "thumb", thumb,
                "key", key,
                "type", type,
                "title", title,
                "agent", agent,
                "scanner", scanner,
                "language", language,
                "uuid", uuid,
                "updatedAt", updatedAt,
                "createdAt", createdAt,
                "scannedAt", scannedAt,
                "content", content,
                "directory", directory,
                "contentChangedAt", contentChangedAt,
                "hidden", hidden,
                "location", location);
    }
    
    public final static class Builder {
 
        private Boolean allowSync;
 
        private String art;
 
        private String composite;
 
        private Boolean filters;
 
        private Boolean refreshing;
 
        private String thumb;
 
        private String key;
 
        private GetAllLibrariesType type;
 
        private String title;
 
        private String agent;
 
        private String scanner;
 
        private String language;
 
        private String uuid;
 
        private Long updatedAt;
 
        private Optional<Long> createdAt = Optional.empty();
 
        private Long scannedAt;
 
        private Boolean content;
 
        private Boolean directory;
 
        private Integer contentChangedAt;
 
        private Optional<? extends Hidden> hidden;
 
        private List<GetAllLibrariesLocation> location;
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Indicates whether syncing is allowed.
         */
        public Builder allowSync(boolean allowSync) {
            Utils.checkNotNull(allowSync, "allowSync");
            this.allowSync = allowSync;
            return this;
        }

        /**
         * URL for the background artwork of the media container.
         */
        public Builder art(String art) {
            Utils.checkNotNull(art, "art");
            this.art = art;
            return this;
        }

        /**
         * The relative path to the composite media item.
         */
        public Builder composite(String composite) {
            Utils.checkNotNull(composite, "composite");
            this.composite = composite;
            return this;
        }

        /**
         * UNKNOWN
         */
        public Builder filters(boolean filters) {
            Utils.checkNotNull(filters, "filters");
            this.filters = filters;
            return this;
        }

        /**
         * Indicates whether the library is currently being refreshed or updated
         */
        public Builder refreshing(boolean refreshing) {
            Utils.checkNotNull(refreshing, "refreshing");
            this.refreshing = refreshing;
            return this;
        }

        /**
         * URL for the thumbnail image of the media container.
         */
        public Builder thumb(String thumb) {
            Utils.checkNotNull(thumb, "thumb");
            this.thumb = thumb;
            return this;
        }

        /**
         * The library key representing the unique identifier
         */
        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }

        public Builder type(GetAllLibrariesType type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        /**
         * The title of the library
         */
        public Builder title(String title) {
            Utils.checkNotNull(title, "title");
            this.title = title;
            return this;
        }

        /**
         * The Plex agent used to match and retrieve media metadata.
         */
        public Builder agent(String agent) {
            Utils.checkNotNull(agent, "agent");
            this.agent = agent;
            return this;
        }

        /**
         * UNKNOWN
         */
        public Builder scanner(String scanner) {
            Utils.checkNotNull(scanner, "scanner");
            this.scanner = scanner;
            return this;
        }

        /**
         * The Plex library language that has been set
         */
        public Builder language(String language) {
            Utils.checkNotNull(language, "language");
            this.language = language;
            return this;
        }

        /**
         * The universally unique identifier for the library.
         */
        public Builder uuid(String uuid) {
            Utils.checkNotNull(uuid, "uuid");
            this.uuid = uuid;
            return this;
        }

        /**
         * Unix epoch datetime in seconds
         */
        public Builder updatedAt(long updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }

        public Builder createdAt(long createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        public Builder createdAt(Optional<Long> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * Unix epoch datetime in seconds
         */
        public Builder scannedAt(long scannedAt) {
            Utils.checkNotNull(scannedAt, "scannedAt");
            this.scannedAt = scannedAt;
            return this;
        }

        /**
         * UNKNOWN
         */
        public Builder content(boolean content) {
            Utils.checkNotNull(content, "content");
            this.content = content;
            return this;
        }

        /**
         * UNKNOWN
         */
        public Builder directory(boolean directory) {
            Utils.checkNotNull(directory, "directory");
            this.directory = directory;
            return this;
        }

        /**
         * The number of seconds since the content was last changed relative to now.
         */
        public Builder contentChangedAt(int contentChangedAt) {
            Utils.checkNotNull(contentChangedAt, "contentChangedAt");
            this.contentChangedAt = contentChangedAt;
            return this;
        }

        public Builder hidden(Hidden hidden) {
            Utils.checkNotNull(hidden, "hidden");
            this.hidden = Optional.ofNullable(hidden);
            return this;
        }

        public Builder hidden(Optional<? extends Hidden> hidden) {
            Utils.checkNotNull(hidden, "hidden");
            this.hidden = hidden;
            return this;
        }

        public Builder location(List<GetAllLibrariesLocation> location) {
            Utils.checkNotNull(location, "location");
            this.location = location;
            return this;
        }
        
        public GetAllLibrariesDirectory build() {
            if (hidden == null) {
                hidden = _SINGLETON_VALUE_Hidden.value();
            }
            return new GetAllLibrariesDirectory(
                allowSync,
                art,
                composite,
                filters,
                refreshing,
                thumb,
                key,
                type,
                title,
                agent,
                scanner,
                language,
                uuid,
                updatedAt,
                createdAt,
                scannedAt,
                content,
                directory,
                contentChangedAt,
                hidden,
                location);
        }

        private static final LazySingletonValue<Optional<? extends Hidden>> _SINGLETON_VALUE_Hidden =
                new LazySingletonValue<>(
                        "hidden",
                        "0",
                        new TypeReference<Optional<? extends Hidden>>() {});
    }
}
