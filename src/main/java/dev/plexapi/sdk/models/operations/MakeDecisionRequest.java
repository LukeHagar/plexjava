/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.models.shared.Accepts;
import dev.plexapi.sdk.models.shared.AdvancedSubtitles;
import dev.plexapi.sdk.models.shared.BoolInt;
import dev.plexapi.sdk.models.shared.TranscodeType;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.SpeakeasyMetadata;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Double;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;


public class MakeDecisionRequest {
    /**
     * Indicates the client accepts the indicated media types
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=accepts")
    private Optional<? extends Accepts> accepts;

    /**
     * An opaque identifier unique to the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Client-Identifier")
    private Optional<String> clientIdentifier;

    /**
     * The name of the client product
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Product")
    private Optional<String> product;

    /**
     * The version of the client application
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Version")
    private Optional<String> version;

    /**
     * The platform of the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform")
    private Optional<String> platform;

    /**
     * The version of the platform
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform-Version")
    private Optional<String> platformVersion;

    /**
     * A relatively friendly name for the client device
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device")
    private Optional<String> device;

    /**
     * A potentially less friendly identifier for the device model
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Model")
    private Optional<String> model;

    /**
     * The device vendor
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Vendor")
    private Optional<String> deviceVendor;

    /**
     * A friendly name for the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Name")
    private Optional<String> deviceName;

    /**
     * The marketplace on which the client application is distributed
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Marketplace")
    private Optional<String> marketplace;

    /**
     * Type of transcode media
     */
    @SpeakeasyMetadata("pathParam:style=simple,explode=false,name=transcodeType")
    private TranscodeType transcodeType;

    /**
     * Transcode session UUID
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=transcodeSessionId")
    private Optional<String> transcodeSessionId;

    /**
     * Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=advancedSubtitles")
    private Optional<? extends AdvancedSubtitles> advancedSubtitles;

    /**
     * Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=audioBoost")
    private Optional<Long> audioBoost;

    /**
     * Target video number of audio channels.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=audioChannelCount")
    private Optional<Long> audioChannelCount;

    /**
     * Indicates the client supports ABR.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=autoAdjustQuality")
    private Optional<? extends BoolInt> autoAdjustQuality;

    /**
     * Indicates if the server should adjust subtitles based on Voice Activity Data.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=autoAdjustSubtitle")
    private Optional<? extends BoolInt> autoAdjustSubtitle;

    /**
     * Indicates the client supports direct playing the indicated content.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=directPlay")
    private Optional<? extends BoolInt> directPlay;

    /**
     * Indicates the client supports direct streaming the video of the indicated content.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=directStream")
    private Optional<? extends BoolInt> directStream;

    /**
     * Indicates the client supports direct streaming the audio of the indicated content.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=directStreamAudio")
    private Optional<? extends BoolInt> directStreamAudio;

    /**
     * Indicates if resolution should be adjusted for orientation.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=disableResolutionRotation")
    private Optional<? extends BoolInt> disableResolutionRotation;

    /**
     * Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=hasMDE")
    private Optional<? extends BoolInt> hasMDE;

    /**
     * Network type of the client, can be used to help determine target bitrate.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=location")
    private Optional<? extends Location> location;

    /**
     * Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=mediaBufferSize")
    private Optional<Long> mediaBufferSize;

    /**
     * Index of the media to transcode. -1 or not specified indicates let the server choose.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=mediaIndex")
    private Optional<Long> mediaIndex;

    /**
     * Target bitrate for audio only files (in kbps, used to transcode).
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=musicBitrate")
    private Optional<Long> musicBitrate;

    /**
     * Offset from the start of the media (in seconds).
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=offset")
    private Optional<Double> offset;

    /**
     * Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=partIndex")
    private Optional<Long> partIndex;

    /**
     * Internal PMS path of the media to transcode.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=path")
    private Optional<String> path;

    /**
     * Maximum bitrate (in kbps) to use in ABR.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=peakBitrate")
    private Optional<Long> peakBitrate;

    /**
     * Target photo resolution.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=photoResolution")
    private Optional<String> photoResolution;

    /**
     * Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=protocol")
    private Optional<? extends Protocol> protocol;

    /**
     * Number of seconds to include in each transcoded segment
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=secondsPerSegment")
    private Optional<Long> secondsPerSegment;

    /**
     * Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=subtitleSize")
    private Optional<Long> subtitleSize;

    /**
     * Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=subtitles")
    private Optional<? extends Subtitles> subtitles;

    /**
     * Target video bitrate (in kbps).
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=videoBitrate")
    private Optional<Long> videoBitrate;

    /**
     * Target photo quality.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=videoQuality")
    private Optional<Long> videoQuality;

    /**
     * Target maximum video resolution.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=videoResolution")
    private Optional<String> videoResolution;

    /**
     * See [Profile Augmentations](#section/API-Info/Profile-Augmentations) .
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Client-Profile-Extra")
    private Optional<String> xPlexClientProfileExtra;

    /**
     * Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile.
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Client-Profile-Name")
    private Optional<String> xPlexClientProfileName;

    /**
     * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Session-Identifier")
    private Optional<String> xPlexSessionIdentifier;

    @JsonCreator
    public MakeDecisionRequest(
            Optional<? extends Accepts> accepts,
            Optional<String> clientIdentifier,
            Optional<String> product,
            Optional<String> version,
            Optional<String> platform,
            Optional<String> platformVersion,
            Optional<String> device,
            Optional<String> model,
            Optional<String> deviceVendor,
            Optional<String> deviceName,
            Optional<String> marketplace,
            TranscodeType transcodeType,
            Optional<String> transcodeSessionId,
            Optional<? extends AdvancedSubtitles> advancedSubtitles,
            Optional<Long> audioBoost,
            Optional<Long> audioChannelCount,
            Optional<? extends BoolInt> autoAdjustQuality,
            Optional<? extends BoolInt> autoAdjustSubtitle,
            Optional<? extends BoolInt> directPlay,
            Optional<? extends BoolInt> directStream,
            Optional<? extends BoolInt> directStreamAudio,
            Optional<? extends BoolInt> disableResolutionRotation,
            Optional<? extends BoolInt> hasMDE,
            Optional<? extends Location> location,
            Optional<Long> mediaBufferSize,
            Optional<Long> mediaIndex,
            Optional<Long> musicBitrate,
            Optional<Double> offset,
            Optional<Long> partIndex,
            Optional<String> path,
            Optional<Long> peakBitrate,
            Optional<String> photoResolution,
            Optional<? extends Protocol> protocol,
            Optional<Long> secondsPerSegment,
            Optional<Long> subtitleSize,
            Optional<? extends Subtitles> subtitles,
            Optional<Long> videoBitrate,
            Optional<Long> videoQuality,
            Optional<String> videoResolution,
            Optional<String> xPlexClientProfileExtra,
            Optional<String> xPlexClientProfileName,
            Optional<String> xPlexSessionIdentifier) {
        Utils.checkNotNull(accepts, "accepts");
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        Utils.checkNotNull(product, "product");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(platform, "platform");
        Utils.checkNotNull(platformVersion, "platformVersion");
        Utils.checkNotNull(device, "device");
        Utils.checkNotNull(model, "model");
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        Utils.checkNotNull(deviceName, "deviceName");
        Utils.checkNotNull(marketplace, "marketplace");
        Utils.checkNotNull(transcodeType, "transcodeType");
        Utils.checkNotNull(transcodeSessionId, "transcodeSessionId");
        Utils.checkNotNull(advancedSubtitles, "advancedSubtitles");
        Utils.checkNotNull(audioBoost, "audioBoost");
        Utils.checkNotNull(audioChannelCount, "audioChannelCount");
        Utils.checkNotNull(autoAdjustQuality, "autoAdjustQuality");
        Utils.checkNotNull(autoAdjustSubtitle, "autoAdjustSubtitle");
        Utils.checkNotNull(directPlay, "directPlay");
        Utils.checkNotNull(directStream, "directStream");
        Utils.checkNotNull(directStreamAudio, "directStreamAudio");
        Utils.checkNotNull(disableResolutionRotation, "disableResolutionRotation");
        Utils.checkNotNull(hasMDE, "hasMDE");
        Utils.checkNotNull(location, "location");
        Utils.checkNotNull(mediaBufferSize, "mediaBufferSize");
        Utils.checkNotNull(mediaIndex, "mediaIndex");
        Utils.checkNotNull(musicBitrate, "musicBitrate");
        Utils.checkNotNull(offset, "offset");
        Utils.checkNotNull(partIndex, "partIndex");
        Utils.checkNotNull(path, "path");
        Utils.checkNotNull(peakBitrate, "peakBitrate");
        Utils.checkNotNull(photoResolution, "photoResolution");
        Utils.checkNotNull(protocol, "protocol");
        Utils.checkNotNull(secondsPerSegment, "secondsPerSegment");
        Utils.checkNotNull(subtitleSize, "subtitleSize");
        Utils.checkNotNull(subtitles, "subtitles");
        Utils.checkNotNull(videoBitrate, "videoBitrate");
        Utils.checkNotNull(videoQuality, "videoQuality");
        Utils.checkNotNull(videoResolution, "videoResolution");
        Utils.checkNotNull(xPlexClientProfileExtra, "xPlexClientProfileExtra");
        Utils.checkNotNull(xPlexClientProfileName, "xPlexClientProfileName");
        Utils.checkNotNull(xPlexSessionIdentifier, "xPlexSessionIdentifier");
        this.accepts = accepts;
        this.clientIdentifier = clientIdentifier;
        this.product = product;
        this.version = version;
        this.platform = platform;
        this.platformVersion = platformVersion;
        this.device = device;
        this.model = model;
        this.deviceVendor = deviceVendor;
        this.deviceName = deviceName;
        this.marketplace = marketplace;
        this.transcodeType = transcodeType;
        this.transcodeSessionId = transcodeSessionId;
        this.advancedSubtitles = advancedSubtitles;
        this.audioBoost = audioBoost;
        this.audioChannelCount = audioChannelCount;
        this.autoAdjustQuality = autoAdjustQuality;
        this.autoAdjustSubtitle = autoAdjustSubtitle;
        this.directPlay = directPlay;
        this.directStream = directStream;
        this.directStreamAudio = directStreamAudio;
        this.disableResolutionRotation = disableResolutionRotation;
        this.hasMDE = hasMDE;
        this.location = location;
        this.mediaBufferSize = mediaBufferSize;
        this.mediaIndex = mediaIndex;
        this.musicBitrate = musicBitrate;
        this.offset = offset;
        this.partIndex = partIndex;
        this.path = path;
        this.peakBitrate = peakBitrate;
        this.photoResolution = photoResolution;
        this.protocol = protocol;
        this.secondsPerSegment = secondsPerSegment;
        this.subtitleSize = subtitleSize;
        this.subtitles = subtitles;
        this.videoBitrate = videoBitrate;
        this.videoQuality = videoQuality;
        this.videoResolution = videoResolution;
        this.xPlexClientProfileExtra = xPlexClientProfileExtra;
        this.xPlexClientProfileName = xPlexClientProfileName;
        this.xPlexSessionIdentifier = xPlexSessionIdentifier;
    }
    
    public MakeDecisionRequest(
            TranscodeType transcodeType) {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), transcodeType,
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Indicates the client accepts the indicated media types
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Accepts> accepts() {
        return (Optional<Accepts>) accepts;
    }

    /**
     * An opaque identifier unique to the client
     */
    @JsonIgnore
    public Optional<String> clientIdentifier() {
        return clientIdentifier;
    }

    /**
     * The name of the client product
     */
    @JsonIgnore
    public Optional<String> product() {
        return product;
    }

    /**
     * The version of the client application
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    /**
     * The platform of the client
     */
    @JsonIgnore
    public Optional<String> platform() {
        return platform;
    }

    /**
     * The version of the platform
     */
    @JsonIgnore
    public Optional<String> platformVersion() {
        return platformVersion;
    }

    /**
     * A relatively friendly name for the client device
     */
    @JsonIgnore
    public Optional<String> device() {
        return device;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    @JsonIgnore
    public Optional<String> model() {
        return model;
    }

    /**
     * The device vendor
     */
    @JsonIgnore
    public Optional<String> deviceVendor() {
        return deviceVendor;
    }

    /**
     * A friendly name for the client
     */
    @JsonIgnore
    public Optional<String> deviceName() {
        return deviceName;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    @JsonIgnore
    public Optional<String> marketplace() {
        return marketplace;
    }

    /**
     * Type of transcode media
     */
    @JsonIgnore
    public TranscodeType transcodeType() {
        return transcodeType;
    }

    /**
     * Transcode session UUID
     */
    @JsonIgnore
    public Optional<String> transcodeSessionId() {
        return transcodeSessionId;
    }

    /**
     * Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AdvancedSubtitles> advancedSubtitles() {
        return (Optional<AdvancedSubtitles>) advancedSubtitles;
    }

    /**
     * Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)
     */
    @JsonIgnore
    public Optional<Long> audioBoost() {
        return audioBoost;
    }

    /**
     * Target video number of audio channels.
     */
    @JsonIgnore
    public Optional<Long> audioChannelCount() {
        return audioChannelCount;
    }

    /**
     * Indicates the client supports ABR.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> autoAdjustQuality() {
        return (Optional<BoolInt>) autoAdjustQuality;
    }

    /**
     * Indicates if the server should adjust subtitles based on Voice Activity Data.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> autoAdjustSubtitle() {
        return (Optional<BoolInt>) autoAdjustSubtitle;
    }

    /**
     * Indicates the client supports direct playing the indicated content.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> directPlay() {
        return (Optional<BoolInt>) directPlay;
    }

    /**
     * Indicates the client supports direct streaming the video of the indicated content.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> directStream() {
        return (Optional<BoolInt>) directStream;
    }

    /**
     * Indicates the client supports direct streaming the audio of the indicated content.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> directStreamAudio() {
        return (Optional<BoolInt>) directStreamAudio;
    }

    /**
     * Indicates if resolution should be adjusted for orientation.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> disableResolutionRotation() {
        return (Optional<BoolInt>) disableResolutionRotation;
    }

    /**
     * Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> hasMDE() {
        return (Optional<BoolInt>) hasMDE;
    }

    /**
     * Network type of the client, can be used to help determine target bitrate.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Location> location() {
        return (Optional<Location>) location;
    }

    /**
     * Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks.
     */
    @JsonIgnore
    public Optional<Long> mediaBufferSize() {
        return mediaBufferSize;
    }

    /**
     * Index of the media to transcode. -1 or not specified indicates let the server choose.
     */
    @JsonIgnore
    public Optional<Long> mediaIndex() {
        return mediaIndex;
    }

    /**
     * Target bitrate for audio only files (in kbps, used to transcode).
     */
    @JsonIgnore
    public Optional<Long> musicBitrate() {
        return musicBitrate;
    }

    /**
     * Offset from the start of the media (in seconds).
     */
    @JsonIgnore
    public Optional<Double> offset() {
        return offset;
    }

    /**
     * Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode
     */
    @JsonIgnore
    public Optional<Long> partIndex() {
        return partIndex;
    }

    /**
     * Internal PMS path of the media to transcode.
     */
    @JsonIgnore
    public Optional<String> path() {
        return path;
    }

    /**
     * Maximum bitrate (in kbps) to use in ABR.
     */
    @JsonIgnore
    public Optional<Long> peakBitrate() {
        return peakBitrate;
    }

    /**
     * Target photo resolution.
     */
    @JsonIgnore
    public Optional<String> photoResolution() {
        return photoResolution;
    }

    /**
     * Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Protocol> protocol() {
        return (Optional<Protocol>) protocol;
    }

    /**
     * Number of seconds to include in each transcoded segment
     */
    @JsonIgnore
    public Optional<Long> secondsPerSegment() {
        return secondsPerSegment;
    }

    /**
     * Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)
     */
    @JsonIgnore
    public Optional<Long> subtitleSize() {
        return subtitleSize;
    }

    /**
     * Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Subtitles> subtitles() {
        return (Optional<Subtitles>) subtitles;
    }

    /**
     * Target video bitrate (in kbps).
     */
    @JsonIgnore
    public Optional<Long> videoBitrate() {
        return videoBitrate;
    }

    /**
     * Target photo quality.
     */
    @JsonIgnore
    public Optional<Long> videoQuality() {
        return videoQuality;
    }

    /**
     * Target maximum video resolution.
     */
    @JsonIgnore
    public Optional<String> videoResolution() {
        return videoResolution;
    }

    /**
     * See [Profile Augmentations](#section/API-Info/Profile-Augmentations) .
     */
    @JsonIgnore
    public Optional<String> xPlexClientProfileExtra() {
        return xPlexClientProfileExtra;
    }

    /**
     * Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile.
     */
    @JsonIgnore
    public Optional<String> xPlexClientProfileName() {
        return xPlexClientProfileName;
    }

    /**
     * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
     */
    @JsonIgnore
    public Optional<String> xPlexSessionIdentifier() {
        return xPlexSessionIdentifier;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public MakeDecisionRequest withAccepts(Accepts accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = Optional.ofNullable(accepts);
        return this;
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public MakeDecisionRequest withAccepts(Optional<? extends Accepts> accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = accepts;
        return this;
    }

    /**
     * An opaque identifier unique to the client
     */
    public MakeDecisionRequest withClientIdentifier(String clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = Optional.ofNullable(clientIdentifier);
        return this;
    }


    /**
     * An opaque identifier unique to the client
     */
    public MakeDecisionRequest withClientIdentifier(Optional<String> clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = clientIdentifier;
        return this;
    }

    /**
     * The name of the client product
     */
    public MakeDecisionRequest withProduct(String product) {
        Utils.checkNotNull(product, "product");
        this.product = Optional.ofNullable(product);
        return this;
    }


    /**
     * The name of the client product
     */
    public MakeDecisionRequest withProduct(Optional<String> product) {
        Utils.checkNotNull(product, "product");
        this.product = product;
        return this;
    }

    /**
     * The version of the client application
     */
    public MakeDecisionRequest withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }


    /**
     * The version of the client application
     */
    public MakeDecisionRequest withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * The platform of the client
     */
    public MakeDecisionRequest withPlatform(String platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = Optional.ofNullable(platform);
        return this;
    }


    /**
     * The platform of the client
     */
    public MakeDecisionRequest withPlatform(Optional<String> platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = platform;
        return this;
    }

    /**
     * The version of the platform
     */
    public MakeDecisionRequest withPlatformVersion(String platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = Optional.ofNullable(platformVersion);
        return this;
    }


    /**
     * The version of the platform
     */
    public MakeDecisionRequest withPlatformVersion(Optional<String> platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = platformVersion;
        return this;
    }

    /**
     * A relatively friendly name for the client device
     */
    public MakeDecisionRequest withDevice(String device) {
        Utils.checkNotNull(device, "device");
        this.device = Optional.ofNullable(device);
        return this;
    }


    /**
     * A relatively friendly name for the client device
     */
    public MakeDecisionRequest withDevice(Optional<String> device) {
        Utils.checkNotNull(device, "device");
        this.device = device;
        return this;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    public MakeDecisionRequest withModel(String model) {
        Utils.checkNotNull(model, "model");
        this.model = Optional.ofNullable(model);
        return this;
    }


    /**
     * A potentially less friendly identifier for the device model
     */
    public MakeDecisionRequest withModel(Optional<String> model) {
        Utils.checkNotNull(model, "model");
        this.model = model;
        return this;
    }

    /**
     * The device vendor
     */
    public MakeDecisionRequest withDeviceVendor(String deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = Optional.ofNullable(deviceVendor);
        return this;
    }


    /**
     * The device vendor
     */
    public MakeDecisionRequest withDeviceVendor(Optional<String> deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = deviceVendor;
        return this;
    }

    /**
     * A friendly name for the client
     */
    public MakeDecisionRequest withDeviceName(String deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = Optional.ofNullable(deviceName);
        return this;
    }


    /**
     * A friendly name for the client
     */
    public MakeDecisionRequest withDeviceName(Optional<String> deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = deviceName;
        return this;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    public MakeDecisionRequest withMarketplace(String marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = Optional.ofNullable(marketplace);
        return this;
    }


    /**
     * The marketplace on which the client application is distributed
     */
    public MakeDecisionRequest withMarketplace(Optional<String> marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = marketplace;
        return this;
    }

    /**
     * Type of transcode media
     */
    public MakeDecisionRequest withTranscodeType(TranscodeType transcodeType) {
        Utils.checkNotNull(transcodeType, "transcodeType");
        this.transcodeType = transcodeType;
        return this;
    }

    /**
     * Transcode session UUID
     */
    public MakeDecisionRequest withTranscodeSessionId(String transcodeSessionId) {
        Utils.checkNotNull(transcodeSessionId, "transcodeSessionId");
        this.transcodeSessionId = Optional.ofNullable(transcodeSessionId);
        return this;
    }


    /**
     * Transcode session UUID
     */
    public MakeDecisionRequest withTranscodeSessionId(Optional<String> transcodeSessionId) {
        Utils.checkNotNull(transcodeSessionId, "transcodeSessionId");
        this.transcodeSessionId = transcodeSessionId;
        return this;
    }

    /**
     * Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost
     */
    public MakeDecisionRequest withAdvancedSubtitles(AdvancedSubtitles advancedSubtitles) {
        Utils.checkNotNull(advancedSubtitles, "advancedSubtitles");
        this.advancedSubtitles = Optional.ofNullable(advancedSubtitles);
        return this;
    }


    /**
     * Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost
     */
    public MakeDecisionRequest withAdvancedSubtitles(Optional<? extends AdvancedSubtitles> advancedSubtitles) {
        Utils.checkNotNull(advancedSubtitles, "advancedSubtitles");
        this.advancedSubtitles = advancedSubtitles;
        return this;
    }

    /**
     * Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)
     */
    public MakeDecisionRequest withAudioBoost(long audioBoost) {
        Utils.checkNotNull(audioBoost, "audioBoost");
        this.audioBoost = Optional.ofNullable(audioBoost);
        return this;
    }


    /**
     * Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)
     */
    public MakeDecisionRequest withAudioBoost(Optional<Long> audioBoost) {
        Utils.checkNotNull(audioBoost, "audioBoost");
        this.audioBoost = audioBoost;
        return this;
    }

    /**
     * Target video number of audio channels.
     */
    public MakeDecisionRequest withAudioChannelCount(long audioChannelCount) {
        Utils.checkNotNull(audioChannelCount, "audioChannelCount");
        this.audioChannelCount = Optional.ofNullable(audioChannelCount);
        return this;
    }


    /**
     * Target video number of audio channels.
     */
    public MakeDecisionRequest withAudioChannelCount(Optional<Long> audioChannelCount) {
        Utils.checkNotNull(audioChannelCount, "audioChannelCount");
        this.audioChannelCount = audioChannelCount;
        return this;
    }

    /**
     * Indicates the client supports ABR.
     */
    public MakeDecisionRequest withAutoAdjustQuality(BoolInt autoAdjustQuality) {
        Utils.checkNotNull(autoAdjustQuality, "autoAdjustQuality");
        this.autoAdjustQuality = Optional.ofNullable(autoAdjustQuality);
        return this;
    }


    /**
     * Indicates the client supports ABR.
     */
    public MakeDecisionRequest withAutoAdjustQuality(Optional<? extends BoolInt> autoAdjustQuality) {
        Utils.checkNotNull(autoAdjustQuality, "autoAdjustQuality");
        this.autoAdjustQuality = autoAdjustQuality;
        return this;
    }

    /**
     * Indicates if the server should adjust subtitles based on Voice Activity Data.
     */
    public MakeDecisionRequest withAutoAdjustSubtitle(BoolInt autoAdjustSubtitle) {
        Utils.checkNotNull(autoAdjustSubtitle, "autoAdjustSubtitle");
        this.autoAdjustSubtitle = Optional.ofNullable(autoAdjustSubtitle);
        return this;
    }


    /**
     * Indicates if the server should adjust subtitles based on Voice Activity Data.
     */
    public MakeDecisionRequest withAutoAdjustSubtitle(Optional<? extends BoolInt> autoAdjustSubtitle) {
        Utils.checkNotNull(autoAdjustSubtitle, "autoAdjustSubtitle");
        this.autoAdjustSubtitle = autoAdjustSubtitle;
        return this;
    }

    /**
     * Indicates the client supports direct playing the indicated content.
     */
    public MakeDecisionRequest withDirectPlay(BoolInt directPlay) {
        Utils.checkNotNull(directPlay, "directPlay");
        this.directPlay = Optional.ofNullable(directPlay);
        return this;
    }


    /**
     * Indicates the client supports direct playing the indicated content.
     */
    public MakeDecisionRequest withDirectPlay(Optional<? extends BoolInt> directPlay) {
        Utils.checkNotNull(directPlay, "directPlay");
        this.directPlay = directPlay;
        return this;
    }

    /**
     * Indicates the client supports direct streaming the video of the indicated content.
     */
    public MakeDecisionRequest withDirectStream(BoolInt directStream) {
        Utils.checkNotNull(directStream, "directStream");
        this.directStream = Optional.ofNullable(directStream);
        return this;
    }


    /**
     * Indicates the client supports direct streaming the video of the indicated content.
     */
    public MakeDecisionRequest withDirectStream(Optional<? extends BoolInt> directStream) {
        Utils.checkNotNull(directStream, "directStream");
        this.directStream = directStream;
        return this;
    }

    /**
     * Indicates the client supports direct streaming the audio of the indicated content.
     */
    public MakeDecisionRequest withDirectStreamAudio(BoolInt directStreamAudio) {
        Utils.checkNotNull(directStreamAudio, "directStreamAudio");
        this.directStreamAudio = Optional.ofNullable(directStreamAudio);
        return this;
    }


    /**
     * Indicates the client supports direct streaming the audio of the indicated content.
     */
    public MakeDecisionRequest withDirectStreamAudio(Optional<? extends BoolInt> directStreamAudio) {
        Utils.checkNotNull(directStreamAudio, "directStreamAudio");
        this.directStreamAudio = directStreamAudio;
        return this;
    }

    /**
     * Indicates if resolution should be adjusted for orientation.
     */
    public MakeDecisionRequest withDisableResolutionRotation(BoolInt disableResolutionRotation) {
        Utils.checkNotNull(disableResolutionRotation, "disableResolutionRotation");
        this.disableResolutionRotation = Optional.ofNullable(disableResolutionRotation);
        return this;
    }


    /**
     * Indicates if resolution should be adjusted for orientation.
     */
    public MakeDecisionRequest withDisableResolutionRotation(Optional<? extends BoolInt> disableResolutionRotation) {
        Utils.checkNotNull(disableResolutionRotation, "disableResolutionRotation");
        this.disableResolutionRotation = disableResolutionRotation;
        return this;
    }

    /**
     * Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1
     */
    public MakeDecisionRequest withHasMDE(BoolInt hasMDE) {
        Utils.checkNotNull(hasMDE, "hasMDE");
        this.hasMDE = Optional.ofNullable(hasMDE);
        return this;
    }


    /**
     * Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1
     */
    public MakeDecisionRequest withHasMDE(Optional<? extends BoolInt> hasMDE) {
        Utils.checkNotNull(hasMDE, "hasMDE");
        this.hasMDE = hasMDE;
        return this;
    }

    /**
     * Network type of the client, can be used to help determine target bitrate.
     */
    public MakeDecisionRequest withLocation(Location location) {
        Utils.checkNotNull(location, "location");
        this.location = Optional.ofNullable(location);
        return this;
    }


    /**
     * Network type of the client, can be used to help determine target bitrate.
     */
    public MakeDecisionRequest withLocation(Optional<? extends Location> location) {
        Utils.checkNotNull(location, "location");
        this.location = location;
        return this;
    }

    /**
     * Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks.
     */
    public MakeDecisionRequest withMediaBufferSize(long mediaBufferSize) {
        Utils.checkNotNull(mediaBufferSize, "mediaBufferSize");
        this.mediaBufferSize = Optional.ofNullable(mediaBufferSize);
        return this;
    }


    /**
     * Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks.
     */
    public MakeDecisionRequest withMediaBufferSize(Optional<Long> mediaBufferSize) {
        Utils.checkNotNull(mediaBufferSize, "mediaBufferSize");
        this.mediaBufferSize = mediaBufferSize;
        return this;
    }

    /**
     * Index of the media to transcode. -1 or not specified indicates let the server choose.
     */
    public MakeDecisionRequest withMediaIndex(long mediaIndex) {
        Utils.checkNotNull(mediaIndex, "mediaIndex");
        this.mediaIndex = Optional.ofNullable(mediaIndex);
        return this;
    }


    /**
     * Index of the media to transcode. -1 or not specified indicates let the server choose.
     */
    public MakeDecisionRequest withMediaIndex(Optional<Long> mediaIndex) {
        Utils.checkNotNull(mediaIndex, "mediaIndex");
        this.mediaIndex = mediaIndex;
        return this;
    }

    /**
     * Target bitrate for audio only files (in kbps, used to transcode).
     */
    public MakeDecisionRequest withMusicBitrate(long musicBitrate) {
        Utils.checkNotNull(musicBitrate, "musicBitrate");
        this.musicBitrate = Optional.ofNullable(musicBitrate);
        return this;
    }


    /**
     * Target bitrate for audio only files (in kbps, used to transcode).
     */
    public MakeDecisionRequest withMusicBitrate(Optional<Long> musicBitrate) {
        Utils.checkNotNull(musicBitrate, "musicBitrate");
        this.musicBitrate = musicBitrate;
        return this;
    }

    /**
     * Offset from the start of the media (in seconds).
     */
    public MakeDecisionRequest withOffset(double offset) {
        Utils.checkNotNull(offset, "offset");
        this.offset = Optional.ofNullable(offset);
        return this;
    }


    /**
     * Offset from the start of the media (in seconds).
     */
    public MakeDecisionRequest withOffset(Optional<Double> offset) {
        Utils.checkNotNull(offset, "offset");
        this.offset = offset;
        return this;
    }

    /**
     * Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode
     */
    public MakeDecisionRequest withPartIndex(long partIndex) {
        Utils.checkNotNull(partIndex, "partIndex");
        this.partIndex = Optional.ofNullable(partIndex);
        return this;
    }


    /**
     * Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode
     */
    public MakeDecisionRequest withPartIndex(Optional<Long> partIndex) {
        Utils.checkNotNull(partIndex, "partIndex");
        this.partIndex = partIndex;
        return this;
    }

    /**
     * Internal PMS path of the media to transcode.
     */
    public MakeDecisionRequest withPath(String path) {
        Utils.checkNotNull(path, "path");
        this.path = Optional.ofNullable(path);
        return this;
    }


    /**
     * Internal PMS path of the media to transcode.
     */
    public MakeDecisionRequest withPath(Optional<String> path) {
        Utils.checkNotNull(path, "path");
        this.path = path;
        return this;
    }

    /**
     * Maximum bitrate (in kbps) to use in ABR.
     */
    public MakeDecisionRequest withPeakBitrate(long peakBitrate) {
        Utils.checkNotNull(peakBitrate, "peakBitrate");
        this.peakBitrate = Optional.ofNullable(peakBitrate);
        return this;
    }


    /**
     * Maximum bitrate (in kbps) to use in ABR.
     */
    public MakeDecisionRequest withPeakBitrate(Optional<Long> peakBitrate) {
        Utils.checkNotNull(peakBitrate, "peakBitrate");
        this.peakBitrate = peakBitrate;
        return this;
    }

    /**
     * Target photo resolution.
     */
    public MakeDecisionRequest withPhotoResolution(String photoResolution) {
        Utils.checkNotNull(photoResolution, "photoResolution");
        this.photoResolution = Optional.ofNullable(photoResolution);
        return this;
    }


    /**
     * Target photo resolution.
     */
    public MakeDecisionRequest withPhotoResolution(Optional<String> photoResolution) {
        Utils.checkNotNull(photoResolution, "photoResolution");
        this.photoResolution = photoResolution;
        return this;
    }

    /**
     * Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
     */
    public MakeDecisionRequest withProtocol(Protocol protocol) {
        Utils.checkNotNull(protocol, "protocol");
        this.protocol = Optional.ofNullable(protocol);
        return this;
    }


    /**
     * Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
     */
    public MakeDecisionRequest withProtocol(Optional<? extends Protocol> protocol) {
        Utils.checkNotNull(protocol, "protocol");
        this.protocol = protocol;
        return this;
    }

    /**
     * Number of seconds to include in each transcoded segment
     */
    public MakeDecisionRequest withSecondsPerSegment(long secondsPerSegment) {
        Utils.checkNotNull(secondsPerSegment, "secondsPerSegment");
        this.secondsPerSegment = Optional.ofNullable(secondsPerSegment);
        return this;
    }


    /**
     * Number of seconds to include in each transcoded segment
     */
    public MakeDecisionRequest withSecondsPerSegment(Optional<Long> secondsPerSegment) {
        Utils.checkNotNull(secondsPerSegment, "secondsPerSegment");
        this.secondsPerSegment = secondsPerSegment;
        return this;
    }

    /**
     * Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)
     */
    public MakeDecisionRequest withSubtitleSize(long subtitleSize) {
        Utils.checkNotNull(subtitleSize, "subtitleSize");
        this.subtitleSize = Optional.ofNullable(subtitleSize);
        return this;
    }


    /**
     * Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)
     */
    public MakeDecisionRequest withSubtitleSize(Optional<Long> subtitleSize) {
        Utils.checkNotNull(subtitleSize, "subtitleSize");
        this.subtitleSize = subtitleSize;
        return this;
    }

    /**
     * Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
     */
    public MakeDecisionRequest withSubtitles(Subtitles subtitles) {
        Utils.checkNotNull(subtitles, "subtitles");
        this.subtitles = Optional.ofNullable(subtitles);
        return this;
    }


    /**
     * Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
     */
    public MakeDecisionRequest withSubtitles(Optional<? extends Subtitles> subtitles) {
        Utils.checkNotNull(subtitles, "subtitles");
        this.subtitles = subtitles;
        return this;
    }

    /**
     * Target video bitrate (in kbps).
     */
    public MakeDecisionRequest withVideoBitrate(long videoBitrate) {
        Utils.checkNotNull(videoBitrate, "videoBitrate");
        this.videoBitrate = Optional.ofNullable(videoBitrate);
        return this;
    }


    /**
     * Target video bitrate (in kbps).
     */
    public MakeDecisionRequest withVideoBitrate(Optional<Long> videoBitrate) {
        Utils.checkNotNull(videoBitrate, "videoBitrate");
        this.videoBitrate = videoBitrate;
        return this;
    }

    /**
     * Target photo quality.
     */
    public MakeDecisionRequest withVideoQuality(long videoQuality) {
        Utils.checkNotNull(videoQuality, "videoQuality");
        this.videoQuality = Optional.ofNullable(videoQuality);
        return this;
    }


    /**
     * Target photo quality.
     */
    public MakeDecisionRequest withVideoQuality(Optional<Long> videoQuality) {
        Utils.checkNotNull(videoQuality, "videoQuality");
        this.videoQuality = videoQuality;
        return this;
    }

    /**
     * Target maximum video resolution.
     */
    public MakeDecisionRequest withVideoResolution(String videoResolution) {
        Utils.checkNotNull(videoResolution, "videoResolution");
        this.videoResolution = Optional.ofNullable(videoResolution);
        return this;
    }


    /**
     * Target maximum video resolution.
     */
    public MakeDecisionRequest withVideoResolution(Optional<String> videoResolution) {
        Utils.checkNotNull(videoResolution, "videoResolution");
        this.videoResolution = videoResolution;
        return this;
    }

    /**
     * See [Profile Augmentations](#section/API-Info/Profile-Augmentations) .
     */
    public MakeDecisionRequest withXPlexClientProfileExtra(String xPlexClientProfileExtra) {
        Utils.checkNotNull(xPlexClientProfileExtra, "xPlexClientProfileExtra");
        this.xPlexClientProfileExtra = Optional.ofNullable(xPlexClientProfileExtra);
        return this;
    }


    /**
     * See [Profile Augmentations](#section/API-Info/Profile-Augmentations) .
     */
    public MakeDecisionRequest withXPlexClientProfileExtra(Optional<String> xPlexClientProfileExtra) {
        Utils.checkNotNull(xPlexClientProfileExtra, "xPlexClientProfileExtra");
        this.xPlexClientProfileExtra = xPlexClientProfileExtra;
        return this;
    }

    /**
     * Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile.
     */
    public MakeDecisionRequest withXPlexClientProfileName(String xPlexClientProfileName) {
        Utils.checkNotNull(xPlexClientProfileName, "xPlexClientProfileName");
        this.xPlexClientProfileName = Optional.ofNullable(xPlexClientProfileName);
        return this;
    }


    /**
     * Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile.
     */
    public MakeDecisionRequest withXPlexClientProfileName(Optional<String> xPlexClientProfileName) {
        Utils.checkNotNull(xPlexClientProfileName, "xPlexClientProfileName");
        this.xPlexClientProfileName = xPlexClientProfileName;
        return this;
    }

    /**
     * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
     */
    public MakeDecisionRequest withXPlexSessionIdentifier(String xPlexSessionIdentifier) {
        Utils.checkNotNull(xPlexSessionIdentifier, "xPlexSessionIdentifier");
        this.xPlexSessionIdentifier = Optional.ofNullable(xPlexSessionIdentifier);
        return this;
    }


    /**
     * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
     */
    public MakeDecisionRequest withXPlexSessionIdentifier(Optional<String> xPlexSessionIdentifier) {
        Utils.checkNotNull(xPlexSessionIdentifier, "xPlexSessionIdentifier");
        this.xPlexSessionIdentifier = xPlexSessionIdentifier;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        MakeDecisionRequest other = (MakeDecisionRequest) o;
        return 
            Utils.enhancedDeepEquals(this.accepts, other.accepts) &&
            Utils.enhancedDeepEquals(this.clientIdentifier, other.clientIdentifier) &&
            Utils.enhancedDeepEquals(this.product, other.product) &&
            Utils.enhancedDeepEquals(this.version, other.version) &&
            Utils.enhancedDeepEquals(this.platform, other.platform) &&
            Utils.enhancedDeepEquals(this.platformVersion, other.platformVersion) &&
            Utils.enhancedDeepEquals(this.device, other.device) &&
            Utils.enhancedDeepEquals(this.model, other.model) &&
            Utils.enhancedDeepEquals(this.deviceVendor, other.deviceVendor) &&
            Utils.enhancedDeepEquals(this.deviceName, other.deviceName) &&
            Utils.enhancedDeepEquals(this.marketplace, other.marketplace) &&
            Utils.enhancedDeepEquals(this.transcodeType, other.transcodeType) &&
            Utils.enhancedDeepEquals(this.transcodeSessionId, other.transcodeSessionId) &&
            Utils.enhancedDeepEquals(this.advancedSubtitles, other.advancedSubtitles) &&
            Utils.enhancedDeepEquals(this.audioBoost, other.audioBoost) &&
            Utils.enhancedDeepEquals(this.audioChannelCount, other.audioChannelCount) &&
            Utils.enhancedDeepEquals(this.autoAdjustQuality, other.autoAdjustQuality) &&
            Utils.enhancedDeepEquals(this.autoAdjustSubtitle, other.autoAdjustSubtitle) &&
            Utils.enhancedDeepEquals(this.directPlay, other.directPlay) &&
            Utils.enhancedDeepEquals(this.directStream, other.directStream) &&
            Utils.enhancedDeepEquals(this.directStreamAudio, other.directStreamAudio) &&
            Utils.enhancedDeepEquals(this.disableResolutionRotation, other.disableResolutionRotation) &&
            Utils.enhancedDeepEquals(this.hasMDE, other.hasMDE) &&
            Utils.enhancedDeepEquals(this.location, other.location) &&
            Utils.enhancedDeepEquals(this.mediaBufferSize, other.mediaBufferSize) &&
            Utils.enhancedDeepEquals(this.mediaIndex, other.mediaIndex) &&
            Utils.enhancedDeepEquals(this.musicBitrate, other.musicBitrate) &&
            Utils.enhancedDeepEquals(this.offset, other.offset) &&
            Utils.enhancedDeepEquals(this.partIndex, other.partIndex) &&
            Utils.enhancedDeepEquals(this.path, other.path) &&
            Utils.enhancedDeepEquals(this.peakBitrate, other.peakBitrate) &&
            Utils.enhancedDeepEquals(this.photoResolution, other.photoResolution) &&
            Utils.enhancedDeepEquals(this.protocol, other.protocol) &&
            Utils.enhancedDeepEquals(this.secondsPerSegment, other.secondsPerSegment) &&
            Utils.enhancedDeepEquals(this.subtitleSize, other.subtitleSize) &&
            Utils.enhancedDeepEquals(this.subtitles, other.subtitles) &&
            Utils.enhancedDeepEquals(this.videoBitrate, other.videoBitrate) &&
            Utils.enhancedDeepEquals(this.videoQuality, other.videoQuality) &&
            Utils.enhancedDeepEquals(this.videoResolution, other.videoResolution) &&
            Utils.enhancedDeepEquals(this.xPlexClientProfileExtra, other.xPlexClientProfileExtra) &&
            Utils.enhancedDeepEquals(this.xPlexClientProfileName, other.xPlexClientProfileName) &&
            Utils.enhancedDeepEquals(this.xPlexSessionIdentifier, other.xPlexSessionIdentifier);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            accepts, clientIdentifier, product,
            version, platform, platformVersion,
            device, model, deviceVendor,
            deviceName, marketplace, transcodeType,
            transcodeSessionId, advancedSubtitles, audioBoost,
            audioChannelCount, autoAdjustQuality, autoAdjustSubtitle,
            directPlay, directStream, directStreamAudio,
            disableResolutionRotation, hasMDE, location,
            mediaBufferSize, mediaIndex, musicBitrate,
            offset, partIndex, path,
            peakBitrate, photoResolution, protocol,
            secondsPerSegment, subtitleSize, subtitles,
            videoBitrate, videoQuality, videoResolution,
            xPlexClientProfileExtra, xPlexClientProfileName, xPlexSessionIdentifier);
    }
    
    @Override
    public String toString() {
        return Utils.toString(MakeDecisionRequest.class,
                "accepts", accepts,
                "clientIdentifier", clientIdentifier,
                "product", product,
                "version", version,
                "platform", platform,
                "platformVersion", platformVersion,
                "device", device,
                "model", model,
                "deviceVendor", deviceVendor,
                "deviceName", deviceName,
                "marketplace", marketplace,
                "transcodeType", transcodeType,
                "transcodeSessionId", transcodeSessionId,
                "advancedSubtitles", advancedSubtitles,
                "audioBoost", audioBoost,
                "audioChannelCount", audioChannelCount,
                "autoAdjustQuality", autoAdjustQuality,
                "autoAdjustSubtitle", autoAdjustSubtitle,
                "directPlay", directPlay,
                "directStream", directStream,
                "directStreamAudio", directStreamAudio,
                "disableResolutionRotation", disableResolutionRotation,
                "hasMDE", hasMDE,
                "location", location,
                "mediaBufferSize", mediaBufferSize,
                "mediaIndex", mediaIndex,
                "musicBitrate", musicBitrate,
                "offset", offset,
                "partIndex", partIndex,
                "path", path,
                "peakBitrate", peakBitrate,
                "photoResolution", photoResolution,
                "protocol", protocol,
                "secondsPerSegment", secondsPerSegment,
                "subtitleSize", subtitleSize,
                "subtitles", subtitles,
                "videoBitrate", videoBitrate,
                "videoQuality", videoQuality,
                "videoResolution", videoResolution,
                "xPlexClientProfileExtra", xPlexClientProfileExtra,
                "xPlexClientProfileName", xPlexClientProfileName,
                "xPlexSessionIdentifier", xPlexSessionIdentifier);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends Accepts> accepts;

        private Optional<String> clientIdentifier = Optional.empty();

        private Optional<String> product = Optional.empty();

        private Optional<String> version = Optional.empty();

        private Optional<String> platform = Optional.empty();

        private Optional<String> platformVersion = Optional.empty();

        private Optional<String> device = Optional.empty();

        private Optional<String> model = Optional.empty();

        private Optional<String> deviceVendor = Optional.empty();

        private Optional<String> deviceName = Optional.empty();

        private Optional<String> marketplace = Optional.empty();

        private TranscodeType transcodeType;

        private Optional<String> transcodeSessionId = Optional.empty();

        private Optional<? extends AdvancedSubtitles> advancedSubtitles = Optional.empty();

        private Optional<Long> audioBoost = Optional.empty();

        private Optional<Long> audioChannelCount = Optional.empty();

        private Optional<? extends BoolInt> autoAdjustQuality;

        private Optional<? extends BoolInt> autoAdjustSubtitle;

        private Optional<? extends BoolInt> directPlay;

        private Optional<? extends BoolInt> directStream;

        private Optional<? extends BoolInt> directStreamAudio;

        private Optional<? extends BoolInt> disableResolutionRotation;

        private Optional<? extends BoolInt> hasMDE;

        private Optional<? extends Location> location = Optional.empty();

        private Optional<Long> mediaBufferSize = Optional.empty();

        private Optional<Long> mediaIndex = Optional.empty();

        private Optional<Long> musicBitrate = Optional.empty();

        private Optional<Double> offset = Optional.empty();

        private Optional<Long> partIndex = Optional.empty();

        private Optional<String> path = Optional.empty();

        private Optional<Long> peakBitrate = Optional.empty();

        private Optional<String> photoResolution = Optional.empty();

        private Optional<? extends Protocol> protocol = Optional.empty();

        private Optional<Long> secondsPerSegment = Optional.empty();

        private Optional<Long> subtitleSize = Optional.empty();

        private Optional<? extends Subtitles> subtitles = Optional.empty();

        private Optional<Long> videoBitrate = Optional.empty();

        private Optional<Long> videoQuality = Optional.empty();

        private Optional<String> videoResolution = Optional.empty();

        private Optional<String> xPlexClientProfileExtra = Optional.empty();

        private Optional<String> xPlexClientProfileName = Optional.empty();

        private Optional<String> xPlexSessionIdentifier = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Accepts accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = Optional.ofNullable(accepts);
            return this;
        }

        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Optional<? extends Accepts> accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = accepts;
            return this;
        }


        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(String clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = Optional.ofNullable(clientIdentifier);
            return this;
        }

        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(Optional<String> clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = clientIdentifier;
            return this;
        }


        /**
         * The name of the client product
         */
        public Builder product(String product) {
            Utils.checkNotNull(product, "product");
            this.product = Optional.ofNullable(product);
            return this;
        }

        /**
         * The name of the client product
         */
        public Builder product(Optional<String> product) {
            Utils.checkNotNull(product, "product");
            this.product = product;
            return this;
        }


        /**
         * The version of the client application
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The version of the client application
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }


        /**
         * The platform of the client
         */
        public Builder platform(String platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = Optional.ofNullable(platform);
            return this;
        }

        /**
         * The platform of the client
         */
        public Builder platform(Optional<String> platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = platform;
            return this;
        }


        /**
         * The version of the platform
         */
        public Builder platformVersion(String platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = Optional.ofNullable(platformVersion);
            return this;
        }

        /**
         * The version of the platform
         */
        public Builder platformVersion(Optional<String> platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = platformVersion;
            return this;
        }


        /**
         * A relatively friendly name for the client device
         */
        public Builder device(String device) {
            Utils.checkNotNull(device, "device");
            this.device = Optional.ofNullable(device);
            return this;
        }

        /**
         * A relatively friendly name for the client device
         */
        public Builder device(Optional<String> device) {
            Utils.checkNotNull(device, "device");
            this.device = device;
            return this;
        }


        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(String model) {
            Utils.checkNotNull(model, "model");
            this.model = Optional.ofNullable(model);
            return this;
        }

        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(Optional<String> model) {
            Utils.checkNotNull(model, "model");
            this.model = model;
            return this;
        }


        /**
         * The device vendor
         */
        public Builder deviceVendor(String deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = Optional.ofNullable(deviceVendor);
            return this;
        }

        /**
         * The device vendor
         */
        public Builder deviceVendor(Optional<String> deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = deviceVendor;
            return this;
        }


        /**
         * A friendly name for the client
         */
        public Builder deviceName(String deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = Optional.ofNullable(deviceName);
            return this;
        }

        /**
         * A friendly name for the client
         */
        public Builder deviceName(Optional<String> deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = deviceName;
            return this;
        }


        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(String marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = Optional.ofNullable(marketplace);
            return this;
        }

        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(Optional<String> marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = marketplace;
            return this;
        }


        /**
         * Type of transcode media
         */
        public Builder transcodeType(TranscodeType transcodeType) {
            Utils.checkNotNull(transcodeType, "transcodeType");
            this.transcodeType = transcodeType;
            return this;
        }


        /**
         * Transcode session UUID
         */
        public Builder transcodeSessionId(String transcodeSessionId) {
            Utils.checkNotNull(transcodeSessionId, "transcodeSessionId");
            this.transcodeSessionId = Optional.ofNullable(transcodeSessionId);
            return this;
        }

        /**
         * Transcode session UUID
         */
        public Builder transcodeSessionId(Optional<String> transcodeSessionId) {
            Utils.checkNotNull(transcodeSessionId, "transcodeSessionId");
            this.transcodeSessionId = transcodeSessionId;
            return this;
        }


        /**
         * Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost
         */
        public Builder advancedSubtitles(AdvancedSubtitles advancedSubtitles) {
            Utils.checkNotNull(advancedSubtitles, "advancedSubtitles");
            this.advancedSubtitles = Optional.ofNullable(advancedSubtitles);
            return this;
        }

        /**
         * Indicates how incompatible advanced subtitles (such as ass/ssa) should be included: * 'burn' - Burn incompatible advanced text subtitles into the video stream * 'text' - Transcode incompatible advanced text subtitles to a compatible text format, even if some markup is lost
         */
        public Builder advancedSubtitles(Optional<? extends AdvancedSubtitles> advancedSubtitles) {
            Utils.checkNotNull(advancedSubtitles, "advancedSubtitles");
            this.advancedSubtitles = advancedSubtitles;
            return this;
        }


        /**
         * Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)
         */
        public Builder audioBoost(long audioBoost) {
            Utils.checkNotNull(audioBoost, "audioBoost");
            this.audioBoost = Optional.ofNullable(audioBoost);
            return this;
        }

        /**
         * Percentage of original audio loudness to use when transcoding (100 is equivalent to original volume, 50 is half, 200 is double, etc)
         */
        public Builder audioBoost(Optional<Long> audioBoost) {
            Utils.checkNotNull(audioBoost, "audioBoost");
            this.audioBoost = audioBoost;
            return this;
        }


        /**
         * Target video number of audio channels.
         */
        public Builder audioChannelCount(long audioChannelCount) {
            Utils.checkNotNull(audioChannelCount, "audioChannelCount");
            this.audioChannelCount = Optional.ofNullable(audioChannelCount);
            return this;
        }

        /**
         * Target video number of audio channels.
         */
        public Builder audioChannelCount(Optional<Long> audioChannelCount) {
            Utils.checkNotNull(audioChannelCount, "audioChannelCount");
            this.audioChannelCount = audioChannelCount;
            return this;
        }


        /**
         * Indicates the client supports ABR.
         */
        public Builder autoAdjustQuality(BoolInt autoAdjustQuality) {
            Utils.checkNotNull(autoAdjustQuality, "autoAdjustQuality");
            this.autoAdjustQuality = Optional.ofNullable(autoAdjustQuality);
            return this;
        }

        /**
         * Indicates the client supports ABR.
         */
        public Builder autoAdjustQuality(Optional<? extends BoolInt> autoAdjustQuality) {
            Utils.checkNotNull(autoAdjustQuality, "autoAdjustQuality");
            this.autoAdjustQuality = autoAdjustQuality;
            return this;
        }


        /**
         * Indicates if the server should adjust subtitles based on Voice Activity Data.
         */
        public Builder autoAdjustSubtitle(BoolInt autoAdjustSubtitle) {
            Utils.checkNotNull(autoAdjustSubtitle, "autoAdjustSubtitle");
            this.autoAdjustSubtitle = Optional.ofNullable(autoAdjustSubtitle);
            return this;
        }

        /**
         * Indicates if the server should adjust subtitles based on Voice Activity Data.
         */
        public Builder autoAdjustSubtitle(Optional<? extends BoolInt> autoAdjustSubtitle) {
            Utils.checkNotNull(autoAdjustSubtitle, "autoAdjustSubtitle");
            this.autoAdjustSubtitle = autoAdjustSubtitle;
            return this;
        }


        /**
         * Indicates the client supports direct playing the indicated content.
         */
        public Builder directPlay(BoolInt directPlay) {
            Utils.checkNotNull(directPlay, "directPlay");
            this.directPlay = Optional.ofNullable(directPlay);
            return this;
        }

        /**
         * Indicates the client supports direct playing the indicated content.
         */
        public Builder directPlay(Optional<? extends BoolInt> directPlay) {
            Utils.checkNotNull(directPlay, "directPlay");
            this.directPlay = directPlay;
            return this;
        }


        /**
         * Indicates the client supports direct streaming the video of the indicated content.
         */
        public Builder directStream(BoolInt directStream) {
            Utils.checkNotNull(directStream, "directStream");
            this.directStream = Optional.ofNullable(directStream);
            return this;
        }

        /**
         * Indicates the client supports direct streaming the video of the indicated content.
         */
        public Builder directStream(Optional<? extends BoolInt> directStream) {
            Utils.checkNotNull(directStream, "directStream");
            this.directStream = directStream;
            return this;
        }


        /**
         * Indicates the client supports direct streaming the audio of the indicated content.
         */
        public Builder directStreamAudio(BoolInt directStreamAudio) {
            Utils.checkNotNull(directStreamAudio, "directStreamAudio");
            this.directStreamAudio = Optional.ofNullable(directStreamAudio);
            return this;
        }

        /**
         * Indicates the client supports direct streaming the audio of the indicated content.
         */
        public Builder directStreamAudio(Optional<? extends BoolInt> directStreamAudio) {
            Utils.checkNotNull(directStreamAudio, "directStreamAudio");
            this.directStreamAudio = directStreamAudio;
            return this;
        }


        /**
         * Indicates if resolution should be adjusted for orientation.
         */
        public Builder disableResolutionRotation(BoolInt disableResolutionRotation) {
            Utils.checkNotNull(disableResolutionRotation, "disableResolutionRotation");
            this.disableResolutionRotation = Optional.ofNullable(disableResolutionRotation);
            return this;
        }

        /**
         * Indicates if resolution should be adjusted for orientation.
         */
        public Builder disableResolutionRotation(Optional<? extends BoolInt> disableResolutionRotation) {
            Utils.checkNotNull(disableResolutionRotation, "disableResolutionRotation");
            this.disableResolutionRotation = disableResolutionRotation;
            return this;
        }


        /**
         * Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1
         */
        public Builder hasMDE(BoolInt hasMDE) {
            Utils.checkNotNull(hasMDE, "hasMDE");
            this.hasMDE = Optional.ofNullable(hasMDE);
            return this;
        }

        /**
         * Ignore client profiles when determining if direct play is possible. Only has an effect when directPlay=1 and both mediaIndex and partIndex are specified and neither are -1
         */
        public Builder hasMDE(Optional<? extends BoolInt> hasMDE) {
            Utils.checkNotNull(hasMDE, "hasMDE");
            this.hasMDE = hasMDE;
            return this;
        }


        /**
         * Network type of the client, can be used to help determine target bitrate.
         */
        public Builder location(Location location) {
            Utils.checkNotNull(location, "location");
            this.location = Optional.ofNullable(location);
            return this;
        }

        /**
         * Network type of the client, can be used to help determine target bitrate.
         */
        public Builder location(Optional<? extends Location> location) {
            Utils.checkNotNull(location, "location");
            this.location = location;
            return this;
        }


        /**
         * Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks.
         */
        public Builder mediaBufferSize(long mediaBufferSize) {
            Utils.checkNotNull(mediaBufferSize, "mediaBufferSize");
            this.mediaBufferSize = Optional.ofNullable(mediaBufferSize);
            return this;
        }

        /**
         * Buffer size used in playback (in KB). Clients should specify a lower bound if not known exactly. This value could make the difference between transcoding and direct play on bandwidth constrained networks.
         */
        public Builder mediaBufferSize(Optional<Long> mediaBufferSize) {
            Utils.checkNotNull(mediaBufferSize, "mediaBufferSize");
            this.mediaBufferSize = mediaBufferSize;
            return this;
        }


        /**
         * Index of the media to transcode. -1 or not specified indicates let the server choose.
         */
        public Builder mediaIndex(long mediaIndex) {
            Utils.checkNotNull(mediaIndex, "mediaIndex");
            this.mediaIndex = Optional.ofNullable(mediaIndex);
            return this;
        }

        /**
         * Index of the media to transcode. -1 or not specified indicates let the server choose.
         */
        public Builder mediaIndex(Optional<Long> mediaIndex) {
            Utils.checkNotNull(mediaIndex, "mediaIndex");
            this.mediaIndex = mediaIndex;
            return this;
        }


        /**
         * Target bitrate for audio only files (in kbps, used to transcode).
         */
        public Builder musicBitrate(long musicBitrate) {
            Utils.checkNotNull(musicBitrate, "musicBitrate");
            this.musicBitrate = Optional.ofNullable(musicBitrate);
            return this;
        }

        /**
         * Target bitrate for audio only files (in kbps, used to transcode).
         */
        public Builder musicBitrate(Optional<Long> musicBitrate) {
            Utils.checkNotNull(musicBitrate, "musicBitrate");
            this.musicBitrate = musicBitrate;
            return this;
        }


        /**
         * Offset from the start of the media (in seconds).
         */
        public Builder offset(double offset) {
            Utils.checkNotNull(offset, "offset");
            this.offset = Optional.ofNullable(offset);
            return this;
        }

        /**
         * Offset from the start of the media (in seconds).
         */
        public Builder offset(Optional<Double> offset) {
            Utils.checkNotNull(offset, "offset");
            this.offset = offset;
            return this;
        }


        /**
         * Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode
         */
        public Builder partIndex(long partIndex) {
            Utils.checkNotNull(partIndex, "partIndex");
            this.partIndex = Optional.ofNullable(partIndex);
            return this;
        }

        /**
         * Index of the part to transcode. -1 or not specified indicates the server should join parts together in a transcode
         */
        public Builder partIndex(Optional<Long> partIndex) {
            Utils.checkNotNull(partIndex, "partIndex");
            this.partIndex = partIndex;
            return this;
        }


        /**
         * Internal PMS path of the media to transcode.
         */
        public Builder path(String path) {
            Utils.checkNotNull(path, "path");
            this.path = Optional.ofNullable(path);
            return this;
        }

        /**
         * Internal PMS path of the media to transcode.
         */
        public Builder path(Optional<String> path) {
            Utils.checkNotNull(path, "path");
            this.path = path;
            return this;
        }


        /**
         * Maximum bitrate (in kbps) to use in ABR.
         */
        public Builder peakBitrate(long peakBitrate) {
            Utils.checkNotNull(peakBitrate, "peakBitrate");
            this.peakBitrate = Optional.ofNullable(peakBitrate);
            return this;
        }

        /**
         * Maximum bitrate (in kbps) to use in ABR.
         */
        public Builder peakBitrate(Optional<Long> peakBitrate) {
            Utils.checkNotNull(peakBitrate, "peakBitrate");
            this.peakBitrate = peakBitrate;
            return this;
        }


        /**
         * Target photo resolution.
         */
        public Builder photoResolution(String photoResolution) {
            Utils.checkNotNull(photoResolution, "photoResolution");
            this.photoResolution = Optional.ofNullable(photoResolution);
            return this;
        }

        /**
         * Target photo resolution.
         */
        public Builder photoResolution(Optional<String> photoResolution) {
            Utils.checkNotNull(photoResolution, "photoResolution");
            this.photoResolution = photoResolution;
            return this;
        }


        /**
         * Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
         */
        public Builder protocol(Protocol protocol) {
            Utils.checkNotNull(protocol, "protocol");
            this.protocol = Optional.ofNullable(protocol);
            return this;
        }

        /**
         * Indicates the network streaming protocol to be used for the transcode session: * 'http' - include the file in the http response such as MKV streaming * 'hls' - hls stream (RFC 8216) * 'dash' - dash stream (ISO/IEC 23009-1:2022)
         */
        public Builder protocol(Optional<? extends Protocol> protocol) {
            Utils.checkNotNull(protocol, "protocol");
            this.protocol = protocol;
            return this;
        }


        /**
         * Number of seconds to include in each transcoded segment
         */
        public Builder secondsPerSegment(long secondsPerSegment) {
            Utils.checkNotNull(secondsPerSegment, "secondsPerSegment");
            this.secondsPerSegment = Optional.ofNullable(secondsPerSegment);
            return this;
        }

        /**
         * Number of seconds to include in each transcoded segment
         */
        public Builder secondsPerSegment(Optional<Long> secondsPerSegment) {
            Utils.checkNotNull(secondsPerSegment, "secondsPerSegment");
            this.secondsPerSegment = secondsPerSegment;
            return this;
        }


        /**
         * Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)
         */
        public Builder subtitleSize(long subtitleSize) {
            Utils.checkNotNull(subtitleSize, "subtitleSize");
            this.subtitleSize = Optional.ofNullable(subtitleSize);
            return this;
        }

        /**
         * Percentage of original subtitle size to use when burning subtitles (100 is equivalent to original size, 50 is half, ect)
         */
        public Builder subtitleSize(Optional<Long> subtitleSize) {
            Utils.checkNotNull(subtitleSize, "subtitleSize");
            this.subtitleSize = subtitleSize;
            return this;
        }


        /**
         * Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
         */
        public Builder subtitles(Subtitles subtitles) {
            Utils.checkNotNull(subtitles, "subtitles");
            this.subtitles = Optional.ofNullable(subtitles);
            return this;
        }

        /**
         * Indicates how subtitles should be included: * 'auto' - Compute the appropriate subtitle setting automatically * 'burn' - Burn the selected subtitle; auto if no selected subtitle * 'none' - Ignore all subtitle streams * 'sidecar' - The selected subtitle should be provided as a sidecar * 'embedded' - The selected subtitle should be provided as an embedded stream * 'segmented' - The selected subtitle should be provided as a segmented stream
         */
        public Builder subtitles(Optional<? extends Subtitles> subtitles) {
            Utils.checkNotNull(subtitles, "subtitles");
            this.subtitles = subtitles;
            return this;
        }


        /**
         * Target video bitrate (in kbps).
         */
        public Builder videoBitrate(long videoBitrate) {
            Utils.checkNotNull(videoBitrate, "videoBitrate");
            this.videoBitrate = Optional.ofNullable(videoBitrate);
            return this;
        }

        /**
         * Target video bitrate (in kbps).
         */
        public Builder videoBitrate(Optional<Long> videoBitrate) {
            Utils.checkNotNull(videoBitrate, "videoBitrate");
            this.videoBitrate = videoBitrate;
            return this;
        }


        /**
         * Target photo quality.
         */
        public Builder videoQuality(long videoQuality) {
            Utils.checkNotNull(videoQuality, "videoQuality");
            this.videoQuality = Optional.ofNullable(videoQuality);
            return this;
        }

        /**
         * Target photo quality.
         */
        public Builder videoQuality(Optional<Long> videoQuality) {
            Utils.checkNotNull(videoQuality, "videoQuality");
            this.videoQuality = videoQuality;
            return this;
        }


        /**
         * Target maximum video resolution.
         */
        public Builder videoResolution(String videoResolution) {
            Utils.checkNotNull(videoResolution, "videoResolution");
            this.videoResolution = Optional.ofNullable(videoResolution);
            return this;
        }

        /**
         * Target maximum video resolution.
         */
        public Builder videoResolution(Optional<String> videoResolution) {
            Utils.checkNotNull(videoResolution, "videoResolution");
            this.videoResolution = videoResolution;
            return this;
        }


        /**
         * See [Profile Augmentations](#section/API-Info/Profile-Augmentations) .
         */
        public Builder xPlexClientProfileExtra(String xPlexClientProfileExtra) {
            Utils.checkNotNull(xPlexClientProfileExtra, "xPlexClientProfileExtra");
            this.xPlexClientProfileExtra = Optional.ofNullable(xPlexClientProfileExtra);
            return this;
        }

        /**
         * See [Profile Augmentations](#section/API-Info/Profile-Augmentations) .
         */
        public Builder xPlexClientProfileExtra(Optional<String> xPlexClientProfileExtra) {
            Utils.checkNotNull(xPlexClientProfileExtra, "xPlexClientProfileExtra");
            this.xPlexClientProfileExtra = xPlexClientProfileExtra;
            return this;
        }


        /**
         * Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile.
         */
        public Builder xPlexClientProfileName(String xPlexClientProfileName) {
            Utils.checkNotNull(xPlexClientProfileName, "xPlexClientProfileName");
            this.xPlexClientProfileName = Optional.ofNullable(xPlexClientProfileName);
            return this;
        }

        /**
         * Which built in Client Profile to use in the decision. Generally should only be used to specify the Generic profile.
         */
        public Builder xPlexClientProfileName(Optional<String> xPlexClientProfileName) {
            Utils.checkNotNull(xPlexClientProfileName, "xPlexClientProfileName");
            this.xPlexClientProfileName = xPlexClientProfileName;
            return this;
        }


        /**
         * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
         */
        public Builder xPlexSessionIdentifier(String xPlexSessionIdentifier) {
            Utils.checkNotNull(xPlexSessionIdentifier, "xPlexSessionIdentifier");
            this.xPlexSessionIdentifier = Optional.ofNullable(xPlexSessionIdentifier);
            return this;
        }

        /**
         * Unique per client playback session.  Used if a client can playback multiple items at a time (such as a browser with multiple tabs)
         */
        public Builder xPlexSessionIdentifier(Optional<String> xPlexSessionIdentifier) {
            Utils.checkNotNull(xPlexSessionIdentifier, "xPlexSessionIdentifier");
            this.xPlexSessionIdentifier = xPlexSessionIdentifier;
            return this;
        }

        public MakeDecisionRequest build() {
            if (accepts == null) {
                accepts = _SINGLETON_VALUE_Accepts.value();
            }
            if (autoAdjustQuality == null) {
                autoAdjustQuality = _SINGLETON_VALUE_AutoAdjustQuality.value();
            }
            if (autoAdjustSubtitle == null) {
                autoAdjustSubtitle = _SINGLETON_VALUE_AutoAdjustSubtitle.value();
            }
            if (directPlay == null) {
                directPlay = _SINGLETON_VALUE_DirectPlay.value();
            }
            if (directStream == null) {
                directStream = _SINGLETON_VALUE_DirectStream.value();
            }
            if (directStreamAudio == null) {
                directStreamAudio = _SINGLETON_VALUE_DirectStreamAudio.value();
            }
            if (disableResolutionRotation == null) {
                disableResolutionRotation = _SINGLETON_VALUE_DisableResolutionRotation.value();
            }
            if (hasMDE == null) {
                hasMDE = _SINGLETON_VALUE_HasMDE.value();
            }

            return new MakeDecisionRequest(
                accepts, clientIdentifier, product,
                version, platform, platformVersion,
                device, model, deviceVendor,
                deviceName, marketplace, transcodeType,
                transcodeSessionId, advancedSubtitles, audioBoost,
                audioChannelCount, autoAdjustQuality, autoAdjustSubtitle,
                directPlay, directStream, directStreamAudio,
                disableResolutionRotation, hasMDE, location,
                mediaBufferSize, mediaIndex, musicBitrate,
                offset, partIndex, path,
                peakBitrate, photoResolution, protocol,
                secondsPerSegment, subtitleSize, subtitles,
                videoBitrate, videoQuality, videoResolution,
                xPlexClientProfileExtra, xPlexClientProfileName, xPlexSessionIdentifier);
        }


        private static final LazySingletonValue<Optional<? extends Accepts>> _SINGLETON_VALUE_Accepts =
                new LazySingletonValue<>(
                        "accepts",
                        "\"application/xml\"",
                        new TypeReference<Optional<? extends Accepts>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_AutoAdjustQuality =
                new LazySingletonValue<>(
                        "autoAdjustQuality",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_AutoAdjustSubtitle =
                new LazySingletonValue<>(
                        "autoAdjustSubtitle",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_DirectPlay =
                new LazySingletonValue<>(
                        "directPlay",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_DirectStream =
                new LazySingletonValue<>(
                        "directStream",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_DirectStreamAudio =
                new LazySingletonValue<>(
                        "directStreamAudio",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_DisableResolutionRotation =
                new LazySingletonValue<>(
                        "disableResolutionRotation",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_HasMDE =
                new LazySingletonValue<>(
                        "hasMDE",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});
    }
}
