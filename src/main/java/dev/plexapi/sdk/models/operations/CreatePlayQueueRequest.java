/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.models.shared.Accepts;
import dev.plexapi.sdk.models.shared.BoolInt;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.SpeakeasyMetadata;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;


public class CreatePlayQueueRequest {
    /**
     * Indicates the client accepts the indicated media types
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=accepts")
    private Optional<? extends Accepts> accepts;

    /**
     * An opaque identifier unique to the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Client-Identifier")
    private Optional<String> clientIdentifier;

    /**
     * The name of the client product
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Product")
    private Optional<String> product;

    /**
     * The version of the client application
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Version")
    private Optional<String> version;

    /**
     * The platform of the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform")
    private Optional<String> platform;

    /**
     * The version of the platform
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform-Version")
    private Optional<String> platformVersion;

    /**
     * A relatively friendly name for the client device
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device")
    private Optional<String> device;

    /**
     * A potentially less friendly identifier for the device model
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Model")
    private Optional<String> model;

    /**
     * The device vendor
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Vendor")
    private Optional<String> deviceVendor;

    /**
     * A friendly name for the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Name")
    private Optional<String> deviceName;

    /**
     * The marketplace on which the client application is distributed
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Marketplace")
    private Optional<String> marketplace;

    /**
     * The content URI for what we're playing.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=uri")
    private Optional<String> uri;

    /**
     * the ID of the playlist we're playing.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=playlistID")
    private Optional<Long> playlistID;

    /**
     * The type of play queue to create
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=type")
    private Type type;

    /**
     * The key of the first item to play, defaults to the first in the play queue.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=key")
    private Optional<String> key;

    /**
     * Whether to shuffle the playlist, defaults to 0.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=shuffle")
    private Optional<? extends BoolInt> shuffle;

    /**
     * If the PQ is bigger than the window, fill any empty space with wraparound items, defaults to 0.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=repeat")
    private Optional<? extends BoolInt> repeat;

    /**
     * Whether to create a continuous play queue (e.g. from an episode), defaults to 0.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=continuous")
    private Optional<? extends BoolInt> continuous;

    /**
     * Number of trailers to prepend a movie with not including the pre-roll. If omitted the pre-roll will not be returned in the play queue. When resuming a movie `extrasPrefixCount` should be omitted as a parameter instead of passing 0.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=extrasPrefixCount")
    private Optional<Long> extrasPrefixCount;

    /**
     * Only applies to queues of type photo, whether to retrieve all descendent photos from an album or section, defaults to 1.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=recursive")
    private Optional<? extends BoolInt> recursive;

    /**
     * Only applies to queues of type show or seasons, whether to return a queue that is started on the On Deck episode if one exists. Otherwise begins the play queue on the beginning of the show or season.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=onDeck")
    private Optional<? extends BoolInt> onDeck;

    @JsonCreator
    public CreatePlayQueueRequest(
            Optional<? extends Accepts> accepts,
            Optional<String> clientIdentifier,
            Optional<String> product,
            Optional<String> version,
            Optional<String> platform,
            Optional<String> platformVersion,
            Optional<String> device,
            Optional<String> model,
            Optional<String> deviceVendor,
            Optional<String> deviceName,
            Optional<String> marketplace,
            Optional<String> uri,
            Optional<Long> playlistID,
            Type type,
            Optional<String> key,
            Optional<? extends BoolInt> shuffle,
            Optional<? extends BoolInt> repeat,
            Optional<? extends BoolInt> continuous,
            Optional<Long> extrasPrefixCount,
            Optional<? extends BoolInt> recursive,
            Optional<? extends BoolInt> onDeck) {
        Utils.checkNotNull(accepts, "accepts");
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        Utils.checkNotNull(product, "product");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(platform, "platform");
        Utils.checkNotNull(platformVersion, "platformVersion");
        Utils.checkNotNull(device, "device");
        Utils.checkNotNull(model, "model");
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        Utils.checkNotNull(deviceName, "deviceName");
        Utils.checkNotNull(marketplace, "marketplace");
        Utils.checkNotNull(uri, "uri");
        Utils.checkNotNull(playlistID, "playlistID");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(shuffle, "shuffle");
        Utils.checkNotNull(repeat, "repeat");
        Utils.checkNotNull(continuous, "continuous");
        Utils.checkNotNull(extrasPrefixCount, "extrasPrefixCount");
        Utils.checkNotNull(recursive, "recursive");
        Utils.checkNotNull(onDeck, "onDeck");
        this.accepts = accepts;
        this.clientIdentifier = clientIdentifier;
        this.product = product;
        this.version = version;
        this.platform = platform;
        this.platformVersion = platformVersion;
        this.device = device;
        this.model = model;
        this.deviceVendor = deviceVendor;
        this.deviceName = deviceName;
        this.marketplace = marketplace;
        this.uri = uri;
        this.playlistID = playlistID;
        this.type = type;
        this.key = key;
        this.shuffle = shuffle;
        this.repeat = repeat;
        this.continuous = continuous;
        this.extrasPrefixCount = extrasPrefixCount;
        this.recursive = recursive;
        this.onDeck = onDeck;
    }
    
    public CreatePlayQueueRequest(
            Type type) {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), type, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Indicates the client accepts the indicated media types
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Accepts> accepts() {
        return (Optional<Accepts>) accepts;
    }

    /**
     * An opaque identifier unique to the client
     */
    @JsonIgnore
    public Optional<String> clientIdentifier() {
        return clientIdentifier;
    }

    /**
     * The name of the client product
     */
    @JsonIgnore
    public Optional<String> product() {
        return product;
    }

    /**
     * The version of the client application
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    /**
     * The platform of the client
     */
    @JsonIgnore
    public Optional<String> platform() {
        return platform;
    }

    /**
     * The version of the platform
     */
    @JsonIgnore
    public Optional<String> platformVersion() {
        return platformVersion;
    }

    /**
     * A relatively friendly name for the client device
     */
    @JsonIgnore
    public Optional<String> device() {
        return device;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    @JsonIgnore
    public Optional<String> model() {
        return model;
    }

    /**
     * The device vendor
     */
    @JsonIgnore
    public Optional<String> deviceVendor() {
        return deviceVendor;
    }

    /**
     * A friendly name for the client
     */
    @JsonIgnore
    public Optional<String> deviceName() {
        return deviceName;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    @JsonIgnore
    public Optional<String> marketplace() {
        return marketplace;
    }

    /**
     * The content URI for what we're playing.
     */
    @JsonIgnore
    public Optional<String> uri() {
        return uri;
    }

    /**
     * the ID of the playlist we're playing.
     */
    @JsonIgnore
    public Optional<Long> playlistID() {
        return playlistID;
    }

    /**
     * The type of play queue to create
     */
    @JsonIgnore
    public Type type() {
        return type;
    }

    /**
     * The key of the first item to play, defaults to the first in the play queue.
     */
    @JsonIgnore
    public Optional<String> key() {
        return key;
    }

    /**
     * Whether to shuffle the playlist, defaults to 0.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> shuffle() {
        return (Optional<BoolInt>) shuffle;
    }

    /**
     * If the PQ is bigger than the window, fill any empty space with wraparound items, defaults to 0.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> repeat() {
        return (Optional<BoolInt>) repeat;
    }

    /**
     * Whether to create a continuous play queue (e.g. from an episode), defaults to 0.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> continuous() {
        return (Optional<BoolInt>) continuous;
    }

    /**
     * Number of trailers to prepend a movie with not including the pre-roll. If omitted the pre-roll will not be returned in the play queue. When resuming a movie `extrasPrefixCount` should be omitted as a parameter instead of passing 0.
     */
    @JsonIgnore
    public Optional<Long> extrasPrefixCount() {
        return extrasPrefixCount;
    }

    /**
     * Only applies to queues of type photo, whether to retrieve all descendent photos from an album or section, defaults to 1.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> recursive() {
        return (Optional<BoolInt>) recursive;
    }

    /**
     * Only applies to queues of type show or seasons, whether to return a queue that is started on the On Deck episode if one exists. Otherwise begins the play queue on the beginning of the show or season.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> onDeck() {
        return (Optional<BoolInt>) onDeck;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public CreatePlayQueueRequest withAccepts(Accepts accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = Optional.ofNullable(accepts);
        return this;
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public CreatePlayQueueRequest withAccepts(Optional<? extends Accepts> accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = accepts;
        return this;
    }

    /**
     * An opaque identifier unique to the client
     */
    public CreatePlayQueueRequest withClientIdentifier(String clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = Optional.ofNullable(clientIdentifier);
        return this;
    }


    /**
     * An opaque identifier unique to the client
     */
    public CreatePlayQueueRequest withClientIdentifier(Optional<String> clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = clientIdentifier;
        return this;
    }

    /**
     * The name of the client product
     */
    public CreatePlayQueueRequest withProduct(String product) {
        Utils.checkNotNull(product, "product");
        this.product = Optional.ofNullable(product);
        return this;
    }


    /**
     * The name of the client product
     */
    public CreatePlayQueueRequest withProduct(Optional<String> product) {
        Utils.checkNotNull(product, "product");
        this.product = product;
        return this;
    }

    /**
     * The version of the client application
     */
    public CreatePlayQueueRequest withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }


    /**
     * The version of the client application
     */
    public CreatePlayQueueRequest withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * The platform of the client
     */
    public CreatePlayQueueRequest withPlatform(String platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = Optional.ofNullable(platform);
        return this;
    }


    /**
     * The platform of the client
     */
    public CreatePlayQueueRequest withPlatform(Optional<String> platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = platform;
        return this;
    }

    /**
     * The version of the platform
     */
    public CreatePlayQueueRequest withPlatformVersion(String platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = Optional.ofNullable(platformVersion);
        return this;
    }


    /**
     * The version of the platform
     */
    public CreatePlayQueueRequest withPlatformVersion(Optional<String> platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = platformVersion;
        return this;
    }

    /**
     * A relatively friendly name for the client device
     */
    public CreatePlayQueueRequest withDevice(String device) {
        Utils.checkNotNull(device, "device");
        this.device = Optional.ofNullable(device);
        return this;
    }


    /**
     * A relatively friendly name for the client device
     */
    public CreatePlayQueueRequest withDevice(Optional<String> device) {
        Utils.checkNotNull(device, "device");
        this.device = device;
        return this;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    public CreatePlayQueueRequest withModel(String model) {
        Utils.checkNotNull(model, "model");
        this.model = Optional.ofNullable(model);
        return this;
    }


    /**
     * A potentially less friendly identifier for the device model
     */
    public CreatePlayQueueRequest withModel(Optional<String> model) {
        Utils.checkNotNull(model, "model");
        this.model = model;
        return this;
    }

    /**
     * The device vendor
     */
    public CreatePlayQueueRequest withDeviceVendor(String deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = Optional.ofNullable(deviceVendor);
        return this;
    }


    /**
     * The device vendor
     */
    public CreatePlayQueueRequest withDeviceVendor(Optional<String> deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = deviceVendor;
        return this;
    }

    /**
     * A friendly name for the client
     */
    public CreatePlayQueueRequest withDeviceName(String deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = Optional.ofNullable(deviceName);
        return this;
    }


    /**
     * A friendly name for the client
     */
    public CreatePlayQueueRequest withDeviceName(Optional<String> deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = deviceName;
        return this;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    public CreatePlayQueueRequest withMarketplace(String marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = Optional.ofNullable(marketplace);
        return this;
    }


    /**
     * The marketplace on which the client application is distributed
     */
    public CreatePlayQueueRequest withMarketplace(Optional<String> marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = marketplace;
        return this;
    }

    /**
     * The content URI for what we're playing.
     */
    public CreatePlayQueueRequest withUri(String uri) {
        Utils.checkNotNull(uri, "uri");
        this.uri = Optional.ofNullable(uri);
        return this;
    }


    /**
     * The content URI for what we're playing.
     */
    public CreatePlayQueueRequest withUri(Optional<String> uri) {
        Utils.checkNotNull(uri, "uri");
        this.uri = uri;
        return this;
    }

    /**
     * the ID of the playlist we're playing.
     */
    public CreatePlayQueueRequest withPlaylistID(long playlistID) {
        Utils.checkNotNull(playlistID, "playlistID");
        this.playlistID = Optional.ofNullable(playlistID);
        return this;
    }


    /**
     * the ID of the playlist we're playing.
     */
    public CreatePlayQueueRequest withPlaylistID(Optional<Long> playlistID) {
        Utils.checkNotNull(playlistID, "playlistID");
        this.playlistID = playlistID;
        return this;
    }

    /**
     * The type of play queue to create
     */
    public CreatePlayQueueRequest withType(Type type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * The key of the first item to play, defaults to the first in the play queue.
     */
    public CreatePlayQueueRequest withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = Optional.ofNullable(key);
        return this;
    }


    /**
     * The key of the first item to play, defaults to the first in the play queue.
     */
    public CreatePlayQueueRequest withKey(Optional<String> key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    /**
     * Whether to shuffle the playlist, defaults to 0.
     */
    public CreatePlayQueueRequest withShuffle(BoolInt shuffle) {
        Utils.checkNotNull(shuffle, "shuffle");
        this.shuffle = Optional.ofNullable(shuffle);
        return this;
    }


    /**
     * Whether to shuffle the playlist, defaults to 0.
     */
    public CreatePlayQueueRequest withShuffle(Optional<? extends BoolInt> shuffle) {
        Utils.checkNotNull(shuffle, "shuffle");
        this.shuffle = shuffle;
        return this;
    }

    /**
     * If the PQ is bigger than the window, fill any empty space with wraparound items, defaults to 0.
     */
    public CreatePlayQueueRequest withRepeat(BoolInt repeat) {
        Utils.checkNotNull(repeat, "repeat");
        this.repeat = Optional.ofNullable(repeat);
        return this;
    }


    /**
     * If the PQ is bigger than the window, fill any empty space with wraparound items, defaults to 0.
     */
    public CreatePlayQueueRequest withRepeat(Optional<? extends BoolInt> repeat) {
        Utils.checkNotNull(repeat, "repeat");
        this.repeat = repeat;
        return this;
    }

    /**
     * Whether to create a continuous play queue (e.g. from an episode), defaults to 0.
     */
    public CreatePlayQueueRequest withContinuous(BoolInt continuous) {
        Utils.checkNotNull(continuous, "continuous");
        this.continuous = Optional.ofNullable(continuous);
        return this;
    }


    /**
     * Whether to create a continuous play queue (e.g. from an episode), defaults to 0.
     */
    public CreatePlayQueueRequest withContinuous(Optional<? extends BoolInt> continuous) {
        Utils.checkNotNull(continuous, "continuous");
        this.continuous = continuous;
        return this;
    }

    /**
     * Number of trailers to prepend a movie with not including the pre-roll. If omitted the pre-roll will not be returned in the play queue. When resuming a movie `extrasPrefixCount` should be omitted as a parameter instead of passing 0.
     */
    public CreatePlayQueueRequest withExtrasPrefixCount(long extrasPrefixCount) {
        Utils.checkNotNull(extrasPrefixCount, "extrasPrefixCount");
        this.extrasPrefixCount = Optional.ofNullable(extrasPrefixCount);
        return this;
    }


    /**
     * Number of trailers to prepend a movie with not including the pre-roll. If omitted the pre-roll will not be returned in the play queue. When resuming a movie `extrasPrefixCount` should be omitted as a parameter instead of passing 0.
     */
    public CreatePlayQueueRequest withExtrasPrefixCount(Optional<Long> extrasPrefixCount) {
        Utils.checkNotNull(extrasPrefixCount, "extrasPrefixCount");
        this.extrasPrefixCount = extrasPrefixCount;
        return this;
    }

    /**
     * Only applies to queues of type photo, whether to retrieve all descendent photos from an album or section, defaults to 1.
     */
    public CreatePlayQueueRequest withRecursive(BoolInt recursive) {
        Utils.checkNotNull(recursive, "recursive");
        this.recursive = Optional.ofNullable(recursive);
        return this;
    }


    /**
     * Only applies to queues of type photo, whether to retrieve all descendent photos from an album or section, defaults to 1.
     */
    public CreatePlayQueueRequest withRecursive(Optional<? extends BoolInt> recursive) {
        Utils.checkNotNull(recursive, "recursive");
        this.recursive = recursive;
        return this;
    }

    /**
     * Only applies to queues of type show or seasons, whether to return a queue that is started on the On Deck episode if one exists. Otherwise begins the play queue on the beginning of the show or season.
     */
    public CreatePlayQueueRequest withOnDeck(BoolInt onDeck) {
        Utils.checkNotNull(onDeck, "onDeck");
        this.onDeck = Optional.ofNullable(onDeck);
        return this;
    }


    /**
     * Only applies to queues of type show or seasons, whether to return a queue that is started on the On Deck episode if one exists. Otherwise begins the play queue on the beginning of the show or season.
     */
    public CreatePlayQueueRequest withOnDeck(Optional<? extends BoolInt> onDeck) {
        Utils.checkNotNull(onDeck, "onDeck");
        this.onDeck = onDeck;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreatePlayQueueRequest other = (CreatePlayQueueRequest) o;
        return 
            Utils.enhancedDeepEquals(this.accepts, other.accepts) &&
            Utils.enhancedDeepEquals(this.clientIdentifier, other.clientIdentifier) &&
            Utils.enhancedDeepEquals(this.product, other.product) &&
            Utils.enhancedDeepEquals(this.version, other.version) &&
            Utils.enhancedDeepEquals(this.platform, other.platform) &&
            Utils.enhancedDeepEquals(this.platformVersion, other.platformVersion) &&
            Utils.enhancedDeepEquals(this.device, other.device) &&
            Utils.enhancedDeepEquals(this.model, other.model) &&
            Utils.enhancedDeepEquals(this.deviceVendor, other.deviceVendor) &&
            Utils.enhancedDeepEquals(this.deviceName, other.deviceName) &&
            Utils.enhancedDeepEquals(this.marketplace, other.marketplace) &&
            Utils.enhancedDeepEquals(this.uri, other.uri) &&
            Utils.enhancedDeepEquals(this.playlistID, other.playlistID) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.shuffle, other.shuffle) &&
            Utils.enhancedDeepEquals(this.repeat, other.repeat) &&
            Utils.enhancedDeepEquals(this.continuous, other.continuous) &&
            Utils.enhancedDeepEquals(this.extrasPrefixCount, other.extrasPrefixCount) &&
            Utils.enhancedDeepEquals(this.recursive, other.recursive) &&
            Utils.enhancedDeepEquals(this.onDeck, other.onDeck);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            accepts, clientIdentifier, product,
            version, platform, platformVersion,
            device, model, deviceVendor,
            deviceName, marketplace, uri,
            playlistID, type, key,
            shuffle, repeat, continuous,
            extrasPrefixCount, recursive, onDeck);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreatePlayQueueRequest.class,
                "accepts", accepts,
                "clientIdentifier", clientIdentifier,
                "product", product,
                "version", version,
                "platform", platform,
                "platformVersion", platformVersion,
                "device", device,
                "model", model,
                "deviceVendor", deviceVendor,
                "deviceName", deviceName,
                "marketplace", marketplace,
                "uri", uri,
                "playlistID", playlistID,
                "type", type,
                "key", key,
                "shuffle", shuffle,
                "repeat", repeat,
                "continuous", continuous,
                "extrasPrefixCount", extrasPrefixCount,
                "recursive", recursive,
                "onDeck", onDeck);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends Accepts> accepts;

        private Optional<String> clientIdentifier = Optional.empty();

        private Optional<String> product = Optional.empty();

        private Optional<String> version = Optional.empty();

        private Optional<String> platform = Optional.empty();

        private Optional<String> platformVersion = Optional.empty();

        private Optional<String> device = Optional.empty();

        private Optional<String> model = Optional.empty();

        private Optional<String> deviceVendor = Optional.empty();

        private Optional<String> deviceName = Optional.empty();

        private Optional<String> marketplace = Optional.empty();

        private Optional<String> uri = Optional.empty();

        private Optional<Long> playlistID = Optional.empty();

        private Type type;

        private Optional<String> key = Optional.empty();

        private Optional<? extends BoolInt> shuffle = Optional.empty();

        private Optional<? extends BoolInt> repeat = Optional.empty();

        private Optional<? extends BoolInt> continuous = Optional.empty();

        private Optional<Long> extrasPrefixCount = Optional.empty();

        private Optional<? extends BoolInt> recursive = Optional.empty();

        private Optional<? extends BoolInt> onDeck = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Accepts accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = Optional.ofNullable(accepts);
            return this;
        }

        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Optional<? extends Accepts> accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = accepts;
            return this;
        }


        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(String clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = Optional.ofNullable(clientIdentifier);
            return this;
        }

        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(Optional<String> clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = clientIdentifier;
            return this;
        }


        /**
         * The name of the client product
         */
        public Builder product(String product) {
            Utils.checkNotNull(product, "product");
            this.product = Optional.ofNullable(product);
            return this;
        }

        /**
         * The name of the client product
         */
        public Builder product(Optional<String> product) {
            Utils.checkNotNull(product, "product");
            this.product = product;
            return this;
        }


        /**
         * The version of the client application
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The version of the client application
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }


        /**
         * The platform of the client
         */
        public Builder platform(String platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = Optional.ofNullable(platform);
            return this;
        }

        /**
         * The platform of the client
         */
        public Builder platform(Optional<String> platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = platform;
            return this;
        }


        /**
         * The version of the platform
         */
        public Builder platformVersion(String platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = Optional.ofNullable(platformVersion);
            return this;
        }

        /**
         * The version of the platform
         */
        public Builder platformVersion(Optional<String> platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = platformVersion;
            return this;
        }


        /**
         * A relatively friendly name for the client device
         */
        public Builder device(String device) {
            Utils.checkNotNull(device, "device");
            this.device = Optional.ofNullable(device);
            return this;
        }

        /**
         * A relatively friendly name for the client device
         */
        public Builder device(Optional<String> device) {
            Utils.checkNotNull(device, "device");
            this.device = device;
            return this;
        }


        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(String model) {
            Utils.checkNotNull(model, "model");
            this.model = Optional.ofNullable(model);
            return this;
        }

        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(Optional<String> model) {
            Utils.checkNotNull(model, "model");
            this.model = model;
            return this;
        }


        /**
         * The device vendor
         */
        public Builder deviceVendor(String deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = Optional.ofNullable(deviceVendor);
            return this;
        }

        /**
         * The device vendor
         */
        public Builder deviceVendor(Optional<String> deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = deviceVendor;
            return this;
        }


        /**
         * A friendly name for the client
         */
        public Builder deviceName(String deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = Optional.ofNullable(deviceName);
            return this;
        }

        /**
         * A friendly name for the client
         */
        public Builder deviceName(Optional<String> deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = deviceName;
            return this;
        }


        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(String marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = Optional.ofNullable(marketplace);
            return this;
        }

        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(Optional<String> marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = marketplace;
            return this;
        }


        /**
         * The content URI for what we're playing.
         */
        public Builder uri(String uri) {
            Utils.checkNotNull(uri, "uri");
            this.uri = Optional.ofNullable(uri);
            return this;
        }

        /**
         * The content URI for what we're playing.
         */
        public Builder uri(Optional<String> uri) {
            Utils.checkNotNull(uri, "uri");
            this.uri = uri;
            return this;
        }


        /**
         * the ID of the playlist we're playing.
         */
        public Builder playlistID(long playlistID) {
            Utils.checkNotNull(playlistID, "playlistID");
            this.playlistID = Optional.ofNullable(playlistID);
            return this;
        }

        /**
         * the ID of the playlist we're playing.
         */
        public Builder playlistID(Optional<Long> playlistID) {
            Utils.checkNotNull(playlistID, "playlistID");
            this.playlistID = playlistID;
            return this;
        }


        /**
         * The type of play queue to create
         */
        public Builder type(Type type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }


        /**
         * The key of the first item to play, defaults to the first in the play queue.
         */
        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = Optional.ofNullable(key);
            return this;
        }

        /**
         * The key of the first item to play, defaults to the first in the play queue.
         */
        public Builder key(Optional<String> key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        /**
         * Whether to shuffle the playlist, defaults to 0.
         */
        public Builder shuffle(BoolInt shuffle) {
            Utils.checkNotNull(shuffle, "shuffle");
            this.shuffle = Optional.ofNullable(shuffle);
            return this;
        }

        /**
         * Whether to shuffle the playlist, defaults to 0.
         */
        public Builder shuffle(Optional<? extends BoolInt> shuffle) {
            Utils.checkNotNull(shuffle, "shuffle");
            this.shuffle = shuffle;
            return this;
        }


        /**
         * If the PQ is bigger than the window, fill any empty space with wraparound items, defaults to 0.
         */
        public Builder repeat(BoolInt repeat) {
            Utils.checkNotNull(repeat, "repeat");
            this.repeat = Optional.ofNullable(repeat);
            return this;
        }

        /**
         * If the PQ is bigger than the window, fill any empty space with wraparound items, defaults to 0.
         */
        public Builder repeat(Optional<? extends BoolInt> repeat) {
            Utils.checkNotNull(repeat, "repeat");
            this.repeat = repeat;
            return this;
        }


        /**
         * Whether to create a continuous play queue (e.g. from an episode), defaults to 0.
         */
        public Builder continuous(BoolInt continuous) {
            Utils.checkNotNull(continuous, "continuous");
            this.continuous = Optional.ofNullable(continuous);
            return this;
        }

        /**
         * Whether to create a continuous play queue (e.g. from an episode), defaults to 0.
         */
        public Builder continuous(Optional<? extends BoolInt> continuous) {
            Utils.checkNotNull(continuous, "continuous");
            this.continuous = continuous;
            return this;
        }


        /**
         * Number of trailers to prepend a movie with not including the pre-roll. If omitted the pre-roll will not be returned in the play queue. When resuming a movie `extrasPrefixCount` should be omitted as a parameter instead of passing 0.
         */
        public Builder extrasPrefixCount(long extrasPrefixCount) {
            Utils.checkNotNull(extrasPrefixCount, "extrasPrefixCount");
            this.extrasPrefixCount = Optional.ofNullable(extrasPrefixCount);
            return this;
        }

        /**
         * Number of trailers to prepend a movie with not including the pre-roll. If omitted the pre-roll will not be returned in the play queue. When resuming a movie `extrasPrefixCount` should be omitted as a parameter instead of passing 0.
         */
        public Builder extrasPrefixCount(Optional<Long> extrasPrefixCount) {
            Utils.checkNotNull(extrasPrefixCount, "extrasPrefixCount");
            this.extrasPrefixCount = extrasPrefixCount;
            return this;
        }


        /**
         * Only applies to queues of type photo, whether to retrieve all descendent photos from an album or section, defaults to 1.
         */
        public Builder recursive(BoolInt recursive) {
            Utils.checkNotNull(recursive, "recursive");
            this.recursive = Optional.ofNullable(recursive);
            return this;
        }

        /**
         * Only applies to queues of type photo, whether to retrieve all descendent photos from an album or section, defaults to 1.
         */
        public Builder recursive(Optional<? extends BoolInt> recursive) {
            Utils.checkNotNull(recursive, "recursive");
            this.recursive = recursive;
            return this;
        }


        /**
         * Only applies to queues of type show or seasons, whether to return a queue that is started on the On Deck episode if one exists. Otherwise begins the play queue on the beginning of the show or season.
         */
        public Builder onDeck(BoolInt onDeck) {
            Utils.checkNotNull(onDeck, "onDeck");
            this.onDeck = Optional.ofNullable(onDeck);
            return this;
        }

        /**
         * Only applies to queues of type show or seasons, whether to return a queue that is started on the On Deck episode if one exists. Otherwise begins the play queue on the beginning of the show or season.
         */
        public Builder onDeck(Optional<? extends BoolInt> onDeck) {
            Utils.checkNotNull(onDeck, "onDeck");
            this.onDeck = onDeck;
            return this;
        }

        public CreatePlayQueueRequest build() {
            if (accepts == null) {
                accepts = _SINGLETON_VALUE_Accepts.value();
            }

            return new CreatePlayQueueRequest(
                accepts, clientIdentifier, product,
                version, platform, platformVersion,
                device, model, deviceVendor,
                deviceName, marketplace, uri,
                playlistID, type, key,
                shuffle, repeat, continuous,
                extrasPrefixCount, recursive, onDeck);
        }


        private static final LazySingletonValue<Optional<? extends Accepts>> _SINGLETON_VALUE_Accepts =
                new LazySingletonValue<>(
                        "accepts",
                        "\"application/xml\"",
                        new TypeReference<Optional<? extends Accepts>>() {});
    }
}
