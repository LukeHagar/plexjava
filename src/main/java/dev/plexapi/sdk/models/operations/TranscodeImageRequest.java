/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.models.shared.Accepts;
import dev.plexapi.sdk.models.shared.BoolInt;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.SpeakeasyMetadata;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;


public class TranscodeImageRequest {
    /**
     * Indicates the client accepts the indicated media types
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=accepts")
    private Optional<? extends Accepts> accepts;

    /**
     * An opaque identifier unique to the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Client-Identifier")
    private Optional<String> clientIdentifier;

    /**
     * The name of the client product
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Product")
    private Optional<String> product;

    /**
     * The version of the client application
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Version")
    private Optional<String> version;

    /**
     * The platform of the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform")
    private Optional<String> platform;

    /**
     * The version of the platform
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform-Version")
    private Optional<String> platformVersion;

    /**
     * A relatively friendly name for the client device
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device")
    private Optional<String> device;

    /**
     * A potentially less friendly identifier for the device model
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Model")
    private Optional<String> model;

    /**
     * The device vendor
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Vendor")
    private Optional<String> deviceVendor;

    /**
     * A friendly name for the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Name")
    private Optional<String> deviceName;

    /**
     * The marketplace on which the client application is distributed
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Marketplace")
    private Optional<String> marketplace;

    /**
     * The source URL for the image to transcode.  Note, if this URL requires a token such as `X-Plex-Token`, it should be given as a query parameter to this url.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=url")
    private Optional<String> url;

    /**
     * The output format for the image; defaults to jpg
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=format")
    private Optional<? extends Format> format;

    /**
     * The desired width of the output image
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=width")
    private Optional<Long> width;

    /**
     * The desired height of the output image
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=height")
    private Optional<Long> height;

    /**
     * The desired quality of the output.  -1 means the highest quality.  Defaults to -1
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=quality")
    private Optional<Long> quality;

    /**
     * The background color to apply before painting the image.  Only really applicable if image has transparency.  Defaults to none
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=background")
    private Optional<String> background;

    /**
     * Indicates if image should be upscaled to the desired width/height.  Defaults to false
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=upscale")
    private Optional<? extends BoolInt> upscale;

    /**
     * Indicates if image should be scaled to fit the smaller dimension.  By default (false) the image is scaled to fit within the width/height specified but if this parameter is true, it will allow overflowing one dimension to fit the other.  Essentially it is making the width/height minimum sizes of the image or sizing the image to fill the entire width/height even if it overflows one dimension.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=minSize")
    private Optional<? extends BoolInt> minSize;

    /**
     * Obey the rotation values specified in EXIF data.  Defaults to true.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=rotate")
    private Optional<? extends BoolInt> rotate;

    /**
     * Apply a blur to the image, Defaults to 0 (none)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=blur")
    private Optional<Long> blur;

    /**
     * Scale the image saturation by the specified percentage.  Defaults to 100
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=saturation")
    private Optional<Long> saturation;

    /**
     * Render the image at the specified opacity percentage.  Defaults to 100
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=opacity")
    private Optional<Long> opacity;

    /**
     * Use the specified chroma subsambling.
     *   - 0: 411
     *   - 1: 420
     *   - 2: 422
     *   - 3: 444
     * Defaults to 3 (444)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=chromaSubsampling")
    private Optional<? extends ChromaSubsampling> chromaSubsampling;

    /**
     * The color to blend with the image.  Defaults to none
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=blendColor")
    private Optional<String> blendColor;

    @JsonCreator
    public TranscodeImageRequest(
            Optional<? extends Accepts> accepts,
            Optional<String> clientIdentifier,
            Optional<String> product,
            Optional<String> version,
            Optional<String> platform,
            Optional<String> platformVersion,
            Optional<String> device,
            Optional<String> model,
            Optional<String> deviceVendor,
            Optional<String> deviceName,
            Optional<String> marketplace,
            Optional<String> url,
            Optional<? extends Format> format,
            Optional<Long> width,
            Optional<Long> height,
            Optional<Long> quality,
            Optional<String> background,
            Optional<? extends BoolInt> upscale,
            Optional<? extends BoolInt> minSize,
            Optional<? extends BoolInt> rotate,
            Optional<Long> blur,
            Optional<Long> saturation,
            Optional<Long> opacity,
            Optional<? extends ChromaSubsampling> chromaSubsampling,
            Optional<String> blendColor) {
        Utils.checkNotNull(accepts, "accepts");
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        Utils.checkNotNull(product, "product");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(platform, "platform");
        Utils.checkNotNull(platformVersion, "platformVersion");
        Utils.checkNotNull(device, "device");
        Utils.checkNotNull(model, "model");
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        Utils.checkNotNull(deviceName, "deviceName");
        Utils.checkNotNull(marketplace, "marketplace");
        Utils.checkNotNull(url, "url");
        Utils.checkNotNull(format, "format");
        Utils.checkNotNull(width, "width");
        Utils.checkNotNull(height, "height");
        Utils.checkNotNull(quality, "quality");
        Utils.checkNotNull(background, "background");
        Utils.checkNotNull(upscale, "upscale");
        Utils.checkNotNull(minSize, "minSize");
        Utils.checkNotNull(rotate, "rotate");
        Utils.checkNotNull(blur, "blur");
        Utils.checkNotNull(saturation, "saturation");
        Utils.checkNotNull(opacity, "opacity");
        Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
        Utils.checkNotNull(blendColor, "blendColor");
        this.accepts = accepts;
        this.clientIdentifier = clientIdentifier;
        this.product = product;
        this.version = version;
        this.platform = platform;
        this.platformVersion = platformVersion;
        this.device = device;
        this.model = model;
        this.deviceVendor = deviceVendor;
        this.deviceName = deviceName;
        this.marketplace = marketplace;
        this.url = url;
        this.format = format;
        this.width = width;
        this.height = height;
        this.quality = quality;
        this.background = background;
        this.upscale = upscale;
        this.minSize = minSize;
        this.rotate = rotate;
        this.blur = blur;
        this.saturation = saturation;
        this.opacity = opacity;
        this.chromaSubsampling = chromaSubsampling;
        this.blendColor = blendColor;
    }
    
    public TranscodeImageRequest() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty());
    }

    /**
     * Indicates the client accepts the indicated media types
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Accepts> accepts() {
        return (Optional<Accepts>) accepts;
    }

    /**
     * An opaque identifier unique to the client
     */
    @JsonIgnore
    public Optional<String> clientIdentifier() {
        return clientIdentifier;
    }

    /**
     * The name of the client product
     */
    @JsonIgnore
    public Optional<String> product() {
        return product;
    }

    /**
     * The version of the client application
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    /**
     * The platform of the client
     */
    @JsonIgnore
    public Optional<String> platform() {
        return platform;
    }

    /**
     * The version of the platform
     */
    @JsonIgnore
    public Optional<String> platformVersion() {
        return platformVersion;
    }

    /**
     * A relatively friendly name for the client device
     */
    @JsonIgnore
    public Optional<String> device() {
        return device;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    @JsonIgnore
    public Optional<String> model() {
        return model;
    }

    /**
     * The device vendor
     */
    @JsonIgnore
    public Optional<String> deviceVendor() {
        return deviceVendor;
    }

    /**
     * A friendly name for the client
     */
    @JsonIgnore
    public Optional<String> deviceName() {
        return deviceName;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    @JsonIgnore
    public Optional<String> marketplace() {
        return marketplace;
    }

    /**
     * The source URL for the image to transcode.  Note, if this URL requires a token such as `X-Plex-Token`, it should be given as a query parameter to this url.
     */
    @JsonIgnore
    public Optional<String> url() {
        return url;
    }

    /**
     * The output format for the image; defaults to jpg
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Format> format() {
        return (Optional<Format>) format;
    }

    /**
     * The desired width of the output image
     */
    @JsonIgnore
    public Optional<Long> width() {
        return width;
    }

    /**
     * The desired height of the output image
     */
    @JsonIgnore
    public Optional<Long> height() {
        return height;
    }

    /**
     * The desired quality of the output.  -1 means the highest quality.  Defaults to -1
     */
    @JsonIgnore
    public Optional<Long> quality() {
        return quality;
    }

    /**
     * The background color to apply before painting the image.  Only really applicable if image has transparency.  Defaults to none
     */
    @JsonIgnore
    public Optional<String> background() {
        return background;
    }

    /**
     * Indicates if image should be upscaled to the desired width/height.  Defaults to false
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> upscale() {
        return (Optional<BoolInt>) upscale;
    }

    /**
     * Indicates if image should be scaled to fit the smaller dimension.  By default (false) the image is scaled to fit within the width/height specified but if this parameter is true, it will allow overflowing one dimension to fit the other.  Essentially it is making the width/height minimum sizes of the image or sizing the image to fill the entire width/height even if it overflows one dimension.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> minSize() {
        return (Optional<BoolInt>) minSize;
    }

    /**
     * Obey the rotation values specified in EXIF data.  Defaults to true.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> rotate() {
        return (Optional<BoolInt>) rotate;
    }

    /**
     * Apply a blur to the image, Defaults to 0 (none)
     */
    @JsonIgnore
    public Optional<Long> blur() {
        return blur;
    }

    /**
     * Scale the image saturation by the specified percentage.  Defaults to 100
     */
    @JsonIgnore
    public Optional<Long> saturation() {
        return saturation;
    }

    /**
     * Render the image at the specified opacity percentage.  Defaults to 100
     */
    @JsonIgnore
    public Optional<Long> opacity() {
        return opacity;
    }

    /**
     * Use the specified chroma subsambling.
     *   - 0: 411
     *   - 1: 420
     *   - 2: 422
     *   - 3: 444
     * Defaults to 3 (444)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ChromaSubsampling> chromaSubsampling() {
        return (Optional<ChromaSubsampling>) chromaSubsampling;
    }

    /**
     * The color to blend with the image.  Defaults to none
     */
    @JsonIgnore
    public Optional<String> blendColor() {
        return blendColor;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public TranscodeImageRequest withAccepts(Accepts accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = Optional.ofNullable(accepts);
        return this;
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public TranscodeImageRequest withAccepts(Optional<? extends Accepts> accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = accepts;
        return this;
    }

    /**
     * An opaque identifier unique to the client
     */
    public TranscodeImageRequest withClientIdentifier(String clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = Optional.ofNullable(clientIdentifier);
        return this;
    }


    /**
     * An opaque identifier unique to the client
     */
    public TranscodeImageRequest withClientIdentifier(Optional<String> clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = clientIdentifier;
        return this;
    }

    /**
     * The name of the client product
     */
    public TranscodeImageRequest withProduct(String product) {
        Utils.checkNotNull(product, "product");
        this.product = Optional.ofNullable(product);
        return this;
    }


    /**
     * The name of the client product
     */
    public TranscodeImageRequest withProduct(Optional<String> product) {
        Utils.checkNotNull(product, "product");
        this.product = product;
        return this;
    }

    /**
     * The version of the client application
     */
    public TranscodeImageRequest withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }


    /**
     * The version of the client application
     */
    public TranscodeImageRequest withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * The platform of the client
     */
    public TranscodeImageRequest withPlatform(String platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = Optional.ofNullable(platform);
        return this;
    }


    /**
     * The platform of the client
     */
    public TranscodeImageRequest withPlatform(Optional<String> platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = platform;
        return this;
    }

    /**
     * The version of the platform
     */
    public TranscodeImageRequest withPlatformVersion(String platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = Optional.ofNullable(platformVersion);
        return this;
    }


    /**
     * The version of the platform
     */
    public TranscodeImageRequest withPlatformVersion(Optional<String> platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = platformVersion;
        return this;
    }

    /**
     * A relatively friendly name for the client device
     */
    public TranscodeImageRequest withDevice(String device) {
        Utils.checkNotNull(device, "device");
        this.device = Optional.ofNullable(device);
        return this;
    }


    /**
     * A relatively friendly name for the client device
     */
    public TranscodeImageRequest withDevice(Optional<String> device) {
        Utils.checkNotNull(device, "device");
        this.device = device;
        return this;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    public TranscodeImageRequest withModel(String model) {
        Utils.checkNotNull(model, "model");
        this.model = Optional.ofNullable(model);
        return this;
    }


    /**
     * A potentially less friendly identifier for the device model
     */
    public TranscodeImageRequest withModel(Optional<String> model) {
        Utils.checkNotNull(model, "model");
        this.model = model;
        return this;
    }

    /**
     * The device vendor
     */
    public TranscodeImageRequest withDeviceVendor(String deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = Optional.ofNullable(deviceVendor);
        return this;
    }


    /**
     * The device vendor
     */
    public TranscodeImageRequest withDeviceVendor(Optional<String> deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = deviceVendor;
        return this;
    }

    /**
     * A friendly name for the client
     */
    public TranscodeImageRequest withDeviceName(String deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = Optional.ofNullable(deviceName);
        return this;
    }


    /**
     * A friendly name for the client
     */
    public TranscodeImageRequest withDeviceName(Optional<String> deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = deviceName;
        return this;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    public TranscodeImageRequest withMarketplace(String marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = Optional.ofNullable(marketplace);
        return this;
    }


    /**
     * The marketplace on which the client application is distributed
     */
    public TranscodeImageRequest withMarketplace(Optional<String> marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = marketplace;
        return this;
    }

    /**
     * The source URL for the image to transcode.  Note, if this URL requires a token such as `X-Plex-Token`, it should be given as a query parameter to this url.
     */
    public TranscodeImageRequest withUrl(String url) {
        Utils.checkNotNull(url, "url");
        this.url = Optional.ofNullable(url);
        return this;
    }


    /**
     * The source URL for the image to transcode.  Note, if this URL requires a token such as `X-Plex-Token`, it should be given as a query parameter to this url.
     */
    public TranscodeImageRequest withUrl(Optional<String> url) {
        Utils.checkNotNull(url, "url");
        this.url = url;
        return this;
    }

    /**
     * The output format for the image; defaults to jpg
     */
    public TranscodeImageRequest withFormat(Format format) {
        Utils.checkNotNull(format, "format");
        this.format = Optional.ofNullable(format);
        return this;
    }


    /**
     * The output format for the image; defaults to jpg
     */
    public TranscodeImageRequest withFormat(Optional<? extends Format> format) {
        Utils.checkNotNull(format, "format");
        this.format = format;
        return this;
    }

    /**
     * The desired width of the output image
     */
    public TranscodeImageRequest withWidth(long width) {
        Utils.checkNotNull(width, "width");
        this.width = Optional.ofNullable(width);
        return this;
    }


    /**
     * The desired width of the output image
     */
    public TranscodeImageRequest withWidth(Optional<Long> width) {
        Utils.checkNotNull(width, "width");
        this.width = width;
        return this;
    }

    /**
     * The desired height of the output image
     */
    public TranscodeImageRequest withHeight(long height) {
        Utils.checkNotNull(height, "height");
        this.height = Optional.ofNullable(height);
        return this;
    }


    /**
     * The desired height of the output image
     */
    public TranscodeImageRequest withHeight(Optional<Long> height) {
        Utils.checkNotNull(height, "height");
        this.height = height;
        return this;
    }

    /**
     * The desired quality of the output.  -1 means the highest quality.  Defaults to -1
     */
    public TranscodeImageRequest withQuality(long quality) {
        Utils.checkNotNull(quality, "quality");
        this.quality = Optional.ofNullable(quality);
        return this;
    }


    /**
     * The desired quality of the output.  -1 means the highest quality.  Defaults to -1
     */
    public TranscodeImageRequest withQuality(Optional<Long> quality) {
        Utils.checkNotNull(quality, "quality");
        this.quality = quality;
        return this;
    }

    /**
     * The background color to apply before painting the image.  Only really applicable if image has transparency.  Defaults to none
     */
    public TranscodeImageRequest withBackground(String background) {
        Utils.checkNotNull(background, "background");
        this.background = Optional.ofNullable(background);
        return this;
    }


    /**
     * The background color to apply before painting the image.  Only really applicable if image has transparency.  Defaults to none
     */
    public TranscodeImageRequest withBackground(Optional<String> background) {
        Utils.checkNotNull(background, "background");
        this.background = background;
        return this;
    }

    /**
     * Indicates if image should be upscaled to the desired width/height.  Defaults to false
     */
    public TranscodeImageRequest withUpscale(BoolInt upscale) {
        Utils.checkNotNull(upscale, "upscale");
        this.upscale = Optional.ofNullable(upscale);
        return this;
    }


    /**
     * Indicates if image should be upscaled to the desired width/height.  Defaults to false
     */
    public TranscodeImageRequest withUpscale(Optional<? extends BoolInt> upscale) {
        Utils.checkNotNull(upscale, "upscale");
        this.upscale = upscale;
        return this;
    }

    /**
     * Indicates if image should be scaled to fit the smaller dimension.  By default (false) the image is scaled to fit within the width/height specified but if this parameter is true, it will allow overflowing one dimension to fit the other.  Essentially it is making the width/height minimum sizes of the image or sizing the image to fill the entire width/height even if it overflows one dimension.
     */
    public TranscodeImageRequest withMinSize(BoolInt minSize) {
        Utils.checkNotNull(minSize, "minSize");
        this.minSize = Optional.ofNullable(minSize);
        return this;
    }


    /**
     * Indicates if image should be scaled to fit the smaller dimension.  By default (false) the image is scaled to fit within the width/height specified but if this parameter is true, it will allow overflowing one dimension to fit the other.  Essentially it is making the width/height minimum sizes of the image or sizing the image to fill the entire width/height even if it overflows one dimension.
     */
    public TranscodeImageRequest withMinSize(Optional<? extends BoolInt> minSize) {
        Utils.checkNotNull(minSize, "minSize");
        this.minSize = minSize;
        return this;
    }

    /**
     * Obey the rotation values specified in EXIF data.  Defaults to true.
     */
    public TranscodeImageRequest withRotate(BoolInt rotate) {
        Utils.checkNotNull(rotate, "rotate");
        this.rotate = Optional.ofNullable(rotate);
        return this;
    }


    /**
     * Obey the rotation values specified in EXIF data.  Defaults to true.
     */
    public TranscodeImageRequest withRotate(Optional<? extends BoolInt> rotate) {
        Utils.checkNotNull(rotate, "rotate");
        this.rotate = rotate;
        return this;
    }

    /**
     * Apply a blur to the image, Defaults to 0 (none)
     */
    public TranscodeImageRequest withBlur(long blur) {
        Utils.checkNotNull(blur, "blur");
        this.blur = Optional.ofNullable(blur);
        return this;
    }


    /**
     * Apply a blur to the image, Defaults to 0 (none)
     */
    public TranscodeImageRequest withBlur(Optional<Long> blur) {
        Utils.checkNotNull(blur, "blur");
        this.blur = blur;
        return this;
    }

    /**
     * Scale the image saturation by the specified percentage.  Defaults to 100
     */
    public TranscodeImageRequest withSaturation(long saturation) {
        Utils.checkNotNull(saturation, "saturation");
        this.saturation = Optional.ofNullable(saturation);
        return this;
    }


    /**
     * Scale the image saturation by the specified percentage.  Defaults to 100
     */
    public TranscodeImageRequest withSaturation(Optional<Long> saturation) {
        Utils.checkNotNull(saturation, "saturation");
        this.saturation = saturation;
        return this;
    }

    /**
     * Render the image at the specified opacity percentage.  Defaults to 100
     */
    public TranscodeImageRequest withOpacity(long opacity) {
        Utils.checkNotNull(opacity, "opacity");
        this.opacity = Optional.ofNullable(opacity);
        return this;
    }


    /**
     * Render the image at the specified opacity percentage.  Defaults to 100
     */
    public TranscodeImageRequest withOpacity(Optional<Long> opacity) {
        Utils.checkNotNull(opacity, "opacity");
        this.opacity = opacity;
        return this;
    }

    /**
     * Use the specified chroma subsambling.
     *   - 0: 411
     *   - 1: 420
     *   - 2: 422
     *   - 3: 444
     * Defaults to 3 (444)
     */
    public TranscodeImageRequest withChromaSubsampling(ChromaSubsampling chromaSubsampling) {
        Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
        this.chromaSubsampling = Optional.ofNullable(chromaSubsampling);
        return this;
    }


    /**
     * Use the specified chroma subsambling.
     *   - 0: 411
     *   - 1: 420
     *   - 2: 422
     *   - 3: 444
     * Defaults to 3 (444)
     */
    public TranscodeImageRequest withChromaSubsampling(Optional<? extends ChromaSubsampling> chromaSubsampling) {
        Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
        this.chromaSubsampling = chromaSubsampling;
        return this;
    }

    /**
     * The color to blend with the image.  Defaults to none
     */
    public TranscodeImageRequest withBlendColor(String blendColor) {
        Utils.checkNotNull(blendColor, "blendColor");
        this.blendColor = Optional.ofNullable(blendColor);
        return this;
    }


    /**
     * The color to blend with the image.  Defaults to none
     */
    public TranscodeImageRequest withBlendColor(Optional<String> blendColor) {
        Utils.checkNotNull(blendColor, "blendColor");
        this.blendColor = blendColor;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        TranscodeImageRequest other = (TranscodeImageRequest) o;
        return 
            Utils.enhancedDeepEquals(this.accepts, other.accepts) &&
            Utils.enhancedDeepEquals(this.clientIdentifier, other.clientIdentifier) &&
            Utils.enhancedDeepEquals(this.product, other.product) &&
            Utils.enhancedDeepEquals(this.version, other.version) &&
            Utils.enhancedDeepEquals(this.platform, other.platform) &&
            Utils.enhancedDeepEquals(this.platformVersion, other.platformVersion) &&
            Utils.enhancedDeepEquals(this.device, other.device) &&
            Utils.enhancedDeepEquals(this.model, other.model) &&
            Utils.enhancedDeepEquals(this.deviceVendor, other.deviceVendor) &&
            Utils.enhancedDeepEquals(this.deviceName, other.deviceName) &&
            Utils.enhancedDeepEquals(this.marketplace, other.marketplace) &&
            Utils.enhancedDeepEquals(this.url, other.url) &&
            Utils.enhancedDeepEquals(this.format, other.format) &&
            Utils.enhancedDeepEquals(this.width, other.width) &&
            Utils.enhancedDeepEquals(this.height, other.height) &&
            Utils.enhancedDeepEquals(this.quality, other.quality) &&
            Utils.enhancedDeepEquals(this.background, other.background) &&
            Utils.enhancedDeepEquals(this.upscale, other.upscale) &&
            Utils.enhancedDeepEquals(this.minSize, other.minSize) &&
            Utils.enhancedDeepEquals(this.rotate, other.rotate) &&
            Utils.enhancedDeepEquals(this.blur, other.blur) &&
            Utils.enhancedDeepEquals(this.saturation, other.saturation) &&
            Utils.enhancedDeepEquals(this.opacity, other.opacity) &&
            Utils.enhancedDeepEquals(this.chromaSubsampling, other.chromaSubsampling) &&
            Utils.enhancedDeepEquals(this.blendColor, other.blendColor);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            accepts, clientIdentifier, product,
            version, platform, platformVersion,
            device, model, deviceVendor,
            deviceName, marketplace, url,
            format, width, height,
            quality, background, upscale,
            minSize, rotate, blur,
            saturation, opacity, chromaSubsampling,
            blendColor);
    }
    
    @Override
    public String toString() {
        return Utils.toString(TranscodeImageRequest.class,
                "accepts", accepts,
                "clientIdentifier", clientIdentifier,
                "product", product,
                "version", version,
                "platform", platform,
                "platformVersion", platformVersion,
                "device", device,
                "model", model,
                "deviceVendor", deviceVendor,
                "deviceName", deviceName,
                "marketplace", marketplace,
                "url", url,
                "format", format,
                "width", width,
                "height", height,
                "quality", quality,
                "background", background,
                "upscale", upscale,
                "minSize", minSize,
                "rotate", rotate,
                "blur", blur,
                "saturation", saturation,
                "opacity", opacity,
                "chromaSubsampling", chromaSubsampling,
                "blendColor", blendColor);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends Accepts> accepts;

        private Optional<String> clientIdentifier = Optional.empty();

        private Optional<String> product = Optional.empty();

        private Optional<String> version = Optional.empty();

        private Optional<String> platform = Optional.empty();

        private Optional<String> platformVersion = Optional.empty();

        private Optional<String> device = Optional.empty();

        private Optional<String> model = Optional.empty();

        private Optional<String> deviceVendor = Optional.empty();

        private Optional<String> deviceName = Optional.empty();

        private Optional<String> marketplace = Optional.empty();

        private Optional<String> url = Optional.empty();

        private Optional<? extends Format> format = Optional.empty();

        private Optional<Long> width = Optional.empty();

        private Optional<Long> height = Optional.empty();

        private Optional<Long> quality = Optional.empty();

        private Optional<String> background = Optional.empty();

        private Optional<? extends BoolInt> upscale;

        private Optional<? extends BoolInt> minSize;

        private Optional<? extends BoolInt> rotate;

        private Optional<Long> blur = Optional.empty();

        private Optional<Long> saturation = Optional.empty();

        private Optional<Long> opacity = Optional.empty();

        private Optional<? extends ChromaSubsampling> chromaSubsampling = Optional.empty();

        private Optional<String> blendColor = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Accepts accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = Optional.ofNullable(accepts);
            return this;
        }

        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Optional<? extends Accepts> accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = accepts;
            return this;
        }


        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(String clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = Optional.ofNullable(clientIdentifier);
            return this;
        }

        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(Optional<String> clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = clientIdentifier;
            return this;
        }


        /**
         * The name of the client product
         */
        public Builder product(String product) {
            Utils.checkNotNull(product, "product");
            this.product = Optional.ofNullable(product);
            return this;
        }

        /**
         * The name of the client product
         */
        public Builder product(Optional<String> product) {
            Utils.checkNotNull(product, "product");
            this.product = product;
            return this;
        }


        /**
         * The version of the client application
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The version of the client application
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }


        /**
         * The platform of the client
         */
        public Builder platform(String platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = Optional.ofNullable(platform);
            return this;
        }

        /**
         * The platform of the client
         */
        public Builder platform(Optional<String> platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = platform;
            return this;
        }


        /**
         * The version of the platform
         */
        public Builder platformVersion(String platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = Optional.ofNullable(platformVersion);
            return this;
        }

        /**
         * The version of the platform
         */
        public Builder platformVersion(Optional<String> platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = platformVersion;
            return this;
        }


        /**
         * A relatively friendly name for the client device
         */
        public Builder device(String device) {
            Utils.checkNotNull(device, "device");
            this.device = Optional.ofNullable(device);
            return this;
        }

        /**
         * A relatively friendly name for the client device
         */
        public Builder device(Optional<String> device) {
            Utils.checkNotNull(device, "device");
            this.device = device;
            return this;
        }


        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(String model) {
            Utils.checkNotNull(model, "model");
            this.model = Optional.ofNullable(model);
            return this;
        }

        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(Optional<String> model) {
            Utils.checkNotNull(model, "model");
            this.model = model;
            return this;
        }


        /**
         * The device vendor
         */
        public Builder deviceVendor(String deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = Optional.ofNullable(deviceVendor);
            return this;
        }

        /**
         * The device vendor
         */
        public Builder deviceVendor(Optional<String> deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = deviceVendor;
            return this;
        }


        /**
         * A friendly name for the client
         */
        public Builder deviceName(String deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = Optional.ofNullable(deviceName);
            return this;
        }

        /**
         * A friendly name for the client
         */
        public Builder deviceName(Optional<String> deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = deviceName;
            return this;
        }


        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(String marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = Optional.ofNullable(marketplace);
            return this;
        }

        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(Optional<String> marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = marketplace;
            return this;
        }


        /**
         * The source URL for the image to transcode.  Note, if this URL requires a token such as `X-Plex-Token`, it should be given as a query parameter to this url.
         */
        public Builder url(String url) {
            Utils.checkNotNull(url, "url");
            this.url = Optional.ofNullable(url);
            return this;
        }

        /**
         * The source URL for the image to transcode.  Note, if this URL requires a token such as `X-Plex-Token`, it should be given as a query parameter to this url.
         */
        public Builder url(Optional<String> url) {
            Utils.checkNotNull(url, "url");
            this.url = url;
            return this;
        }


        /**
         * The output format for the image; defaults to jpg
         */
        public Builder format(Format format) {
            Utils.checkNotNull(format, "format");
            this.format = Optional.ofNullable(format);
            return this;
        }

        /**
         * The output format for the image; defaults to jpg
         */
        public Builder format(Optional<? extends Format> format) {
            Utils.checkNotNull(format, "format");
            this.format = format;
            return this;
        }


        /**
         * The desired width of the output image
         */
        public Builder width(long width) {
            Utils.checkNotNull(width, "width");
            this.width = Optional.ofNullable(width);
            return this;
        }

        /**
         * The desired width of the output image
         */
        public Builder width(Optional<Long> width) {
            Utils.checkNotNull(width, "width");
            this.width = width;
            return this;
        }


        /**
         * The desired height of the output image
         */
        public Builder height(long height) {
            Utils.checkNotNull(height, "height");
            this.height = Optional.ofNullable(height);
            return this;
        }

        /**
         * The desired height of the output image
         */
        public Builder height(Optional<Long> height) {
            Utils.checkNotNull(height, "height");
            this.height = height;
            return this;
        }


        /**
         * The desired quality of the output.  -1 means the highest quality.  Defaults to -1
         */
        public Builder quality(long quality) {
            Utils.checkNotNull(quality, "quality");
            this.quality = Optional.ofNullable(quality);
            return this;
        }

        /**
         * The desired quality of the output.  -1 means the highest quality.  Defaults to -1
         */
        public Builder quality(Optional<Long> quality) {
            Utils.checkNotNull(quality, "quality");
            this.quality = quality;
            return this;
        }


        /**
         * The background color to apply before painting the image.  Only really applicable if image has transparency.  Defaults to none
         */
        public Builder background(String background) {
            Utils.checkNotNull(background, "background");
            this.background = Optional.ofNullable(background);
            return this;
        }

        /**
         * The background color to apply before painting the image.  Only really applicable if image has transparency.  Defaults to none
         */
        public Builder background(Optional<String> background) {
            Utils.checkNotNull(background, "background");
            this.background = background;
            return this;
        }


        /**
         * Indicates if image should be upscaled to the desired width/height.  Defaults to false
         */
        public Builder upscale(BoolInt upscale) {
            Utils.checkNotNull(upscale, "upscale");
            this.upscale = Optional.ofNullable(upscale);
            return this;
        }

        /**
         * Indicates if image should be upscaled to the desired width/height.  Defaults to false
         */
        public Builder upscale(Optional<? extends BoolInt> upscale) {
            Utils.checkNotNull(upscale, "upscale");
            this.upscale = upscale;
            return this;
        }


        /**
         * Indicates if image should be scaled to fit the smaller dimension.  By default (false) the image is scaled to fit within the width/height specified but if this parameter is true, it will allow overflowing one dimension to fit the other.  Essentially it is making the width/height minimum sizes of the image or sizing the image to fill the entire width/height even if it overflows one dimension.
         */
        public Builder minSize(BoolInt minSize) {
            Utils.checkNotNull(minSize, "minSize");
            this.minSize = Optional.ofNullable(minSize);
            return this;
        }

        /**
         * Indicates if image should be scaled to fit the smaller dimension.  By default (false) the image is scaled to fit within the width/height specified but if this parameter is true, it will allow overflowing one dimension to fit the other.  Essentially it is making the width/height minimum sizes of the image or sizing the image to fill the entire width/height even if it overflows one dimension.
         */
        public Builder minSize(Optional<? extends BoolInt> minSize) {
            Utils.checkNotNull(minSize, "minSize");
            this.minSize = minSize;
            return this;
        }


        /**
         * Obey the rotation values specified in EXIF data.  Defaults to true.
         */
        public Builder rotate(BoolInt rotate) {
            Utils.checkNotNull(rotate, "rotate");
            this.rotate = Optional.ofNullable(rotate);
            return this;
        }

        /**
         * Obey the rotation values specified in EXIF data.  Defaults to true.
         */
        public Builder rotate(Optional<? extends BoolInt> rotate) {
            Utils.checkNotNull(rotate, "rotate");
            this.rotate = rotate;
            return this;
        }


        /**
         * Apply a blur to the image, Defaults to 0 (none)
         */
        public Builder blur(long blur) {
            Utils.checkNotNull(blur, "blur");
            this.blur = Optional.ofNullable(blur);
            return this;
        }

        /**
         * Apply a blur to the image, Defaults to 0 (none)
         */
        public Builder blur(Optional<Long> blur) {
            Utils.checkNotNull(blur, "blur");
            this.blur = blur;
            return this;
        }


        /**
         * Scale the image saturation by the specified percentage.  Defaults to 100
         */
        public Builder saturation(long saturation) {
            Utils.checkNotNull(saturation, "saturation");
            this.saturation = Optional.ofNullable(saturation);
            return this;
        }

        /**
         * Scale the image saturation by the specified percentage.  Defaults to 100
         */
        public Builder saturation(Optional<Long> saturation) {
            Utils.checkNotNull(saturation, "saturation");
            this.saturation = saturation;
            return this;
        }


        /**
         * Render the image at the specified opacity percentage.  Defaults to 100
         */
        public Builder opacity(long opacity) {
            Utils.checkNotNull(opacity, "opacity");
            this.opacity = Optional.ofNullable(opacity);
            return this;
        }

        /**
         * Render the image at the specified opacity percentage.  Defaults to 100
         */
        public Builder opacity(Optional<Long> opacity) {
            Utils.checkNotNull(opacity, "opacity");
            this.opacity = opacity;
            return this;
        }


        /**
         * Use the specified chroma subsambling.
         *   - 0: 411
         *   - 1: 420
         *   - 2: 422
         *   - 3: 444
         * Defaults to 3 (444)
         */
        public Builder chromaSubsampling(ChromaSubsampling chromaSubsampling) {
            Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
            this.chromaSubsampling = Optional.ofNullable(chromaSubsampling);
            return this;
        }

        /**
         * Use the specified chroma subsambling.
         *   - 0: 411
         *   - 1: 420
         *   - 2: 422
         *   - 3: 444
         * Defaults to 3 (444)
         */
        public Builder chromaSubsampling(Optional<? extends ChromaSubsampling> chromaSubsampling) {
            Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
            this.chromaSubsampling = chromaSubsampling;
            return this;
        }


        /**
         * The color to blend with the image.  Defaults to none
         */
        public Builder blendColor(String blendColor) {
            Utils.checkNotNull(blendColor, "blendColor");
            this.blendColor = Optional.ofNullable(blendColor);
            return this;
        }

        /**
         * The color to blend with the image.  Defaults to none
         */
        public Builder blendColor(Optional<String> blendColor) {
            Utils.checkNotNull(blendColor, "blendColor");
            this.blendColor = blendColor;
            return this;
        }

        public TranscodeImageRequest build() {
            if (accepts == null) {
                accepts = _SINGLETON_VALUE_Accepts.value();
            }
            if (upscale == null) {
                upscale = _SINGLETON_VALUE_Upscale.value();
            }
            if (minSize == null) {
                minSize = _SINGLETON_VALUE_MinSize.value();
            }
            if (rotate == null) {
                rotate = _SINGLETON_VALUE_Rotate.value();
            }

            return new TranscodeImageRequest(
                accepts, clientIdentifier, product,
                version, platform, platformVersion,
                device, model, deviceVendor,
                deviceName, marketplace, url,
                format, width, height,
                quality, background, upscale,
                minSize, rotate, blur,
                saturation, opacity, chromaSubsampling,
                blendColor);
        }


        private static final LazySingletonValue<Optional<? extends Accepts>> _SINGLETON_VALUE_Accepts =
                new LazySingletonValue<>(
                        "accepts",
                        "\"application/xml\"",
                        new TypeReference<Optional<? extends Accepts>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_Upscale =
                new LazySingletonValue<>(
                        "upscale",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_MinSize =
                new LazySingletonValue<>(
                        "minSize",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_Rotate =
                new LazySingletonValue<>(
                        "rotate",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});
    }
}
