/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.models.shared.Accepts;
import dev.plexapi.sdk.models.shared.BoolInt;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.SpeakeasyMetadata;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;


public class GetStreamRequest {
    /**
     * Indicates the client accepts the indicated media types
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=accepts")
    private Optional<? extends Accepts> accepts;

    /**
     * An opaque identifier unique to the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Client-Identifier")
    private Optional<String> clientIdentifier;

    /**
     * The name of the client product
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Product")
    private Optional<String> product;

    /**
     * The version of the client application
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Version")
    private Optional<String> version;

    /**
     * The platform of the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform")
    private Optional<String> platform;

    /**
     * The version of the platform
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Platform-Version")
    private Optional<String> platformVersion;

    /**
     * A relatively friendly name for the client device
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device")
    private Optional<String> device;

    /**
     * A potentially less friendly identifier for the device model
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Model")
    private Optional<String> model;

    /**
     * The device vendor
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Vendor")
    private Optional<String> deviceVendor;

    /**
     * A friendly name for the client
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Device-Name")
    private Optional<String> deviceName;

    /**
     * The marketplace on which the client application is distributed
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=X-Plex-Marketplace")
    private Optional<String> marketplace;

    /**
     * The id of the stream
     */
    @SpeakeasyMetadata("pathParam:style=simple,explode=false,name=streamId")
    private long streamId;

    /**
     * The extension of the stream.  Required to fetch the `sub` portion of `idx`/`sub` subtitles
     */
    @SpeakeasyMetadata("pathParam:style=simple,explode=false,name=ext")
    private String ext;

    /**
     * The requested encoding for the subtitle (only used for text subtitles)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=encoding")
    private Optional<String> encoding;

    /**
     * The requested format for the subtitle to convert the subtitles to (only used for text subtitles)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=format")
    private Optional<String> format;

    /**
     * Whether the server should attempt to automatically adjust the subtitle timestamps to match the media
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=autoAdjustSubtitle")
    private Optional<? extends BoolInt> autoAdjustSubtitle;

    @JsonCreator
    public GetStreamRequest(
            Optional<? extends Accepts> accepts,
            Optional<String> clientIdentifier,
            Optional<String> product,
            Optional<String> version,
            Optional<String> platform,
            Optional<String> platformVersion,
            Optional<String> device,
            Optional<String> model,
            Optional<String> deviceVendor,
            Optional<String> deviceName,
            Optional<String> marketplace,
            long streamId,
            String ext,
            Optional<String> encoding,
            Optional<String> format,
            Optional<? extends BoolInt> autoAdjustSubtitle) {
        Utils.checkNotNull(accepts, "accepts");
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        Utils.checkNotNull(product, "product");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(platform, "platform");
        Utils.checkNotNull(platformVersion, "platformVersion");
        Utils.checkNotNull(device, "device");
        Utils.checkNotNull(model, "model");
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        Utils.checkNotNull(deviceName, "deviceName");
        Utils.checkNotNull(marketplace, "marketplace");
        Utils.checkNotNull(streamId, "streamId");
        Utils.checkNotNull(ext, "ext");
        Utils.checkNotNull(encoding, "encoding");
        Utils.checkNotNull(format, "format");
        Utils.checkNotNull(autoAdjustSubtitle, "autoAdjustSubtitle");
        this.accepts = accepts;
        this.clientIdentifier = clientIdentifier;
        this.product = product;
        this.version = version;
        this.platform = platform;
        this.platformVersion = platformVersion;
        this.device = device;
        this.model = model;
        this.deviceVendor = deviceVendor;
        this.deviceName = deviceName;
        this.marketplace = marketplace;
        this.streamId = streamId;
        this.ext = ext;
        this.encoding = encoding;
        this.format = format;
        this.autoAdjustSubtitle = autoAdjustSubtitle;
    }
    
    public GetStreamRequest(
            long streamId,
            String ext) {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), streamId,
            ext, Optional.empty(), Optional.empty(),
            Optional.empty());
    }

    /**
     * Indicates the client accepts the indicated media types
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Accepts> accepts() {
        return (Optional<Accepts>) accepts;
    }

    /**
     * An opaque identifier unique to the client
     */
    @JsonIgnore
    public Optional<String> clientIdentifier() {
        return clientIdentifier;
    }

    /**
     * The name of the client product
     */
    @JsonIgnore
    public Optional<String> product() {
        return product;
    }

    /**
     * The version of the client application
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    /**
     * The platform of the client
     */
    @JsonIgnore
    public Optional<String> platform() {
        return platform;
    }

    /**
     * The version of the platform
     */
    @JsonIgnore
    public Optional<String> platformVersion() {
        return platformVersion;
    }

    /**
     * A relatively friendly name for the client device
     */
    @JsonIgnore
    public Optional<String> device() {
        return device;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    @JsonIgnore
    public Optional<String> model() {
        return model;
    }

    /**
     * The device vendor
     */
    @JsonIgnore
    public Optional<String> deviceVendor() {
        return deviceVendor;
    }

    /**
     * A friendly name for the client
     */
    @JsonIgnore
    public Optional<String> deviceName() {
        return deviceName;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    @JsonIgnore
    public Optional<String> marketplace() {
        return marketplace;
    }

    /**
     * The id of the stream
     */
    @JsonIgnore
    public long streamId() {
        return streamId;
    }

    /**
     * The extension of the stream.  Required to fetch the `sub` portion of `idx`/`sub` subtitles
     */
    @JsonIgnore
    public String ext() {
        return ext;
    }

    /**
     * The requested encoding for the subtitle (only used for text subtitles)
     */
    @JsonIgnore
    public Optional<String> encoding() {
        return encoding;
    }

    /**
     * The requested format for the subtitle to convert the subtitles to (only used for text subtitles)
     */
    @JsonIgnore
    public Optional<String> format() {
        return format;
    }

    /**
     * Whether the server should attempt to automatically adjust the subtitle timestamps to match the media
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BoolInt> autoAdjustSubtitle() {
        return (Optional<BoolInt>) autoAdjustSubtitle;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public GetStreamRequest withAccepts(Accepts accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = Optional.ofNullable(accepts);
        return this;
    }


    /**
     * Indicates the client accepts the indicated media types
     */
    public GetStreamRequest withAccepts(Optional<? extends Accepts> accepts) {
        Utils.checkNotNull(accepts, "accepts");
        this.accepts = accepts;
        return this;
    }

    /**
     * An opaque identifier unique to the client
     */
    public GetStreamRequest withClientIdentifier(String clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = Optional.ofNullable(clientIdentifier);
        return this;
    }


    /**
     * An opaque identifier unique to the client
     */
    public GetStreamRequest withClientIdentifier(Optional<String> clientIdentifier) {
        Utils.checkNotNull(clientIdentifier, "clientIdentifier");
        this.clientIdentifier = clientIdentifier;
        return this;
    }

    /**
     * The name of the client product
     */
    public GetStreamRequest withProduct(String product) {
        Utils.checkNotNull(product, "product");
        this.product = Optional.ofNullable(product);
        return this;
    }


    /**
     * The name of the client product
     */
    public GetStreamRequest withProduct(Optional<String> product) {
        Utils.checkNotNull(product, "product");
        this.product = product;
        return this;
    }

    /**
     * The version of the client application
     */
    public GetStreamRequest withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }


    /**
     * The version of the client application
     */
    public GetStreamRequest withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * The platform of the client
     */
    public GetStreamRequest withPlatform(String platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = Optional.ofNullable(platform);
        return this;
    }


    /**
     * The platform of the client
     */
    public GetStreamRequest withPlatform(Optional<String> platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = platform;
        return this;
    }

    /**
     * The version of the platform
     */
    public GetStreamRequest withPlatformVersion(String platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = Optional.ofNullable(platformVersion);
        return this;
    }


    /**
     * The version of the platform
     */
    public GetStreamRequest withPlatformVersion(Optional<String> platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = platformVersion;
        return this;
    }

    /**
     * A relatively friendly name for the client device
     */
    public GetStreamRequest withDevice(String device) {
        Utils.checkNotNull(device, "device");
        this.device = Optional.ofNullable(device);
        return this;
    }


    /**
     * A relatively friendly name for the client device
     */
    public GetStreamRequest withDevice(Optional<String> device) {
        Utils.checkNotNull(device, "device");
        this.device = device;
        return this;
    }

    /**
     * A potentially less friendly identifier for the device model
     */
    public GetStreamRequest withModel(String model) {
        Utils.checkNotNull(model, "model");
        this.model = Optional.ofNullable(model);
        return this;
    }


    /**
     * A potentially less friendly identifier for the device model
     */
    public GetStreamRequest withModel(Optional<String> model) {
        Utils.checkNotNull(model, "model");
        this.model = model;
        return this;
    }

    /**
     * The device vendor
     */
    public GetStreamRequest withDeviceVendor(String deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = Optional.ofNullable(deviceVendor);
        return this;
    }


    /**
     * The device vendor
     */
    public GetStreamRequest withDeviceVendor(Optional<String> deviceVendor) {
        Utils.checkNotNull(deviceVendor, "deviceVendor");
        this.deviceVendor = deviceVendor;
        return this;
    }

    /**
     * A friendly name for the client
     */
    public GetStreamRequest withDeviceName(String deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = Optional.ofNullable(deviceName);
        return this;
    }


    /**
     * A friendly name for the client
     */
    public GetStreamRequest withDeviceName(Optional<String> deviceName) {
        Utils.checkNotNull(deviceName, "deviceName");
        this.deviceName = deviceName;
        return this;
    }

    /**
     * The marketplace on which the client application is distributed
     */
    public GetStreamRequest withMarketplace(String marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = Optional.ofNullable(marketplace);
        return this;
    }


    /**
     * The marketplace on which the client application is distributed
     */
    public GetStreamRequest withMarketplace(Optional<String> marketplace) {
        Utils.checkNotNull(marketplace, "marketplace");
        this.marketplace = marketplace;
        return this;
    }

    /**
     * The id of the stream
     */
    public GetStreamRequest withStreamId(long streamId) {
        Utils.checkNotNull(streamId, "streamId");
        this.streamId = streamId;
        return this;
    }

    /**
     * The extension of the stream.  Required to fetch the `sub` portion of `idx`/`sub` subtitles
     */
    public GetStreamRequest withExt(String ext) {
        Utils.checkNotNull(ext, "ext");
        this.ext = ext;
        return this;
    }

    /**
     * The requested encoding for the subtitle (only used for text subtitles)
     */
    public GetStreamRequest withEncoding(String encoding) {
        Utils.checkNotNull(encoding, "encoding");
        this.encoding = Optional.ofNullable(encoding);
        return this;
    }


    /**
     * The requested encoding for the subtitle (only used for text subtitles)
     */
    public GetStreamRequest withEncoding(Optional<String> encoding) {
        Utils.checkNotNull(encoding, "encoding");
        this.encoding = encoding;
        return this;
    }

    /**
     * The requested format for the subtitle to convert the subtitles to (only used for text subtitles)
     */
    public GetStreamRequest withFormat(String format) {
        Utils.checkNotNull(format, "format");
        this.format = Optional.ofNullable(format);
        return this;
    }


    /**
     * The requested format for the subtitle to convert the subtitles to (only used for text subtitles)
     */
    public GetStreamRequest withFormat(Optional<String> format) {
        Utils.checkNotNull(format, "format");
        this.format = format;
        return this;
    }

    /**
     * Whether the server should attempt to automatically adjust the subtitle timestamps to match the media
     */
    public GetStreamRequest withAutoAdjustSubtitle(BoolInt autoAdjustSubtitle) {
        Utils.checkNotNull(autoAdjustSubtitle, "autoAdjustSubtitle");
        this.autoAdjustSubtitle = Optional.ofNullable(autoAdjustSubtitle);
        return this;
    }


    /**
     * Whether the server should attempt to automatically adjust the subtitle timestamps to match the media
     */
    public GetStreamRequest withAutoAdjustSubtitle(Optional<? extends BoolInt> autoAdjustSubtitle) {
        Utils.checkNotNull(autoAdjustSubtitle, "autoAdjustSubtitle");
        this.autoAdjustSubtitle = autoAdjustSubtitle;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        GetStreamRequest other = (GetStreamRequest) o;
        return 
            Utils.enhancedDeepEquals(this.accepts, other.accepts) &&
            Utils.enhancedDeepEquals(this.clientIdentifier, other.clientIdentifier) &&
            Utils.enhancedDeepEquals(this.product, other.product) &&
            Utils.enhancedDeepEquals(this.version, other.version) &&
            Utils.enhancedDeepEquals(this.platform, other.platform) &&
            Utils.enhancedDeepEquals(this.platformVersion, other.platformVersion) &&
            Utils.enhancedDeepEquals(this.device, other.device) &&
            Utils.enhancedDeepEquals(this.model, other.model) &&
            Utils.enhancedDeepEquals(this.deviceVendor, other.deviceVendor) &&
            Utils.enhancedDeepEquals(this.deviceName, other.deviceName) &&
            Utils.enhancedDeepEquals(this.marketplace, other.marketplace) &&
            Utils.enhancedDeepEquals(this.streamId, other.streamId) &&
            Utils.enhancedDeepEquals(this.ext, other.ext) &&
            Utils.enhancedDeepEquals(this.encoding, other.encoding) &&
            Utils.enhancedDeepEquals(this.format, other.format) &&
            Utils.enhancedDeepEquals(this.autoAdjustSubtitle, other.autoAdjustSubtitle);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            accepts, clientIdentifier, product,
            version, platform, platformVersion,
            device, model, deviceVendor,
            deviceName, marketplace, streamId,
            ext, encoding, format,
            autoAdjustSubtitle);
    }
    
    @Override
    public String toString() {
        return Utils.toString(GetStreamRequest.class,
                "accepts", accepts,
                "clientIdentifier", clientIdentifier,
                "product", product,
                "version", version,
                "platform", platform,
                "platformVersion", platformVersion,
                "device", device,
                "model", model,
                "deviceVendor", deviceVendor,
                "deviceName", deviceName,
                "marketplace", marketplace,
                "streamId", streamId,
                "ext", ext,
                "encoding", encoding,
                "format", format,
                "autoAdjustSubtitle", autoAdjustSubtitle);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends Accepts> accepts;

        private Optional<String> clientIdentifier = Optional.empty();

        private Optional<String> product = Optional.empty();

        private Optional<String> version = Optional.empty();

        private Optional<String> platform = Optional.empty();

        private Optional<String> platformVersion = Optional.empty();

        private Optional<String> device = Optional.empty();

        private Optional<String> model = Optional.empty();

        private Optional<String> deviceVendor = Optional.empty();

        private Optional<String> deviceName = Optional.empty();

        private Optional<String> marketplace = Optional.empty();

        private Long streamId;

        private String ext;

        private Optional<String> encoding = Optional.empty();

        private Optional<String> format = Optional.empty();

        private Optional<? extends BoolInt> autoAdjustSubtitle;

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Accepts accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = Optional.ofNullable(accepts);
            return this;
        }

        /**
         * Indicates the client accepts the indicated media types
         */
        public Builder accepts(Optional<? extends Accepts> accepts) {
            Utils.checkNotNull(accepts, "accepts");
            this.accepts = accepts;
            return this;
        }


        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(String clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = Optional.ofNullable(clientIdentifier);
            return this;
        }

        /**
         * An opaque identifier unique to the client
         */
        public Builder clientIdentifier(Optional<String> clientIdentifier) {
            Utils.checkNotNull(clientIdentifier, "clientIdentifier");
            this.clientIdentifier = clientIdentifier;
            return this;
        }


        /**
         * The name of the client product
         */
        public Builder product(String product) {
            Utils.checkNotNull(product, "product");
            this.product = Optional.ofNullable(product);
            return this;
        }

        /**
         * The name of the client product
         */
        public Builder product(Optional<String> product) {
            Utils.checkNotNull(product, "product");
            this.product = product;
            return this;
        }


        /**
         * The version of the client application
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The version of the client application
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }


        /**
         * The platform of the client
         */
        public Builder platform(String platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = Optional.ofNullable(platform);
            return this;
        }

        /**
         * The platform of the client
         */
        public Builder platform(Optional<String> platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = platform;
            return this;
        }


        /**
         * The version of the platform
         */
        public Builder platformVersion(String platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = Optional.ofNullable(platformVersion);
            return this;
        }

        /**
         * The version of the platform
         */
        public Builder platformVersion(Optional<String> platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = platformVersion;
            return this;
        }


        /**
         * A relatively friendly name for the client device
         */
        public Builder device(String device) {
            Utils.checkNotNull(device, "device");
            this.device = Optional.ofNullable(device);
            return this;
        }

        /**
         * A relatively friendly name for the client device
         */
        public Builder device(Optional<String> device) {
            Utils.checkNotNull(device, "device");
            this.device = device;
            return this;
        }


        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(String model) {
            Utils.checkNotNull(model, "model");
            this.model = Optional.ofNullable(model);
            return this;
        }

        /**
         * A potentially less friendly identifier for the device model
         */
        public Builder model(Optional<String> model) {
            Utils.checkNotNull(model, "model");
            this.model = model;
            return this;
        }


        /**
         * The device vendor
         */
        public Builder deviceVendor(String deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = Optional.ofNullable(deviceVendor);
            return this;
        }

        /**
         * The device vendor
         */
        public Builder deviceVendor(Optional<String> deviceVendor) {
            Utils.checkNotNull(deviceVendor, "deviceVendor");
            this.deviceVendor = deviceVendor;
            return this;
        }


        /**
         * A friendly name for the client
         */
        public Builder deviceName(String deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = Optional.ofNullable(deviceName);
            return this;
        }

        /**
         * A friendly name for the client
         */
        public Builder deviceName(Optional<String> deviceName) {
            Utils.checkNotNull(deviceName, "deviceName");
            this.deviceName = deviceName;
            return this;
        }


        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(String marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = Optional.ofNullable(marketplace);
            return this;
        }

        /**
         * The marketplace on which the client application is distributed
         */
        public Builder marketplace(Optional<String> marketplace) {
            Utils.checkNotNull(marketplace, "marketplace");
            this.marketplace = marketplace;
            return this;
        }


        /**
         * The id of the stream
         */
        public Builder streamId(long streamId) {
            Utils.checkNotNull(streamId, "streamId");
            this.streamId = streamId;
            return this;
        }


        /**
         * The extension of the stream.  Required to fetch the `sub` portion of `idx`/`sub` subtitles
         */
        public Builder ext(String ext) {
            Utils.checkNotNull(ext, "ext");
            this.ext = ext;
            return this;
        }


        /**
         * The requested encoding for the subtitle (only used for text subtitles)
         */
        public Builder encoding(String encoding) {
            Utils.checkNotNull(encoding, "encoding");
            this.encoding = Optional.ofNullable(encoding);
            return this;
        }

        /**
         * The requested encoding for the subtitle (only used for text subtitles)
         */
        public Builder encoding(Optional<String> encoding) {
            Utils.checkNotNull(encoding, "encoding");
            this.encoding = encoding;
            return this;
        }


        /**
         * The requested format for the subtitle to convert the subtitles to (only used for text subtitles)
         */
        public Builder format(String format) {
            Utils.checkNotNull(format, "format");
            this.format = Optional.ofNullable(format);
            return this;
        }

        /**
         * The requested format for the subtitle to convert the subtitles to (only used for text subtitles)
         */
        public Builder format(Optional<String> format) {
            Utils.checkNotNull(format, "format");
            this.format = format;
            return this;
        }


        /**
         * Whether the server should attempt to automatically adjust the subtitle timestamps to match the media
         */
        public Builder autoAdjustSubtitle(BoolInt autoAdjustSubtitle) {
            Utils.checkNotNull(autoAdjustSubtitle, "autoAdjustSubtitle");
            this.autoAdjustSubtitle = Optional.ofNullable(autoAdjustSubtitle);
            return this;
        }

        /**
         * Whether the server should attempt to automatically adjust the subtitle timestamps to match the media
         */
        public Builder autoAdjustSubtitle(Optional<? extends BoolInt> autoAdjustSubtitle) {
            Utils.checkNotNull(autoAdjustSubtitle, "autoAdjustSubtitle");
            this.autoAdjustSubtitle = autoAdjustSubtitle;
            return this;
        }

        public GetStreamRequest build() {
            if (accepts == null) {
                accepts = _SINGLETON_VALUE_Accepts.value();
            }
            if (autoAdjustSubtitle == null) {
                autoAdjustSubtitle = _SINGLETON_VALUE_AutoAdjustSubtitle.value();
            }

            return new GetStreamRequest(
                accepts, clientIdentifier, product,
                version, platform, platformVersion,
                device, model, deviceVendor,
                deviceName, marketplace, streamId,
                ext, encoding, format,
                autoAdjustSubtitle);
        }


        private static final LazySingletonValue<Optional<? extends Accepts>> _SINGLETON_VALUE_Accepts =
                new LazySingletonValue<>(
                        "accepts",
                        "\"application/xml\"",
                        new TypeReference<Optional<? extends Accepts>>() {});

        private static final LazySingletonValue<Optional<? extends BoolInt>> _SINGLETON_VALUE_AutoAdjustSubtitle =
                new LazySingletonValue<>(
                        "autoAdjustSubtitle",
                        "0",
                        new TypeReference<Optional<? extends BoolInt>>() {});
    }
}
