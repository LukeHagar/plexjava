/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Optional;


public class GetLibrarySectionsAllPart {
    /**
     * Indicates if the part is accessible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessible")
    private Optional<Boolean> accessible;

    /**
     * Indicates if the part exists.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("exists")
    private Optional<Boolean> exists;

    /**
     * Unique part identifier.
     */
    @JsonProperty("id")
    private long id;

    /**
     * Key to access this part.
     */
    @JsonProperty("key")
    private String key;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("indexes")
    private Optional<String> indexes;

    /**
     * Duration of the part in milliseconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("duration")
    private Optional<Integer> duration;

    /**
     * File path for the part.
     */
    @JsonProperty("file")
    private String file;

    /**
     * File size in bytes.
     */
    @JsonProperty("size")
    private long size;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("packetLength")
    private Optional<Integer> packetLength;

    /**
     * Container format of the part.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("container")
    private Optional<String> container;

    /**
     * Video profile for the part.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("videoProfile")
    private Optional<String> videoProfile;

    /**
     * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("audioProfile")
    private Optional<String> audioProfile;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("has64bitOffsets")
    private Optional<Boolean> has64bitOffsets;

    /**
     * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("optimizedForStreaming")
    private Optional<? extends GetLibrarySectionsAllLibraryOptimizedForStreaming> optimizedForStreaming;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hasThumbnail")
    private Optional<? extends GetLibrarySectionsAllHasThumbnail> hasThumbnail;

    /**
     * An array of streams for this part.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Stream")
    private Optional<? extends List<GetLibrarySectionsAllStream>> stream;

    @JsonCreator
    public GetLibrarySectionsAllPart(
            @JsonProperty("accessible") Optional<Boolean> accessible,
            @JsonProperty("exists") Optional<Boolean> exists,
            @JsonProperty("id") long id,
            @JsonProperty("key") String key,
            @JsonProperty("indexes") Optional<String> indexes,
            @JsonProperty("duration") Optional<Integer> duration,
            @JsonProperty("file") String file,
            @JsonProperty("size") long size,
            @JsonProperty("packetLength") Optional<Integer> packetLength,
            @JsonProperty("container") Optional<String> container,
            @JsonProperty("videoProfile") Optional<String> videoProfile,
            @JsonProperty("audioProfile") Optional<String> audioProfile,
            @JsonProperty("has64bitOffsets") Optional<Boolean> has64bitOffsets,
            @JsonProperty("optimizedForStreaming") Optional<? extends GetLibrarySectionsAllLibraryOptimizedForStreaming> optimizedForStreaming,
            @JsonProperty("hasThumbnail") Optional<? extends GetLibrarySectionsAllHasThumbnail> hasThumbnail,
            @JsonProperty("Stream") Optional<? extends List<GetLibrarySectionsAllStream>> stream) {
        Utils.checkNotNull(accessible, "accessible");
        Utils.checkNotNull(exists, "exists");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(indexes, "indexes");
        Utils.checkNotNull(duration, "duration");
        Utils.checkNotNull(file, "file");
        Utils.checkNotNull(size, "size");
        Utils.checkNotNull(packetLength, "packetLength");
        Utils.checkNotNull(container, "container");
        Utils.checkNotNull(videoProfile, "videoProfile");
        Utils.checkNotNull(audioProfile, "audioProfile");
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        Utils.checkNotNull(hasThumbnail, "hasThumbnail");
        Utils.checkNotNull(stream, "stream");
        this.accessible = accessible;
        this.exists = exists;
        this.id = id;
        this.key = key;
        this.indexes = indexes;
        this.duration = duration;
        this.file = file;
        this.size = size;
        this.packetLength = packetLength;
        this.container = container;
        this.videoProfile = videoProfile;
        this.audioProfile = audioProfile;
        this.has64bitOffsets = has64bitOffsets;
        this.optimizedForStreaming = optimizedForStreaming;
        this.hasThumbnail = hasThumbnail;
        this.stream = stream;
    }
    
    public GetLibrarySectionsAllPart(
            long id,
            String key,
            String file,
            long size) {
        this(Optional.empty(), Optional.empty(), id,
            key, Optional.empty(), Optional.empty(),
            file, size, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty());
    }

    /**
     * Indicates if the part is accessible.
     */
    @JsonIgnore
    public Optional<Boolean> accessible() {
        return accessible;
    }

    /**
     * Indicates if the part exists.
     */
    @JsonIgnore
    public Optional<Boolean> exists() {
        return exists;
    }

    /**
     * Unique part identifier.
     */
    @JsonIgnore
    public long id() {
        return id;
    }

    /**
     * Key to access this part.
     */
    @JsonIgnore
    public String key() {
        return key;
    }

    @JsonIgnore
    public Optional<String> indexes() {
        return indexes;
    }

    /**
     * Duration of the part in milliseconds.
     */
    @JsonIgnore
    public Optional<Integer> duration() {
        return duration;
    }

    /**
     * File path for the part.
     */
    @JsonIgnore
    public String file() {
        return file;
    }

    /**
     * File size in bytes.
     */
    @JsonIgnore
    public long size() {
        return size;
    }

    @JsonIgnore
    public Optional<Integer> packetLength() {
        return packetLength;
    }

    /**
     * Container format of the part.
     */
    @JsonIgnore
    public Optional<String> container() {
        return container;
    }

    /**
     * Video profile for the part.
     */
    @JsonIgnore
    public Optional<String> videoProfile() {
        return videoProfile;
    }

    /**
     * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
     */
    @JsonIgnore
    public Optional<String> audioProfile() {
        return audioProfile;
    }

    @JsonIgnore
    public Optional<Boolean> has64bitOffsets() {
        return has64bitOffsets;
    }

    /**
     * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetLibrarySectionsAllLibraryOptimizedForStreaming> optimizedForStreaming() {
        return (Optional<GetLibrarySectionsAllLibraryOptimizedForStreaming>) optimizedForStreaming;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetLibrarySectionsAllHasThumbnail> hasThumbnail() {
        return (Optional<GetLibrarySectionsAllHasThumbnail>) hasThumbnail;
    }

    /**
     * An array of streams for this part.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<GetLibrarySectionsAllStream>> stream() {
        return (Optional<List<GetLibrarySectionsAllStream>>) stream;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates if the part is accessible.
     */
    public GetLibrarySectionsAllPart withAccessible(boolean accessible) {
        Utils.checkNotNull(accessible, "accessible");
        this.accessible = Optional.ofNullable(accessible);
        return this;
    }


    /**
     * Indicates if the part is accessible.
     */
    public GetLibrarySectionsAllPart withAccessible(Optional<Boolean> accessible) {
        Utils.checkNotNull(accessible, "accessible");
        this.accessible = accessible;
        return this;
    }

    /**
     * Indicates if the part exists.
     */
    public GetLibrarySectionsAllPart withExists(boolean exists) {
        Utils.checkNotNull(exists, "exists");
        this.exists = Optional.ofNullable(exists);
        return this;
    }


    /**
     * Indicates if the part exists.
     */
    public GetLibrarySectionsAllPart withExists(Optional<Boolean> exists) {
        Utils.checkNotNull(exists, "exists");
        this.exists = exists;
        return this;
    }

    /**
     * Unique part identifier.
     */
    public GetLibrarySectionsAllPart withId(long id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Key to access this part.
     */
    public GetLibrarySectionsAllPart withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    public GetLibrarySectionsAllPart withIndexes(String indexes) {
        Utils.checkNotNull(indexes, "indexes");
        this.indexes = Optional.ofNullable(indexes);
        return this;
    }


    public GetLibrarySectionsAllPart withIndexes(Optional<String> indexes) {
        Utils.checkNotNull(indexes, "indexes");
        this.indexes = indexes;
        return this;
    }

    /**
     * Duration of the part in milliseconds.
     */
    public GetLibrarySectionsAllPart withDuration(int duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = Optional.ofNullable(duration);
        return this;
    }


    /**
     * Duration of the part in milliseconds.
     */
    public GetLibrarySectionsAllPart withDuration(Optional<Integer> duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = duration;
        return this;
    }

    /**
     * File path for the part.
     */
    public GetLibrarySectionsAllPart withFile(String file) {
        Utils.checkNotNull(file, "file");
        this.file = file;
        return this;
    }

    /**
     * File size in bytes.
     */
    public GetLibrarySectionsAllPart withSize(long size) {
        Utils.checkNotNull(size, "size");
        this.size = size;
        return this;
    }

    public GetLibrarySectionsAllPart withPacketLength(int packetLength) {
        Utils.checkNotNull(packetLength, "packetLength");
        this.packetLength = Optional.ofNullable(packetLength);
        return this;
    }


    public GetLibrarySectionsAllPart withPacketLength(Optional<Integer> packetLength) {
        Utils.checkNotNull(packetLength, "packetLength");
        this.packetLength = packetLength;
        return this;
    }

    /**
     * Container format of the part.
     */
    public GetLibrarySectionsAllPart withContainer(String container) {
        Utils.checkNotNull(container, "container");
        this.container = Optional.ofNullable(container);
        return this;
    }


    /**
     * Container format of the part.
     */
    public GetLibrarySectionsAllPart withContainer(Optional<String> container) {
        Utils.checkNotNull(container, "container");
        this.container = container;
        return this;
    }

    /**
     * Video profile for the part.
     */
    public GetLibrarySectionsAllPart withVideoProfile(String videoProfile) {
        Utils.checkNotNull(videoProfile, "videoProfile");
        this.videoProfile = Optional.ofNullable(videoProfile);
        return this;
    }


    /**
     * Video profile for the part.
     */
    public GetLibrarySectionsAllPart withVideoProfile(Optional<String> videoProfile) {
        Utils.checkNotNull(videoProfile, "videoProfile");
        this.videoProfile = videoProfile;
        return this;
    }

    /**
     * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
     */
    public GetLibrarySectionsAllPart withAudioProfile(String audioProfile) {
        Utils.checkNotNull(audioProfile, "audioProfile");
        this.audioProfile = Optional.ofNullable(audioProfile);
        return this;
    }


    /**
     * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
     */
    public GetLibrarySectionsAllPart withAudioProfile(Optional<String> audioProfile) {
        Utils.checkNotNull(audioProfile, "audioProfile");
        this.audioProfile = audioProfile;
        return this;
    }

    public GetLibrarySectionsAllPart withHas64bitOffsets(boolean has64bitOffsets) {
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        this.has64bitOffsets = Optional.ofNullable(has64bitOffsets);
        return this;
    }


    public GetLibrarySectionsAllPart withHas64bitOffsets(Optional<Boolean> has64bitOffsets) {
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        this.has64bitOffsets = has64bitOffsets;
        return this;
    }

    /**
     * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
     */
    public GetLibrarySectionsAllPart withOptimizedForStreaming(GetLibrarySectionsAllLibraryOptimizedForStreaming optimizedForStreaming) {
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        this.optimizedForStreaming = Optional.ofNullable(optimizedForStreaming);
        return this;
    }


    /**
     * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
     */
    public GetLibrarySectionsAllPart withOptimizedForStreaming(Optional<? extends GetLibrarySectionsAllLibraryOptimizedForStreaming> optimizedForStreaming) {
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        this.optimizedForStreaming = optimizedForStreaming;
        return this;
    }

    public GetLibrarySectionsAllPart withHasThumbnail(GetLibrarySectionsAllHasThumbnail hasThumbnail) {
        Utils.checkNotNull(hasThumbnail, "hasThumbnail");
        this.hasThumbnail = Optional.ofNullable(hasThumbnail);
        return this;
    }


    public GetLibrarySectionsAllPart withHasThumbnail(Optional<? extends GetLibrarySectionsAllHasThumbnail> hasThumbnail) {
        Utils.checkNotNull(hasThumbnail, "hasThumbnail");
        this.hasThumbnail = hasThumbnail;
        return this;
    }

    /**
     * An array of streams for this part.
     */
    public GetLibrarySectionsAllPart withStream(List<GetLibrarySectionsAllStream> stream) {
        Utils.checkNotNull(stream, "stream");
        this.stream = Optional.ofNullable(stream);
        return this;
    }


    /**
     * An array of streams for this part.
     */
    public GetLibrarySectionsAllPart withStream(Optional<? extends List<GetLibrarySectionsAllStream>> stream) {
        Utils.checkNotNull(stream, "stream");
        this.stream = stream;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        GetLibrarySectionsAllPart other = (GetLibrarySectionsAllPart) o;
        return 
            Utils.enhancedDeepEquals(this.accessible, other.accessible) &&
            Utils.enhancedDeepEquals(this.exists, other.exists) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.indexes, other.indexes) &&
            Utils.enhancedDeepEquals(this.duration, other.duration) &&
            Utils.enhancedDeepEquals(this.file, other.file) &&
            Utils.enhancedDeepEquals(this.size, other.size) &&
            Utils.enhancedDeepEquals(this.packetLength, other.packetLength) &&
            Utils.enhancedDeepEquals(this.container, other.container) &&
            Utils.enhancedDeepEquals(this.videoProfile, other.videoProfile) &&
            Utils.enhancedDeepEquals(this.audioProfile, other.audioProfile) &&
            Utils.enhancedDeepEquals(this.has64bitOffsets, other.has64bitOffsets) &&
            Utils.enhancedDeepEquals(this.optimizedForStreaming, other.optimizedForStreaming) &&
            Utils.enhancedDeepEquals(this.hasThumbnail, other.hasThumbnail) &&
            Utils.enhancedDeepEquals(this.stream, other.stream);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            accessible, exists, id,
            key, indexes, duration,
            file, size, packetLength,
            container, videoProfile, audioProfile,
            has64bitOffsets, optimizedForStreaming, hasThumbnail,
            stream);
    }
    
    @Override
    public String toString() {
        return Utils.toString(GetLibrarySectionsAllPart.class,
                "accessible", accessible,
                "exists", exists,
                "id", id,
                "key", key,
                "indexes", indexes,
                "duration", duration,
                "file", file,
                "size", size,
                "packetLength", packetLength,
                "container", container,
                "videoProfile", videoProfile,
                "audioProfile", audioProfile,
                "has64bitOffsets", has64bitOffsets,
                "optimizedForStreaming", optimizedForStreaming,
                "hasThumbnail", hasThumbnail,
                "stream", stream);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<Boolean> accessible = Optional.empty();

        private Optional<Boolean> exists = Optional.empty();

        private Long id;

        private String key;

        private Optional<String> indexes = Optional.empty();

        private Optional<Integer> duration = Optional.empty();

        private String file;

        private Long size;

        private Optional<Integer> packetLength = Optional.empty();

        private Optional<String> container = Optional.empty();

        private Optional<String> videoProfile = Optional.empty();

        private Optional<String> audioProfile = Optional.empty();

        private Optional<Boolean> has64bitOffsets = Optional.empty();

        private Optional<? extends GetLibrarySectionsAllLibraryOptimizedForStreaming> optimizedForStreaming = Optional.empty();

        private Optional<? extends GetLibrarySectionsAllHasThumbnail> hasThumbnail;

        private Optional<? extends List<GetLibrarySectionsAllStream>> stream = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates if the part is accessible.
         */
        public Builder accessible(boolean accessible) {
            Utils.checkNotNull(accessible, "accessible");
            this.accessible = Optional.ofNullable(accessible);
            return this;
        }

        /**
         * Indicates if the part is accessible.
         */
        public Builder accessible(Optional<Boolean> accessible) {
            Utils.checkNotNull(accessible, "accessible");
            this.accessible = accessible;
            return this;
        }


        /**
         * Indicates if the part exists.
         */
        public Builder exists(boolean exists) {
            Utils.checkNotNull(exists, "exists");
            this.exists = Optional.ofNullable(exists);
            return this;
        }

        /**
         * Indicates if the part exists.
         */
        public Builder exists(Optional<Boolean> exists) {
            Utils.checkNotNull(exists, "exists");
            this.exists = exists;
            return this;
        }


        /**
         * Unique part identifier.
         */
        public Builder id(long id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * Key to access this part.
         */
        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        public Builder indexes(String indexes) {
            Utils.checkNotNull(indexes, "indexes");
            this.indexes = Optional.ofNullable(indexes);
            return this;
        }

        public Builder indexes(Optional<String> indexes) {
            Utils.checkNotNull(indexes, "indexes");
            this.indexes = indexes;
            return this;
        }


        /**
         * Duration of the part in milliseconds.
         */
        public Builder duration(int duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = Optional.ofNullable(duration);
            return this;
        }

        /**
         * Duration of the part in milliseconds.
         */
        public Builder duration(Optional<Integer> duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = duration;
            return this;
        }


        /**
         * File path for the part.
         */
        public Builder file(String file) {
            Utils.checkNotNull(file, "file");
            this.file = file;
            return this;
        }


        /**
         * File size in bytes.
         */
        public Builder size(long size) {
            Utils.checkNotNull(size, "size");
            this.size = size;
            return this;
        }


        public Builder packetLength(int packetLength) {
            Utils.checkNotNull(packetLength, "packetLength");
            this.packetLength = Optional.ofNullable(packetLength);
            return this;
        }

        public Builder packetLength(Optional<Integer> packetLength) {
            Utils.checkNotNull(packetLength, "packetLength");
            this.packetLength = packetLength;
            return this;
        }


        /**
         * Container format of the part.
         */
        public Builder container(String container) {
            Utils.checkNotNull(container, "container");
            this.container = Optional.ofNullable(container);
            return this;
        }

        /**
         * Container format of the part.
         */
        public Builder container(Optional<String> container) {
            Utils.checkNotNull(container, "container");
            this.container = container;
            return this;
        }


        /**
         * Video profile for the part.
         */
        public Builder videoProfile(String videoProfile) {
            Utils.checkNotNull(videoProfile, "videoProfile");
            this.videoProfile = Optional.ofNullable(videoProfile);
            return this;
        }

        /**
         * Video profile for the part.
         */
        public Builder videoProfile(Optional<String> videoProfile) {
            Utils.checkNotNull(videoProfile, "videoProfile");
            this.videoProfile = videoProfile;
            return this;
        }


        /**
         * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
         */
        public Builder audioProfile(String audioProfile) {
            Utils.checkNotNull(audioProfile, "audioProfile");
            this.audioProfile = Optional.ofNullable(audioProfile);
            return this;
        }

        /**
         * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
         */
        public Builder audioProfile(Optional<String> audioProfile) {
            Utils.checkNotNull(audioProfile, "audioProfile");
            this.audioProfile = audioProfile;
            return this;
        }


        public Builder has64bitOffsets(boolean has64bitOffsets) {
            Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
            this.has64bitOffsets = Optional.ofNullable(has64bitOffsets);
            return this;
        }

        public Builder has64bitOffsets(Optional<Boolean> has64bitOffsets) {
            Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
            this.has64bitOffsets = has64bitOffsets;
            return this;
        }


        /**
         * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
         */
        public Builder optimizedForStreaming(GetLibrarySectionsAllLibraryOptimizedForStreaming optimizedForStreaming) {
            Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
            this.optimizedForStreaming = Optional.ofNullable(optimizedForStreaming);
            return this;
        }

        /**
         * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
         */
        public Builder optimizedForStreaming(Optional<? extends GetLibrarySectionsAllLibraryOptimizedForStreaming> optimizedForStreaming) {
            Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
            this.optimizedForStreaming = optimizedForStreaming;
            return this;
        }


        public Builder hasThumbnail(GetLibrarySectionsAllHasThumbnail hasThumbnail) {
            Utils.checkNotNull(hasThumbnail, "hasThumbnail");
            this.hasThumbnail = Optional.ofNullable(hasThumbnail);
            return this;
        }

        public Builder hasThumbnail(Optional<? extends GetLibrarySectionsAllHasThumbnail> hasThumbnail) {
            Utils.checkNotNull(hasThumbnail, "hasThumbnail");
            this.hasThumbnail = hasThumbnail;
            return this;
        }


        /**
         * An array of streams for this part.
         */
        public Builder stream(List<GetLibrarySectionsAllStream> stream) {
            Utils.checkNotNull(stream, "stream");
            this.stream = Optional.ofNullable(stream);
            return this;
        }

        /**
         * An array of streams for this part.
         */
        public Builder stream(Optional<? extends List<GetLibrarySectionsAllStream>> stream) {
            Utils.checkNotNull(stream, "stream");
            this.stream = stream;
            return this;
        }

        public GetLibrarySectionsAllPart build() {
            if (hasThumbnail == null) {
                hasThumbnail = _SINGLETON_VALUE_HasThumbnail.value();
            }

            return new GetLibrarySectionsAllPart(
                accessible, exists, id,
                key, indexes, duration,
                file, size, packetLength,
                container, videoProfile, audioProfile,
                has64bitOffsets, optimizedForStreaming, hasThumbnail,
                stream);
        }


        private static final LazySingletonValue<Optional<? extends GetLibrarySectionsAllHasThumbnail>> _SINGLETON_VALUE_HasThumbnail =
                new LazySingletonValue<>(
                        "hasThumbnail",
                        "\"0\"",
                        new TypeReference<Optional<? extends GetLibrarySectionsAllHasThumbnail>>() {});
    }
}
