/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */


package dev.plexapi.sdk.models.operations;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class GetMediaMetaDataPart {

    /**
     * Indicates if the part is accessible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessible")
    private Optional<Boolean> accessible;

    /**
     * Indicates if the part exists.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("exists")
    private Optional<Boolean> exists;

    /**
     * Unique part identifier.
     */
    @JsonProperty("id")
    private long id;

    /**
     * Key to access this part.
     */
    @JsonProperty("key")
    private String key;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("indexes")
    private Optional<String> indexes;

    /**
     * Duration of the part in milliseconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("duration")
    private Optional<Integer> duration;

    /**
     * File path for the part.
     */
    @JsonProperty("file")
    private String file;

    /**
     * File size in bytes.
     */
    @JsonProperty("size")
    private long size;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("packetLength")
    private Optional<Integer> packetLength;

    /**
     * Container format of the part.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("container")
    private Optional<String> container;

    /**
     * Video profile for the part.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("videoProfile")
    private Optional<String> videoProfile;

    /**
     * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("audioProfile")
    private Optional<String> audioProfile;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("has64bitOffsets")
    private Optional<Boolean> has64bitOffsets;

    /**
     * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("optimizedForStreaming")
    private Optional<? extends GetMediaMetaDataLibraryOptimizedForStreaming> optimizedForStreaming;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hasThumbnail")
    private Optional<? extends GetMediaMetaDataHasThumbnail> hasThumbnail;

    /**
     * An array of streams for this part.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Stream")
    private Optional<? extends List<GetMediaMetaDataStream>> stream;

    @JsonCreator
    public GetMediaMetaDataPart(
            @JsonProperty("accessible") Optional<Boolean> accessible,
            @JsonProperty("exists") Optional<Boolean> exists,
            @JsonProperty("id") long id,
            @JsonProperty("key") String key,
            @JsonProperty("indexes") Optional<String> indexes,
            @JsonProperty("duration") Optional<Integer> duration,
            @JsonProperty("file") String file,
            @JsonProperty("size") long size,
            @JsonProperty("packetLength") Optional<Integer> packetLength,
            @JsonProperty("container") Optional<String> container,
            @JsonProperty("videoProfile") Optional<String> videoProfile,
            @JsonProperty("audioProfile") Optional<String> audioProfile,
            @JsonProperty("has64bitOffsets") Optional<Boolean> has64bitOffsets,
            @JsonProperty("optimizedForStreaming") Optional<? extends GetMediaMetaDataLibraryOptimizedForStreaming> optimizedForStreaming,
            @JsonProperty("hasThumbnail") Optional<? extends GetMediaMetaDataHasThumbnail> hasThumbnail,
            @JsonProperty("Stream") Optional<? extends List<GetMediaMetaDataStream>> stream) {
        Utils.checkNotNull(accessible, "accessible");
        Utils.checkNotNull(exists, "exists");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(indexes, "indexes");
        Utils.checkNotNull(duration, "duration");
        Utils.checkNotNull(file, "file");
        Utils.checkNotNull(size, "size");
        Utils.checkNotNull(packetLength, "packetLength");
        Utils.checkNotNull(container, "container");
        Utils.checkNotNull(videoProfile, "videoProfile");
        Utils.checkNotNull(audioProfile, "audioProfile");
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        Utils.checkNotNull(hasThumbnail, "hasThumbnail");
        Utils.checkNotNull(stream, "stream");
        this.accessible = accessible;
        this.exists = exists;
        this.id = id;
        this.key = key;
        this.indexes = indexes;
        this.duration = duration;
        this.file = file;
        this.size = size;
        this.packetLength = packetLength;
        this.container = container;
        this.videoProfile = videoProfile;
        this.audioProfile = audioProfile;
        this.has64bitOffsets = has64bitOffsets;
        this.optimizedForStreaming = optimizedForStreaming;
        this.hasThumbnail = hasThumbnail;
        this.stream = stream;
    }
    
    public GetMediaMetaDataPart(
            long id,
            String key,
            String file,
            long size) {
        this(Optional.empty(), Optional.empty(), id, key, Optional.empty(), Optional.empty(), file, size, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Indicates if the part is accessible.
     */
    @JsonIgnore
    public Optional<Boolean> accessible() {
        return accessible;
    }

    /**
     * Indicates if the part exists.
     */
    @JsonIgnore
    public Optional<Boolean> exists() {
        return exists;
    }

    /**
     * Unique part identifier.
     */
    @JsonIgnore
    public long id() {
        return id;
    }

    /**
     * Key to access this part.
     */
    @JsonIgnore
    public String key() {
        return key;
    }

    @JsonIgnore
    public Optional<String> indexes() {
        return indexes;
    }

    /**
     * Duration of the part in milliseconds.
     */
    @JsonIgnore
    public Optional<Integer> duration() {
        return duration;
    }

    /**
     * File path for the part.
     */
    @JsonIgnore
    public String file() {
        return file;
    }

    /**
     * File size in bytes.
     */
    @JsonIgnore
    public long size() {
        return size;
    }

    @JsonIgnore
    public Optional<Integer> packetLength() {
        return packetLength;
    }

    /**
     * Container format of the part.
     */
    @JsonIgnore
    public Optional<String> container() {
        return container;
    }

    /**
     * Video profile for the part.
     */
    @JsonIgnore
    public Optional<String> videoProfile() {
        return videoProfile;
    }

    /**
     * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
     */
    @JsonIgnore
    public Optional<String> audioProfile() {
        return audioProfile;
    }

    @JsonIgnore
    public Optional<Boolean> has64bitOffsets() {
        return has64bitOffsets;
    }

    /**
     * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetMediaMetaDataLibraryOptimizedForStreaming> optimizedForStreaming() {
        return (Optional<GetMediaMetaDataLibraryOptimizedForStreaming>) optimizedForStreaming;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetMediaMetaDataHasThumbnail> hasThumbnail() {
        return (Optional<GetMediaMetaDataHasThumbnail>) hasThumbnail;
    }

    /**
     * An array of streams for this part.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<GetMediaMetaDataStream>> stream() {
        return (Optional<List<GetMediaMetaDataStream>>) stream;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Indicates if the part is accessible.
     */
    public GetMediaMetaDataPart withAccessible(boolean accessible) {
        Utils.checkNotNull(accessible, "accessible");
        this.accessible = Optional.ofNullable(accessible);
        return this;
    }

    /**
     * Indicates if the part is accessible.
     */
    public GetMediaMetaDataPart withAccessible(Optional<Boolean> accessible) {
        Utils.checkNotNull(accessible, "accessible");
        this.accessible = accessible;
        return this;
    }

    /**
     * Indicates if the part exists.
     */
    public GetMediaMetaDataPart withExists(boolean exists) {
        Utils.checkNotNull(exists, "exists");
        this.exists = Optional.ofNullable(exists);
        return this;
    }

    /**
     * Indicates if the part exists.
     */
    public GetMediaMetaDataPart withExists(Optional<Boolean> exists) {
        Utils.checkNotNull(exists, "exists");
        this.exists = exists;
        return this;
    }

    /**
     * Unique part identifier.
     */
    public GetMediaMetaDataPart withId(long id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Key to access this part.
     */
    public GetMediaMetaDataPart withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    public GetMediaMetaDataPart withIndexes(String indexes) {
        Utils.checkNotNull(indexes, "indexes");
        this.indexes = Optional.ofNullable(indexes);
        return this;
    }

    public GetMediaMetaDataPart withIndexes(Optional<String> indexes) {
        Utils.checkNotNull(indexes, "indexes");
        this.indexes = indexes;
        return this;
    }

    /**
     * Duration of the part in milliseconds.
     */
    public GetMediaMetaDataPart withDuration(int duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = Optional.ofNullable(duration);
        return this;
    }

    /**
     * Duration of the part in milliseconds.
     */
    public GetMediaMetaDataPart withDuration(Optional<Integer> duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = duration;
        return this;
    }

    /**
     * File path for the part.
     */
    public GetMediaMetaDataPart withFile(String file) {
        Utils.checkNotNull(file, "file");
        this.file = file;
        return this;
    }

    /**
     * File size in bytes.
     */
    public GetMediaMetaDataPart withSize(long size) {
        Utils.checkNotNull(size, "size");
        this.size = size;
        return this;
    }

    public GetMediaMetaDataPart withPacketLength(int packetLength) {
        Utils.checkNotNull(packetLength, "packetLength");
        this.packetLength = Optional.ofNullable(packetLength);
        return this;
    }

    public GetMediaMetaDataPart withPacketLength(Optional<Integer> packetLength) {
        Utils.checkNotNull(packetLength, "packetLength");
        this.packetLength = packetLength;
        return this;
    }

    /**
     * Container format of the part.
     */
    public GetMediaMetaDataPart withContainer(String container) {
        Utils.checkNotNull(container, "container");
        this.container = Optional.ofNullable(container);
        return this;
    }

    /**
     * Container format of the part.
     */
    public GetMediaMetaDataPart withContainer(Optional<String> container) {
        Utils.checkNotNull(container, "container");
        this.container = container;
        return this;
    }

    /**
     * Video profile for the part.
     */
    public GetMediaMetaDataPart withVideoProfile(String videoProfile) {
        Utils.checkNotNull(videoProfile, "videoProfile");
        this.videoProfile = Optional.ofNullable(videoProfile);
        return this;
    }

    /**
     * Video profile for the part.
     */
    public GetMediaMetaDataPart withVideoProfile(Optional<String> videoProfile) {
        Utils.checkNotNull(videoProfile, "videoProfile");
        this.videoProfile = videoProfile;
        return this;
    }

    /**
     * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
     */
    public GetMediaMetaDataPart withAudioProfile(String audioProfile) {
        Utils.checkNotNull(audioProfile, "audioProfile");
        this.audioProfile = Optional.ofNullable(audioProfile);
        return this;
    }

    /**
     * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
     */
    public GetMediaMetaDataPart withAudioProfile(Optional<String> audioProfile) {
        Utils.checkNotNull(audioProfile, "audioProfile");
        this.audioProfile = audioProfile;
        return this;
    }

    public GetMediaMetaDataPart withHas64bitOffsets(boolean has64bitOffsets) {
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        this.has64bitOffsets = Optional.ofNullable(has64bitOffsets);
        return this;
    }

    public GetMediaMetaDataPart withHas64bitOffsets(Optional<Boolean> has64bitOffsets) {
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        this.has64bitOffsets = has64bitOffsets;
        return this;
    }

    /**
     * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
     */
    public GetMediaMetaDataPart withOptimizedForStreaming(GetMediaMetaDataLibraryOptimizedForStreaming optimizedForStreaming) {
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        this.optimizedForStreaming = Optional.ofNullable(optimizedForStreaming);
        return this;
    }

    /**
     * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
     */
    public GetMediaMetaDataPart withOptimizedForStreaming(Optional<? extends GetMediaMetaDataLibraryOptimizedForStreaming> optimizedForStreaming) {
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        this.optimizedForStreaming = optimizedForStreaming;
        return this;
    }

    public GetMediaMetaDataPart withHasThumbnail(GetMediaMetaDataHasThumbnail hasThumbnail) {
        Utils.checkNotNull(hasThumbnail, "hasThumbnail");
        this.hasThumbnail = Optional.ofNullable(hasThumbnail);
        return this;
    }

    public GetMediaMetaDataPart withHasThumbnail(Optional<? extends GetMediaMetaDataHasThumbnail> hasThumbnail) {
        Utils.checkNotNull(hasThumbnail, "hasThumbnail");
        this.hasThumbnail = hasThumbnail;
        return this;
    }

    /**
     * An array of streams for this part.
     */
    public GetMediaMetaDataPart withStream(List<GetMediaMetaDataStream> stream) {
        Utils.checkNotNull(stream, "stream");
        this.stream = Optional.ofNullable(stream);
        return this;
    }

    /**
     * An array of streams for this part.
     */
    public GetMediaMetaDataPart withStream(Optional<? extends List<GetMediaMetaDataStream>> stream) {
        Utils.checkNotNull(stream, "stream");
        this.stream = stream;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        GetMediaMetaDataPart other = (GetMediaMetaDataPart) o;
        return 
            Objects.deepEquals(this.accessible, other.accessible) &&
            Objects.deepEquals(this.exists, other.exists) &&
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.key, other.key) &&
            Objects.deepEquals(this.indexes, other.indexes) &&
            Objects.deepEquals(this.duration, other.duration) &&
            Objects.deepEquals(this.file, other.file) &&
            Objects.deepEquals(this.size, other.size) &&
            Objects.deepEquals(this.packetLength, other.packetLength) &&
            Objects.deepEquals(this.container, other.container) &&
            Objects.deepEquals(this.videoProfile, other.videoProfile) &&
            Objects.deepEquals(this.audioProfile, other.audioProfile) &&
            Objects.deepEquals(this.has64bitOffsets, other.has64bitOffsets) &&
            Objects.deepEquals(this.optimizedForStreaming, other.optimizedForStreaming) &&
            Objects.deepEquals(this.hasThumbnail, other.hasThumbnail) &&
            Objects.deepEquals(this.stream, other.stream);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            accessible,
            exists,
            id,
            key,
            indexes,
            duration,
            file,
            size,
            packetLength,
            container,
            videoProfile,
            audioProfile,
            has64bitOffsets,
            optimizedForStreaming,
            hasThumbnail,
            stream);
    }
    
    @Override
    public String toString() {
        return Utils.toString(GetMediaMetaDataPart.class,
                "accessible", accessible,
                "exists", exists,
                "id", id,
                "key", key,
                "indexes", indexes,
                "duration", duration,
                "file", file,
                "size", size,
                "packetLength", packetLength,
                "container", container,
                "videoProfile", videoProfile,
                "audioProfile", audioProfile,
                "has64bitOffsets", has64bitOffsets,
                "optimizedForStreaming", optimizedForStreaming,
                "hasThumbnail", hasThumbnail,
                "stream", stream);
    }
    
    public final static class Builder {
 
        private Optional<Boolean> accessible = Optional.empty();
 
        private Optional<Boolean> exists = Optional.empty();
 
        private Long id;
 
        private String key;
 
        private Optional<String> indexes = Optional.empty();
 
        private Optional<Integer> duration = Optional.empty();
 
        private String file;
 
        private Long size;
 
        private Optional<Integer> packetLength = Optional.empty();
 
        private Optional<String> container = Optional.empty();
 
        private Optional<String> videoProfile = Optional.empty();
 
        private Optional<String> audioProfile = Optional.empty();
 
        private Optional<Boolean> has64bitOffsets = Optional.empty();
 
        private Optional<? extends GetMediaMetaDataLibraryOptimizedForStreaming> optimizedForStreaming = Optional.empty();
 
        private Optional<? extends GetMediaMetaDataHasThumbnail> hasThumbnail;
 
        private Optional<? extends List<GetMediaMetaDataStream>> stream = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Indicates if the part is accessible.
         */
        public Builder accessible(boolean accessible) {
            Utils.checkNotNull(accessible, "accessible");
            this.accessible = Optional.ofNullable(accessible);
            return this;
        }

        /**
         * Indicates if the part is accessible.
         */
        public Builder accessible(Optional<Boolean> accessible) {
            Utils.checkNotNull(accessible, "accessible");
            this.accessible = accessible;
            return this;
        }

        /**
         * Indicates if the part exists.
         */
        public Builder exists(boolean exists) {
            Utils.checkNotNull(exists, "exists");
            this.exists = Optional.ofNullable(exists);
            return this;
        }

        /**
         * Indicates if the part exists.
         */
        public Builder exists(Optional<Boolean> exists) {
            Utils.checkNotNull(exists, "exists");
            this.exists = exists;
            return this;
        }

        /**
         * Unique part identifier.
         */
        public Builder id(long id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Key to access this part.
         */
        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }

        public Builder indexes(String indexes) {
            Utils.checkNotNull(indexes, "indexes");
            this.indexes = Optional.ofNullable(indexes);
            return this;
        }

        public Builder indexes(Optional<String> indexes) {
            Utils.checkNotNull(indexes, "indexes");
            this.indexes = indexes;
            return this;
        }

        /**
         * Duration of the part in milliseconds.
         */
        public Builder duration(int duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = Optional.ofNullable(duration);
            return this;
        }

        /**
         * Duration of the part in milliseconds.
         */
        public Builder duration(Optional<Integer> duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = duration;
            return this;
        }

        /**
         * File path for the part.
         */
        public Builder file(String file) {
            Utils.checkNotNull(file, "file");
            this.file = file;
            return this;
        }

        /**
         * File size in bytes.
         */
        public Builder size(long size) {
            Utils.checkNotNull(size, "size");
            this.size = size;
            return this;
        }

        public Builder packetLength(int packetLength) {
            Utils.checkNotNull(packetLength, "packetLength");
            this.packetLength = Optional.ofNullable(packetLength);
            return this;
        }

        public Builder packetLength(Optional<Integer> packetLength) {
            Utils.checkNotNull(packetLength, "packetLength");
            this.packetLength = packetLength;
            return this;
        }

        /**
         * Container format of the part.
         */
        public Builder container(String container) {
            Utils.checkNotNull(container, "container");
            this.container = Optional.ofNullable(container);
            return this;
        }

        /**
         * Container format of the part.
         */
        public Builder container(Optional<String> container) {
            Utils.checkNotNull(container, "container");
            this.container = container;
            return this;
        }

        /**
         * Video profile for the part.
         */
        public Builder videoProfile(String videoProfile) {
            Utils.checkNotNull(videoProfile, "videoProfile");
            this.videoProfile = Optional.ofNullable(videoProfile);
            return this;
        }

        /**
         * Video profile for the part.
         */
        public Builder videoProfile(Optional<String> videoProfile) {
            Utils.checkNotNull(videoProfile, "videoProfile");
            this.videoProfile = videoProfile;
            return this;
        }

        /**
         * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
         */
        public Builder audioProfile(String audioProfile) {
            Utils.checkNotNull(audioProfile, "audioProfile");
            this.audioProfile = Optional.ofNullable(audioProfile);
            return this;
        }

        /**
         * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
         */
        public Builder audioProfile(Optional<String> audioProfile) {
            Utils.checkNotNull(audioProfile, "audioProfile");
            this.audioProfile = audioProfile;
            return this;
        }

        public Builder has64bitOffsets(boolean has64bitOffsets) {
            Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
            this.has64bitOffsets = Optional.ofNullable(has64bitOffsets);
            return this;
        }

        public Builder has64bitOffsets(Optional<Boolean> has64bitOffsets) {
            Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
            this.has64bitOffsets = has64bitOffsets;
            return this;
        }

        /**
         * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
         */
        public Builder optimizedForStreaming(GetMediaMetaDataLibraryOptimizedForStreaming optimizedForStreaming) {
            Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
            this.optimizedForStreaming = Optional.ofNullable(optimizedForStreaming);
            return this;
        }

        /**
         * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
         */
        public Builder optimizedForStreaming(Optional<? extends GetMediaMetaDataLibraryOptimizedForStreaming> optimizedForStreaming) {
            Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
            this.optimizedForStreaming = optimizedForStreaming;
            return this;
        }

        public Builder hasThumbnail(GetMediaMetaDataHasThumbnail hasThumbnail) {
            Utils.checkNotNull(hasThumbnail, "hasThumbnail");
            this.hasThumbnail = Optional.ofNullable(hasThumbnail);
            return this;
        }

        public Builder hasThumbnail(Optional<? extends GetMediaMetaDataHasThumbnail> hasThumbnail) {
            Utils.checkNotNull(hasThumbnail, "hasThumbnail");
            this.hasThumbnail = hasThumbnail;
            return this;
        }

        /**
         * An array of streams for this part.
         */
        public Builder stream(List<GetMediaMetaDataStream> stream) {
            Utils.checkNotNull(stream, "stream");
            this.stream = Optional.ofNullable(stream);
            return this;
        }

        /**
         * An array of streams for this part.
         */
        public Builder stream(Optional<? extends List<GetMediaMetaDataStream>> stream) {
            Utils.checkNotNull(stream, "stream");
            this.stream = stream;
            return this;
        }
        
        public GetMediaMetaDataPart build() {
            if (hasThumbnail == null) {
                hasThumbnail = _SINGLETON_VALUE_HasThumbnail.value();
            }            return new GetMediaMetaDataPart(
                accessible,
                exists,
                id,
                key,
                indexes,
                duration,
                file,
                size,
                packetLength,
                container,
                videoProfile,
                audioProfile,
                has64bitOffsets,
                optimizedForStreaming,
                hasThumbnail,
                stream);
        }

        private static final LazySingletonValue<Optional<? extends GetMediaMetaDataHasThumbnail>> _SINGLETON_VALUE_HasThumbnail =
                new LazySingletonValue<>(
                        "hasThumbnail",
                        "\"0\"",
                        new TypeReference<Optional<? extends GetMediaMetaDataHasThumbnail>>() {});
    }
}

