/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Part
 * 
 * <p>`Part` represents a particular file or "part" of a media item. The part is the playable unit of the media hierarchy. Suppose that a movie library contains a movie that is broken up into files, reminiscent of a movie split across two BDs. The metadata item represents information about the movie, the media item represents this instance of the movie at this resolution and quality, and the part items represent the two playable files.  If another media were added which contained the joining of these two parts transcoded down to a lower resolution, then this metadata would contain 2 medias, one with 2 parts and one with 1 part.
 */
public class Part {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("audioProfile")
    private Optional<? extends Object> audioProfile;

    /**
     * The container of the media file, such as `mp4` or `mkv`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("container")
    private Optional<? extends Object> container;

    /**
     * The duration of the media item, in milliseconds
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("duration")
    private Optional<Long> duration;

    /**
     * The local file path at which the part is stored on the server
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("file")
    private Optional<? extends Object> file;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("has64bitOffsets")
    private Optional<Boolean> has64bitOffsets;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<Long> id;

    /**
     * The key from which the media can be streamed
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("key")
    private Optional<? extends Object> key;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("optimizedForStreaming")
    private Optional<Boolean> optimizedForStreaming;

    /**
     * The size of the media, in bytes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("size")
    private Optional<Long> size;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Stream")
    private Optional<? extends List<Stream>> stream;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("videoProfile")
    private Optional<? extends Object> videoProfile;


    @JsonIgnore
    private Map<String, Object> additionalProperties;

    @JsonCreator
    public Part(
            @JsonProperty("audioProfile") Optional<? extends Object> audioProfile,
            @JsonProperty("container") Optional<? extends Object> container,
            @JsonProperty("duration") Optional<Long> duration,
            @JsonProperty("file") Optional<? extends Object> file,
            @JsonProperty("has64bitOffsets") Optional<Boolean> has64bitOffsets,
            @JsonProperty("id") Optional<Long> id,
            @JsonProperty("key") Optional<? extends Object> key,
            @JsonProperty("optimizedForStreaming") Optional<Boolean> optimizedForStreaming,
            @JsonProperty("size") Optional<Long> size,
            @JsonProperty("Stream") Optional<? extends List<Stream>> stream,
            @JsonProperty("videoProfile") Optional<? extends Object> videoProfile) {
        Utils.checkNotNull(audioProfile, "audioProfile");
        Utils.checkNotNull(container, "container");
        Utils.checkNotNull(duration, "duration");
        Utils.checkNotNull(file, "file");
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        Utils.checkNotNull(size, "size");
        Utils.checkNotNull(stream, "stream");
        Utils.checkNotNull(videoProfile, "videoProfile");
        this.audioProfile = audioProfile;
        this.container = container;
        this.duration = duration;
        this.file = file;
        this.has64bitOffsets = has64bitOffsets;
        this.id = id;
        this.key = key;
        this.optimizedForStreaming = optimizedForStreaming;
        this.size = size;
        this.stream = stream;
        this.videoProfile = videoProfile;
        this.additionalProperties = new HashMap<>();
    }
    
    public Part() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty());
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> audioProfile() {
        return (Optional<Object>) audioProfile;
    }

    /**
     * The container of the media file, such as `mp4` or `mkv`
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> container() {
        return (Optional<Object>) container;
    }

    /**
     * The duration of the media item, in milliseconds
     */
    @JsonIgnore
    public Optional<Long> duration() {
        return duration;
    }

    /**
     * The local file path at which the part is stored on the server
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> file() {
        return (Optional<Object>) file;
    }

    @JsonIgnore
    public Optional<Boolean> has64bitOffsets() {
        return has64bitOffsets;
    }

    @JsonIgnore
    public Optional<Long> id() {
        return id;
    }

    /**
     * The key from which the media can be streamed
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> key() {
        return (Optional<Object>) key;
    }

    @JsonIgnore
    public Optional<Boolean> optimizedForStreaming() {
        return optimizedForStreaming;
    }

    /**
     * The size of the media, in bytes
     */
    @JsonIgnore
    public Optional<Long> size() {
        return size;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Stream>> stream() {
        return (Optional<List<Stream>>) stream;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> videoProfile() {
        return (Optional<Object>) videoProfile;
    }

    @JsonAnyGetter
    public Map<String, Object> additionalProperties() {
        return additionalProperties;
    }

    public static Builder builder() {
        return new Builder();
    }


    public Part withAudioProfile(Object audioProfile) {
        Utils.checkNotNull(audioProfile, "audioProfile");
        this.audioProfile = Optional.ofNullable(audioProfile);
        return this;
    }


    public Part withAudioProfile(Optional<? extends Object> audioProfile) {
        Utils.checkNotNull(audioProfile, "audioProfile");
        this.audioProfile = audioProfile;
        return this;
    }

    /**
     * The container of the media file, such as `mp4` or `mkv`
     */
    public Part withContainer(Object container) {
        Utils.checkNotNull(container, "container");
        this.container = Optional.ofNullable(container);
        return this;
    }


    /**
     * The container of the media file, such as `mp4` or `mkv`
     */
    public Part withContainer(Optional<? extends Object> container) {
        Utils.checkNotNull(container, "container");
        this.container = container;
        return this;
    }

    /**
     * The duration of the media item, in milliseconds
     */
    public Part withDuration(long duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = Optional.ofNullable(duration);
        return this;
    }


    /**
     * The duration of the media item, in milliseconds
     */
    public Part withDuration(Optional<Long> duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = duration;
        return this;
    }

    /**
     * The local file path at which the part is stored on the server
     */
    public Part withFile(Object file) {
        Utils.checkNotNull(file, "file");
        this.file = Optional.ofNullable(file);
        return this;
    }


    /**
     * The local file path at which the part is stored on the server
     */
    public Part withFile(Optional<? extends Object> file) {
        Utils.checkNotNull(file, "file");
        this.file = file;
        return this;
    }

    public Part withHas64bitOffsets(boolean has64bitOffsets) {
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        this.has64bitOffsets = Optional.ofNullable(has64bitOffsets);
        return this;
    }


    public Part withHas64bitOffsets(Optional<Boolean> has64bitOffsets) {
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        this.has64bitOffsets = has64bitOffsets;
        return this;
    }

    public Part withId(long id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }


    public Part withId(Optional<Long> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * The key from which the media can be streamed
     */
    public Part withKey(Object key) {
        Utils.checkNotNull(key, "key");
        this.key = Optional.ofNullable(key);
        return this;
    }


    /**
     * The key from which the media can be streamed
     */
    public Part withKey(Optional<? extends Object> key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    public Part withOptimizedForStreaming(boolean optimizedForStreaming) {
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        this.optimizedForStreaming = Optional.ofNullable(optimizedForStreaming);
        return this;
    }


    public Part withOptimizedForStreaming(Optional<Boolean> optimizedForStreaming) {
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        this.optimizedForStreaming = optimizedForStreaming;
        return this;
    }

    /**
     * The size of the media, in bytes
     */
    public Part withSize(long size) {
        Utils.checkNotNull(size, "size");
        this.size = Optional.ofNullable(size);
        return this;
    }


    /**
     * The size of the media, in bytes
     */
    public Part withSize(Optional<Long> size) {
        Utils.checkNotNull(size, "size");
        this.size = size;
        return this;
    }

    public Part withStream(List<Stream> stream) {
        Utils.checkNotNull(stream, "stream");
        this.stream = Optional.ofNullable(stream);
        return this;
    }


    public Part withStream(Optional<? extends List<Stream>> stream) {
        Utils.checkNotNull(stream, "stream");
        this.stream = stream;
        return this;
    }

    public Part withVideoProfile(Object videoProfile) {
        Utils.checkNotNull(videoProfile, "videoProfile");
        this.videoProfile = Optional.ofNullable(videoProfile);
        return this;
    }


    public Part withVideoProfile(Optional<? extends Object> videoProfile) {
        Utils.checkNotNull(videoProfile, "videoProfile");
        this.videoProfile = videoProfile;
        return this;
    }

    @JsonAnySetter
    public Part withAdditionalProperty(String key, Object value) {
        // note that value can be null because of the way JsonAnySetter works
        Utils.checkNotNull(key, "key");
        additionalProperties.put(key, value); 
        return this;
    }
    public Part withAdditionalProperties(Map<String, Object> additionalProperties) {
        Utils.checkNotNull(additionalProperties, "additionalProperties");
        this.additionalProperties = additionalProperties;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Part other = (Part) o;
        return 
            Utils.enhancedDeepEquals(this.audioProfile, other.audioProfile) &&
            Utils.enhancedDeepEquals(this.container, other.container) &&
            Utils.enhancedDeepEquals(this.duration, other.duration) &&
            Utils.enhancedDeepEquals(this.file, other.file) &&
            Utils.enhancedDeepEquals(this.has64bitOffsets, other.has64bitOffsets) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.optimizedForStreaming, other.optimizedForStreaming) &&
            Utils.enhancedDeepEquals(this.size, other.size) &&
            Utils.enhancedDeepEquals(this.stream, other.stream) &&
            Utils.enhancedDeepEquals(this.videoProfile, other.videoProfile) &&
            Utils.enhancedDeepEquals(this.additionalProperties, other.additionalProperties);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            audioProfile, container, duration,
            file, has64bitOffsets, id,
            key, optimizedForStreaming, size,
            stream, videoProfile, additionalProperties);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Part.class,
                "audioProfile", audioProfile,
                "container", container,
                "duration", duration,
                "file", file,
                "has64bitOffsets", has64bitOffsets,
                "id", id,
                "key", key,
                "optimizedForStreaming", optimizedForStreaming,
                "size", size,
                "stream", stream,
                "videoProfile", videoProfile,
                "additionalProperties", additionalProperties);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends Object> audioProfile = Optional.empty();

        private Optional<? extends Object> container = Optional.empty();

        private Optional<Long> duration = Optional.empty();

        private Optional<? extends Object> file = Optional.empty();

        private Optional<Boolean> has64bitOffsets = Optional.empty();

        private Optional<Long> id = Optional.empty();

        private Optional<? extends Object> key = Optional.empty();

        private Optional<Boolean> optimizedForStreaming = Optional.empty();

        private Optional<Long> size = Optional.empty();

        private Optional<? extends List<Stream>> stream = Optional.empty();

        private Optional<? extends Object> videoProfile = Optional.empty();

        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {
          // force use of static builder() method
        }


        public Builder audioProfile(Object audioProfile) {
            Utils.checkNotNull(audioProfile, "audioProfile");
            this.audioProfile = Optional.ofNullable(audioProfile);
            return this;
        }

        public Builder audioProfile(Optional<? extends Object> audioProfile) {
            Utils.checkNotNull(audioProfile, "audioProfile");
            this.audioProfile = audioProfile;
            return this;
        }


        /**
         * The container of the media file, such as `mp4` or `mkv`
         */
        public Builder container(Object container) {
            Utils.checkNotNull(container, "container");
            this.container = Optional.ofNullable(container);
            return this;
        }

        /**
         * The container of the media file, such as `mp4` or `mkv`
         */
        public Builder container(Optional<? extends Object> container) {
            Utils.checkNotNull(container, "container");
            this.container = container;
            return this;
        }


        /**
         * The duration of the media item, in milliseconds
         */
        public Builder duration(long duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = Optional.ofNullable(duration);
            return this;
        }

        /**
         * The duration of the media item, in milliseconds
         */
        public Builder duration(Optional<Long> duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = duration;
            return this;
        }


        /**
         * The local file path at which the part is stored on the server
         */
        public Builder file(Object file) {
            Utils.checkNotNull(file, "file");
            this.file = Optional.ofNullable(file);
            return this;
        }

        /**
         * The local file path at which the part is stored on the server
         */
        public Builder file(Optional<? extends Object> file) {
            Utils.checkNotNull(file, "file");
            this.file = file;
            return this;
        }


        public Builder has64bitOffsets(boolean has64bitOffsets) {
            Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
            this.has64bitOffsets = Optional.ofNullable(has64bitOffsets);
            return this;
        }

        public Builder has64bitOffsets(Optional<Boolean> has64bitOffsets) {
            Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
            this.has64bitOffsets = has64bitOffsets;
            return this;
        }


        public Builder id(long id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        public Builder id(Optional<Long> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * The key from which the media can be streamed
         */
        public Builder key(Object key) {
            Utils.checkNotNull(key, "key");
            this.key = Optional.ofNullable(key);
            return this;
        }

        /**
         * The key from which the media can be streamed
         */
        public Builder key(Optional<? extends Object> key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        public Builder optimizedForStreaming(boolean optimizedForStreaming) {
            Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
            this.optimizedForStreaming = Optional.ofNullable(optimizedForStreaming);
            return this;
        }

        public Builder optimizedForStreaming(Optional<Boolean> optimizedForStreaming) {
            Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
            this.optimizedForStreaming = optimizedForStreaming;
            return this;
        }


        /**
         * The size of the media, in bytes
         */
        public Builder size(long size) {
            Utils.checkNotNull(size, "size");
            this.size = Optional.ofNullable(size);
            return this;
        }

        /**
         * The size of the media, in bytes
         */
        public Builder size(Optional<Long> size) {
            Utils.checkNotNull(size, "size");
            this.size = size;
            return this;
        }


        public Builder stream(List<Stream> stream) {
            Utils.checkNotNull(stream, "stream");
            this.stream = Optional.ofNullable(stream);
            return this;
        }

        public Builder stream(Optional<? extends List<Stream>> stream) {
            Utils.checkNotNull(stream, "stream");
            this.stream = stream;
            return this;
        }


        public Builder videoProfile(Object videoProfile) {
            Utils.checkNotNull(videoProfile, "videoProfile");
            this.videoProfile = Optional.ofNullable(videoProfile);
            return this;
        }

        public Builder videoProfile(Optional<? extends Object> videoProfile) {
            Utils.checkNotNull(videoProfile, "videoProfile");
            this.videoProfile = videoProfile;
            return this;
        }

        public Builder additionalProperty(String key, Object value) {
            Utils.checkNotNull(key, "key");
            // we could be strict about null values (force the user
            // to pass `JsonNullable.of(null)`) but likely to be a bit 
            // annoying for additional properties building so we'll 
            // relax preconditions.
            this.additionalProperties.put(key, value);
            return this;
        }

        public Builder additionalProperties(Map<String, Object> additionalProperties) {
            Utils.checkNotNull(additionalProperties, "additionalProperties");
            this.additionalProperties = additionalProperties;
            return this;
        }

        public Part build() {

            return new Part(
                audioProfile, container, duration,
                file, has64bitOffsets, id,
                key, optimizedForStreaming, size,
                stream, videoProfile)
                .withAdditionalProperties(additionalProperties);
        }

    }
}
