/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Double;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;

/**
 * MediaGrabOperation
 * 
 * <p>A media grab opration represents a scheduled or active recording of media
 */
public class MediaGrabOperation {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currentSize")
    private Optional<Long> currentSize;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grabberIdentifier")
    private Optional<String> grabberIdentifier;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grabberProtocol")
    private Optional<String> grabberProtocol;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("key")
    private Optional<String> key;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mediaIndex")
    private Optional<Long> mediaIndex;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mediaSubscriptionID")
    private Optional<Long> mediaSubscriptionID;

    /**
     * Items in a library are referred to as "metadata items." These metadata items are distinct from "media items" which represent actual instances of media that can be consumed. Consider a TV library that has a single video file in it for a particular episode of a show. The library has a single media item, but it has three metadata items: one for the show, one for the season, and one for the episode. Consider a movie library that has two video files in it: the same movie, but two different resolutions. The library has a single metadata item for the movie, but that metadata item has two media items, one for each resolution. Additionally a "media item" will have one or more "media parts" where the the parts are intended to be watched together, such as a CD1 and CD2 parts of the same movie.
     * 
     * <p>Note that when a metadata item has multiple media items, those media items should be isomorphic. That is, a 4K version and 1080p version of a movie are different versions of the same movie. They have the same duration, same summary, same rating, etc. and they can generally be considered interchangeable. A theatrical release vs. director's cut vs. unrated version on the other hand would be separate metadata items.
     * 
     * <p>Metadata items can often live in a hierarchy with relationships between them.  For example, the metadata item for an episodes is associated with a season metadata item which is associated with a show metadata item.  A similar hierarchy exists with track, album, and artist and photos and photo album.  The relationships may be expressed via relative terms and absolute terms.  For example, "leaves" refer to metadata items which has associated media (there is no media for a season nor show).  A show will have "children" in the form of seasons and a season will have "children" in the form of episodes and episodes have "parent" in the form of a season which has a "parent" in the form of a show.  Similarly, a show has "grandchildren" in the form of episodse and an episode has a "grandparent" in the form of a show.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Metadata")
    private Optional<? extends Metadata> metadata;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("percent")
    private Optional<Double> percent;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("provider")
    private Optional<String> provider;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends Status> status;

    @JsonCreator
    public MediaGrabOperation(
            @JsonProperty("currentSize") Optional<Long> currentSize,
            @JsonProperty("grabberIdentifier") Optional<String> grabberIdentifier,
            @JsonProperty("grabberProtocol") Optional<String> grabberProtocol,
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("key") Optional<String> key,
            @JsonProperty("mediaIndex") Optional<Long> mediaIndex,
            @JsonProperty("mediaSubscriptionID") Optional<Long> mediaSubscriptionID,
            @JsonProperty("Metadata") Optional<? extends Metadata> metadata,
            @JsonProperty("percent") Optional<Double> percent,
            @JsonProperty("provider") Optional<String> provider,
            @JsonProperty("status") Optional<? extends Status> status) {
        Utils.checkNotNull(currentSize, "currentSize");
        Utils.checkNotNull(grabberIdentifier, "grabberIdentifier");
        Utils.checkNotNull(grabberProtocol, "grabberProtocol");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(mediaIndex, "mediaIndex");
        Utils.checkNotNull(mediaSubscriptionID, "mediaSubscriptionID");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(percent, "percent");
        Utils.checkNotNull(provider, "provider");
        Utils.checkNotNull(status, "status");
        this.currentSize = currentSize;
        this.grabberIdentifier = grabberIdentifier;
        this.grabberProtocol = grabberProtocol;
        this.id = id;
        this.key = key;
        this.mediaIndex = mediaIndex;
        this.mediaSubscriptionID = mediaSubscriptionID;
        this.metadata = metadata;
        this.percent = percent;
        this.provider = provider;
        this.status = status;
    }
    
    public MediaGrabOperation() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty());
    }

    @JsonIgnore
    public Optional<Long> currentSize() {
        return currentSize;
    }

    @JsonIgnore
    public Optional<String> grabberIdentifier() {
        return grabberIdentifier;
    }

    @JsonIgnore
    public Optional<String> grabberProtocol() {
        return grabberProtocol;
    }

    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    @JsonIgnore
    public Optional<String> key() {
        return key;
    }

    @JsonIgnore
    public Optional<Long> mediaIndex() {
        return mediaIndex;
    }

    @JsonIgnore
    public Optional<Long> mediaSubscriptionID() {
        return mediaSubscriptionID;
    }

    /**
     * Items in a library are referred to as "metadata items." These metadata items are distinct from "media items" which represent actual instances of media that can be consumed. Consider a TV library that has a single video file in it for a particular episode of a show. The library has a single media item, but it has three metadata items: one for the show, one for the season, and one for the episode. Consider a movie library that has two video files in it: the same movie, but two different resolutions. The library has a single metadata item for the movie, but that metadata item has two media items, one for each resolution. Additionally a "media item" will have one or more "media parts" where the the parts are intended to be watched together, such as a CD1 and CD2 parts of the same movie.
     * 
     * <p>Note that when a metadata item has multiple media items, those media items should be isomorphic. That is, a 4K version and 1080p version of a movie are different versions of the same movie. They have the same duration, same summary, same rating, etc. and they can generally be considered interchangeable. A theatrical release vs. director's cut vs. unrated version on the other hand would be separate metadata items.
     * 
     * <p>Metadata items can often live in a hierarchy with relationships between them.  For example, the metadata item for an episodes is associated with a season metadata item which is associated with a show metadata item.  A similar hierarchy exists with track, album, and artist and photos and photo album.  The relationships may be expressed via relative terms and absolute terms.  For example, "leaves" refer to metadata items which has associated media (there is no media for a season nor show).  A show will have "children" in the form of seasons and a season will have "children" in the form of episodes and episodes have "parent" in the form of a season which has a "parent" in the form of a show.  Similarly, a show has "grandchildren" in the form of episodse and an episode has a "grandparent" in the form of a show.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Metadata> metadata() {
        return (Optional<Metadata>) metadata;
    }

    @JsonIgnore
    public Optional<Double> percent() {
        return percent;
    }

    @JsonIgnore
    public Optional<String> provider() {
        return provider;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Status> status() {
        return (Optional<Status>) status;
    }

    public static Builder builder() {
        return new Builder();
    }


    public MediaGrabOperation withCurrentSize(long currentSize) {
        Utils.checkNotNull(currentSize, "currentSize");
        this.currentSize = Optional.ofNullable(currentSize);
        return this;
    }


    public MediaGrabOperation withCurrentSize(Optional<Long> currentSize) {
        Utils.checkNotNull(currentSize, "currentSize");
        this.currentSize = currentSize;
        return this;
    }

    public MediaGrabOperation withGrabberIdentifier(String grabberIdentifier) {
        Utils.checkNotNull(grabberIdentifier, "grabberIdentifier");
        this.grabberIdentifier = Optional.ofNullable(grabberIdentifier);
        return this;
    }


    public MediaGrabOperation withGrabberIdentifier(Optional<String> grabberIdentifier) {
        Utils.checkNotNull(grabberIdentifier, "grabberIdentifier");
        this.grabberIdentifier = grabberIdentifier;
        return this;
    }

    public MediaGrabOperation withGrabberProtocol(String grabberProtocol) {
        Utils.checkNotNull(grabberProtocol, "grabberProtocol");
        this.grabberProtocol = Optional.ofNullable(grabberProtocol);
        return this;
    }


    public MediaGrabOperation withGrabberProtocol(Optional<String> grabberProtocol) {
        Utils.checkNotNull(grabberProtocol, "grabberProtocol");
        this.grabberProtocol = grabberProtocol;
        return this;
    }

    public MediaGrabOperation withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }


    public MediaGrabOperation withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    public MediaGrabOperation withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = Optional.ofNullable(key);
        return this;
    }


    public MediaGrabOperation withKey(Optional<String> key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    public MediaGrabOperation withMediaIndex(long mediaIndex) {
        Utils.checkNotNull(mediaIndex, "mediaIndex");
        this.mediaIndex = Optional.ofNullable(mediaIndex);
        return this;
    }


    public MediaGrabOperation withMediaIndex(Optional<Long> mediaIndex) {
        Utils.checkNotNull(mediaIndex, "mediaIndex");
        this.mediaIndex = mediaIndex;
        return this;
    }

    public MediaGrabOperation withMediaSubscriptionID(long mediaSubscriptionID) {
        Utils.checkNotNull(mediaSubscriptionID, "mediaSubscriptionID");
        this.mediaSubscriptionID = Optional.ofNullable(mediaSubscriptionID);
        return this;
    }


    public MediaGrabOperation withMediaSubscriptionID(Optional<Long> mediaSubscriptionID) {
        Utils.checkNotNull(mediaSubscriptionID, "mediaSubscriptionID");
        this.mediaSubscriptionID = mediaSubscriptionID;
        return this;
    }

    /**
     * Items in a library are referred to as "metadata items." These metadata items are distinct from "media items" which represent actual instances of media that can be consumed. Consider a TV library that has a single video file in it for a particular episode of a show. The library has a single media item, but it has three metadata items: one for the show, one for the season, and one for the episode. Consider a movie library that has two video files in it: the same movie, but two different resolutions. The library has a single metadata item for the movie, but that metadata item has two media items, one for each resolution. Additionally a "media item" will have one or more "media parts" where the the parts are intended to be watched together, such as a CD1 and CD2 parts of the same movie.
     * 
     * <p>Note that when a metadata item has multiple media items, those media items should be isomorphic. That is, a 4K version and 1080p version of a movie are different versions of the same movie. They have the same duration, same summary, same rating, etc. and they can generally be considered interchangeable. A theatrical release vs. director's cut vs. unrated version on the other hand would be separate metadata items.
     * 
     * <p>Metadata items can often live in a hierarchy with relationships between them.  For example, the metadata item for an episodes is associated with a season metadata item which is associated with a show metadata item.  A similar hierarchy exists with track, album, and artist and photos and photo album.  The relationships may be expressed via relative terms and absolute terms.  For example, "leaves" refer to metadata items which has associated media (there is no media for a season nor show).  A show will have "children" in the form of seasons and a season will have "children" in the form of episodes and episodes have "parent" in the form of a season which has a "parent" in the form of a show.  Similarly, a show has "grandchildren" in the form of episodse and an episode has a "grandparent" in the form of a show.
     */
    public MediaGrabOperation withMetadata(Metadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }


    /**
     * Items in a library are referred to as "metadata items." These metadata items are distinct from "media items" which represent actual instances of media that can be consumed. Consider a TV library that has a single video file in it for a particular episode of a show. The library has a single media item, but it has three metadata items: one for the show, one for the season, and one for the episode. Consider a movie library that has two video files in it: the same movie, but two different resolutions. The library has a single metadata item for the movie, but that metadata item has two media items, one for each resolution. Additionally a "media item" will have one or more "media parts" where the the parts are intended to be watched together, such as a CD1 and CD2 parts of the same movie.
     * 
     * <p>Note that when a metadata item has multiple media items, those media items should be isomorphic. That is, a 4K version and 1080p version of a movie are different versions of the same movie. They have the same duration, same summary, same rating, etc. and they can generally be considered interchangeable. A theatrical release vs. director's cut vs. unrated version on the other hand would be separate metadata items.
     * 
     * <p>Metadata items can often live in a hierarchy with relationships between them.  For example, the metadata item for an episodes is associated with a season metadata item which is associated with a show metadata item.  A similar hierarchy exists with track, album, and artist and photos and photo album.  The relationships may be expressed via relative terms and absolute terms.  For example, "leaves" refer to metadata items which has associated media (there is no media for a season nor show).  A show will have "children" in the form of seasons and a season will have "children" in the form of episodes and episodes have "parent" in the form of a season which has a "parent" in the form of a show.  Similarly, a show has "grandchildren" in the form of episodse and an episode has a "grandparent" in the form of a show.
     */
    public MediaGrabOperation withMetadata(Optional<? extends Metadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    public MediaGrabOperation withPercent(double percent) {
        Utils.checkNotNull(percent, "percent");
        this.percent = Optional.ofNullable(percent);
        return this;
    }


    public MediaGrabOperation withPercent(Optional<Double> percent) {
        Utils.checkNotNull(percent, "percent");
        this.percent = percent;
        return this;
    }

    public MediaGrabOperation withProvider(String provider) {
        Utils.checkNotNull(provider, "provider");
        this.provider = Optional.ofNullable(provider);
        return this;
    }


    public MediaGrabOperation withProvider(Optional<String> provider) {
        Utils.checkNotNull(provider, "provider");
        this.provider = provider;
        return this;
    }

    public MediaGrabOperation withStatus(Status status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }


    public MediaGrabOperation withStatus(Optional<? extends Status> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        MediaGrabOperation other = (MediaGrabOperation) o;
        return 
            Utils.enhancedDeepEquals(this.currentSize, other.currentSize) &&
            Utils.enhancedDeepEquals(this.grabberIdentifier, other.grabberIdentifier) &&
            Utils.enhancedDeepEquals(this.grabberProtocol, other.grabberProtocol) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.mediaIndex, other.mediaIndex) &&
            Utils.enhancedDeepEquals(this.mediaSubscriptionID, other.mediaSubscriptionID) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.percent, other.percent) &&
            Utils.enhancedDeepEquals(this.provider, other.provider) &&
            Utils.enhancedDeepEquals(this.status, other.status);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            currentSize, grabberIdentifier, grabberProtocol,
            id, key, mediaIndex,
            mediaSubscriptionID, metadata, percent,
            provider, status);
    }
    
    @Override
    public String toString() {
        return Utils.toString(MediaGrabOperation.class,
                "currentSize", currentSize,
                "grabberIdentifier", grabberIdentifier,
                "grabberProtocol", grabberProtocol,
                "id", id,
                "key", key,
                "mediaIndex", mediaIndex,
                "mediaSubscriptionID", mediaSubscriptionID,
                "metadata", metadata,
                "percent", percent,
                "provider", provider,
                "status", status);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<Long> currentSize = Optional.empty();

        private Optional<String> grabberIdentifier = Optional.empty();

        private Optional<String> grabberProtocol = Optional.empty();

        private Optional<String> id = Optional.empty();

        private Optional<String> key = Optional.empty();

        private Optional<Long> mediaIndex = Optional.empty();

        private Optional<Long> mediaSubscriptionID = Optional.empty();

        private Optional<? extends Metadata> metadata = Optional.empty();

        private Optional<Double> percent = Optional.empty();

        private Optional<String> provider = Optional.empty();

        private Optional<? extends Status> status = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        public Builder currentSize(long currentSize) {
            Utils.checkNotNull(currentSize, "currentSize");
            this.currentSize = Optional.ofNullable(currentSize);
            return this;
        }

        public Builder currentSize(Optional<Long> currentSize) {
            Utils.checkNotNull(currentSize, "currentSize");
            this.currentSize = currentSize;
            return this;
        }


        public Builder grabberIdentifier(String grabberIdentifier) {
            Utils.checkNotNull(grabberIdentifier, "grabberIdentifier");
            this.grabberIdentifier = Optional.ofNullable(grabberIdentifier);
            return this;
        }

        public Builder grabberIdentifier(Optional<String> grabberIdentifier) {
            Utils.checkNotNull(grabberIdentifier, "grabberIdentifier");
            this.grabberIdentifier = grabberIdentifier;
            return this;
        }


        public Builder grabberProtocol(String grabberProtocol) {
            Utils.checkNotNull(grabberProtocol, "grabberProtocol");
            this.grabberProtocol = Optional.ofNullable(grabberProtocol);
            return this;
        }

        public Builder grabberProtocol(Optional<String> grabberProtocol) {
            Utils.checkNotNull(grabberProtocol, "grabberProtocol");
            this.grabberProtocol = grabberProtocol;
            return this;
        }


        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = Optional.ofNullable(key);
            return this;
        }

        public Builder key(Optional<String> key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        public Builder mediaIndex(long mediaIndex) {
            Utils.checkNotNull(mediaIndex, "mediaIndex");
            this.mediaIndex = Optional.ofNullable(mediaIndex);
            return this;
        }

        public Builder mediaIndex(Optional<Long> mediaIndex) {
            Utils.checkNotNull(mediaIndex, "mediaIndex");
            this.mediaIndex = mediaIndex;
            return this;
        }


        public Builder mediaSubscriptionID(long mediaSubscriptionID) {
            Utils.checkNotNull(mediaSubscriptionID, "mediaSubscriptionID");
            this.mediaSubscriptionID = Optional.ofNullable(mediaSubscriptionID);
            return this;
        }

        public Builder mediaSubscriptionID(Optional<Long> mediaSubscriptionID) {
            Utils.checkNotNull(mediaSubscriptionID, "mediaSubscriptionID");
            this.mediaSubscriptionID = mediaSubscriptionID;
            return this;
        }


        /**
         * Items in a library are referred to as "metadata items." These metadata items are distinct from "media items" which represent actual instances of media that can be consumed. Consider a TV library that has a single video file in it for a particular episode of a show. The library has a single media item, but it has three metadata items: one for the show, one for the season, and one for the episode. Consider a movie library that has two video files in it: the same movie, but two different resolutions. The library has a single metadata item for the movie, but that metadata item has two media items, one for each resolution. Additionally a "media item" will have one or more "media parts" where the the parts are intended to be watched together, such as a CD1 and CD2 parts of the same movie.
         * 
         * <p>Note that when a metadata item has multiple media items, those media items should be isomorphic. That is, a 4K version and 1080p version of a movie are different versions of the same movie. They have the same duration, same summary, same rating, etc. and they can generally be considered interchangeable. A theatrical release vs. director's cut vs. unrated version on the other hand would be separate metadata items.
         * 
         * <p>Metadata items can often live in a hierarchy with relationships between them.  For example, the metadata item for an episodes is associated with a season metadata item which is associated with a show metadata item.  A similar hierarchy exists with track, album, and artist and photos and photo album.  The relationships may be expressed via relative terms and absolute terms.  For example, "leaves" refer to metadata items which has associated media (there is no media for a season nor show).  A show will have "children" in the form of seasons and a season will have "children" in the form of episodes and episodes have "parent" in the form of a season which has a "parent" in the form of a show.  Similarly, a show has "grandchildren" in the form of episodse and an episode has a "grandparent" in the form of a show.
         */
        public Builder metadata(Metadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        /**
         * Items in a library are referred to as "metadata items." These metadata items are distinct from "media items" which represent actual instances of media that can be consumed. Consider a TV library that has a single video file in it for a particular episode of a show. The library has a single media item, but it has three metadata items: one for the show, one for the season, and one for the episode. Consider a movie library that has two video files in it: the same movie, but two different resolutions. The library has a single metadata item for the movie, but that metadata item has two media items, one for each resolution. Additionally a "media item" will have one or more "media parts" where the the parts are intended to be watched together, such as a CD1 and CD2 parts of the same movie.
         * 
         * <p>Note that when a metadata item has multiple media items, those media items should be isomorphic. That is, a 4K version and 1080p version of a movie are different versions of the same movie. They have the same duration, same summary, same rating, etc. and they can generally be considered interchangeable. A theatrical release vs. director's cut vs. unrated version on the other hand would be separate metadata items.
         * 
         * <p>Metadata items can often live in a hierarchy with relationships between them.  For example, the metadata item for an episodes is associated with a season metadata item which is associated with a show metadata item.  A similar hierarchy exists with track, album, and artist and photos and photo album.  The relationships may be expressed via relative terms and absolute terms.  For example, "leaves" refer to metadata items which has associated media (there is no media for a season nor show).  A show will have "children" in the form of seasons and a season will have "children" in the form of episodes and episodes have "parent" in the form of a season which has a "parent" in the form of a show.  Similarly, a show has "grandchildren" in the form of episodse and an episode has a "grandparent" in the form of a show.
         */
        public Builder metadata(Optional<? extends Metadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }


        public Builder percent(double percent) {
            Utils.checkNotNull(percent, "percent");
            this.percent = Optional.ofNullable(percent);
            return this;
        }

        public Builder percent(Optional<Double> percent) {
            Utils.checkNotNull(percent, "percent");
            this.percent = percent;
            return this;
        }


        public Builder provider(String provider) {
            Utils.checkNotNull(provider, "provider");
            this.provider = Optional.ofNullable(provider);
            return this;
        }

        public Builder provider(Optional<String> provider) {
            Utils.checkNotNull(provider, "provider");
            this.provider = provider;
            return this;
        }


        public Builder status(Status status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        public Builder status(Optional<? extends Status> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        public MediaGrabOperation build() {

            return new MediaGrabOperation(
                currentSize, grabberIdentifier, grabberProtocol,
                id, key, mediaIndex,
                mediaSubscriptionID, metadata, percent,
                provider, status);
        }

    }
}
