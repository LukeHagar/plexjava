/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.util.Optional;

/**
 * Player
 * 
 * <p>Information about the player being used for playback
 */
public class Player {
    /**
     * The title of the client
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title")
    private Optional<String> title;

    /**
     * The remote address
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("address")
    private Optional<String> address;

    /**
     * Indicating if the client is playing from the local LAN
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("local")
    private Optional<Boolean> local;

    /**
     * The identifier of the client
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("machineIdentifier")
    private Optional<String> machineIdentifier;

    /**
     * The model of the client
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("model")
    private Optional<String> model;

    /**
     * The platform of the client
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("platform")
    private Optional<String> platform;

    /**
     * The platformVersion of the client
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("platformVersion")
    private Optional<String> platformVersion;

    /**
     * The product name of the client
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("product")
    private Optional<String> product;

    /**
     * Indicating if the client is playing over a relay connection
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("relayed")
    private Optional<Boolean> relayed;

    /**
     * The client's public address
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("remotePublicAddress")
    private Optional<String> remotePublicAddress;

    /**
     * Indicating if the client is playing over HTTPS
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("secure")
    private Optional<Boolean> secure;

    /**
     * The client's last reported state
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("state")
    private Optional<String> state;

    /**
     * The id of the user
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userID")
    private Optional<Long> userID;

    /**
     * The vendor of the client
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("vendor")
    private Optional<String> vendor;

    /**
     * The version of the client
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("version")
    private Optional<String> version;

    @JsonCreator
    public Player(
            @JsonProperty("title") Optional<String> title,
            @JsonProperty("address") Optional<String> address,
            @JsonProperty("local") Optional<Boolean> local,
            @JsonProperty("machineIdentifier") Optional<String> machineIdentifier,
            @JsonProperty("model") Optional<String> model,
            @JsonProperty("platform") Optional<String> platform,
            @JsonProperty("platformVersion") Optional<String> platformVersion,
            @JsonProperty("product") Optional<String> product,
            @JsonProperty("relayed") Optional<Boolean> relayed,
            @JsonProperty("remotePublicAddress") Optional<String> remotePublicAddress,
            @JsonProperty("secure") Optional<Boolean> secure,
            @JsonProperty("state") Optional<String> state,
            @JsonProperty("userID") Optional<Long> userID,
            @JsonProperty("vendor") Optional<String> vendor,
            @JsonProperty("version") Optional<String> version) {
        Utils.checkNotNull(title, "title");
        Utils.checkNotNull(address, "address");
        Utils.checkNotNull(local, "local");
        Utils.checkNotNull(machineIdentifier, "machineIdentifier");
        Utils.checkNotNull(model, "model");
        Utils.checkNotNull(platform, "platform");
        Utils.checkNotNull(platformVersion, "platformVersion");
        Utils.checkNotNull(product, "product");
        Utils.checkNotNull(relayed, "relayed");
        Utils.checkNotNull(remotePublicAddress, "remotePublicAddress");
        Utils.checkNotNull(secure, "secure");
        Utils.checkNotNull(state, "state");
        Utils.checkNotNull(userID, "userID");
        Utils.checkNotNull(vendor, "vendor");
        Utils.checkNotNull(version, "version");
        this.title = title;
        this.address = address;
        this.local = local;
        this.machineIdentifier = machineIdentifier;
        this.model = model;
        this.platform = platform;
        this.platformVersion = platformVersion;
        this.product = product;
        this.relayed = relayed;
        this.remotePublicAddress = remotePublicAddress;
        this.secure = secure;
        this.state = state;
        this.userID = userID;
        this.vendor = vendor;
        this.version = version;
    }
    
    public Player() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The title of the client
     */
    @JsonIgnore
    public Optional<String> title() {
        return title;
    }

    /**
     * The remote address
     */
    @JsonIgnore
    public Optional<String> address() {
        return address;
    }

    /**
     * Indicating if the client is playing from the local LAN
     */
    @JsonIgnore
    public Optional<Boolean> local() {
        return local;
    }

    /**
     * The identifier of the client
     */
    @JsonIgnore
    public Optional<String> machineIdentifier() {
        return machineIdentifier;
    }

    /**
     * The model of the client
     */
    @JsonIgnore
    public Optional<String> model() {
        return model;
    }

    /**
     * The platform of the client
     */
    @JsonIgnore
    public Optional<String> platform() {
        return platform;
    }

    /**
     * The platformVersion of the client
     */
    @JsonIgnore
    public Optional<String> platformVersion() {
        return platformVersion;
    }

    /**
     * The product name of the client
     */
    @JsonIgnore
    public Optional<String> product() {
        return product;
    }

    /**
     * Indicating if the client is playing over a relay connection
     */
    @JsonIgnore
    public Optional<Boolean> relayed() {
        return relayed;
    }

    /**
     * The client's public address
     */
    @JsonIgnore
    public Optional<String> remotePublicAddress() {
        return remotePublicAddress;
    }

    /**
     * Indicating if the client is playing over HTTPS
     */
    @JsonIgnore
    public Optional<Boolean> secure() {
        return secure;
    }

    /**
     * The client's last reported state
     */
    @JsonIgnore
    public Optional<String> state() {
        return state;
    }

    /**
     * The id of the user
     */
    @JsonIgnore
    public Optional<Long> userID() {
        return userID;
    }

    /**
     * The vendor of the client
     */
    @JsonIgnore
    public Optional<String> vendor() {
        return vendor;
    }

    /**
     * The version of the client
     */
    @JsonIgnore
    public Optional<String> version() {
        return version;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The title of the client
     */
    public Player withTitle(String title) {
        Utils.checkNotNull(title, "title");
        this.title = Optional.ofNullable(title);
        return this;
    }


    /**
     * The title of the client
     */
    public Player withTitle(Optional<String> title) {
        Utils.checkNotNull(title, "title");
        this.title = title;
        return this;
    }

    /**
     * The remote address
     */
    public Player withAddress(String address) {
        Utils.checkNotNull(address, "address");
        this.address = Optional.ofNullable(address);
        return this;
    }


    /**
     * The remote address
     */
    public Player withAddress(Optional<String> address) {
        Utils.checkNotNull(address, "address");
        this.address = address;
        return this;
    }

    /**
     * Indicating if the client is playing from the local LAN
     */
    public Player withLocal(boolean local) {
        Utils.checkNotNull(local, "local");
        this.local = Optional.ofNullable(local);
        return this;
    }


    /**
     * Indicating if the client is playing from the local LAN
     */
    public Player withLocal(Optional<Boolean> local) {
        Utils.checkNotNull(local, "local");
        this.local = local;
        return this;
    }

    /**
     * The identifier of the client
     */
    public Player withMachineIdentifier(String machineIdentifier) {
        Utils.checkNotNull(machineIdentifier, "machineIdentifier");
        this.machineIdentifier = Optional.ofNullable(machineIdentifier);
        return this;
    }


    /**
     * The identifier of the client
     */
    public Player withMachineIdentifier(Optional<String> machineIdentifier) {
        Utils.checkNotNull(machineIdentifier, "machineIdentifier");
        this.machineIdentifier = machineIdentifier;
        return this;
    }

    /**
     * The model of the client
     */
    public Player withModel(String model) {
        Utils.checkNotNull(model, "model");
        this.model = Optional.ofNullable(model);
        return this;
    }


    /**
     * The model of the client
     */
    public Player withModel(Optional<String> model) {
        Utils.checkNotNull(model, "model");
        this.model = model;
        return this;
    }

    /**
     * The platform of the client
     */
    public Player withPlatform(String platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = Optional.ofNullable(platform);
        return this;
    }


    /**
     * The platform of the client
     */
    public Player withPlatform(Optional<String> platform) {
        Utils.checkNotNull(platform, "platform");
        this.platform = platform;
        return this;
    }

    /**
     * The platformVersion of the client
     */
    public Player withPlatformVersion(String platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = Optional.ofNullable(platformVersion);
        return this;
    }


    /**
     * The platformVersion of the client
     */
    public Player withPlatformVersion(Optional<String> platformVersion) {
        Utils.checkNotNull(platformVersion, "platformVersion");
        this.platformVersion = platformVersion;
        return this;
    }

    /**
     * The product name of the client
     */
    public Player withProduct(String product) {
        Utils.checkNotNull(product, "product");
        this.product = Optional.ofNullable(product);
        return this;
    }


    /**
     * The product name of the client
     */
    public Player withProduct(Optional<String> product) {
        Utils.checkNotNull(product, "product");
        this.product = product;
        return this;
    }

    /**
     * Indicating if the client is playing over a relay connection
     */
    public Player withRelayed(boolean relayed) {
        Utils.checkNotNull(relayed, "relayed");
        this.relayed = Optional.ofNullable(relayed);
        return this;
    }


    /**
     * Indicating if the client is playing over a relay connection
     */
    public Player withRelayed(Optional<Boolean> relayed) {
        Utils.checkNotNull(relayed, "relayed");
        this.relayed = relayed;
        return this;
    }

    /**
     * The client's public address
     */
    public Player withRemotePublicAddress(String remotePublicAddress) {
        Utils.checkNotNull(remotePublicAddress, "remotePublicAddress");
        this.remotePublicAddress = Optional.ofNullable(remotePublicAddress);
        return this;
    }


    /**
     * The client's public address
     */
    public Player withRemotePublicAddress(Optional<String> remotePublicAddress) {
        Utils.checkNotNull(remotePublicAddress, "remotePublicAddress");
        this.remotePublicAddress = remotePublicAddress;
        return this;
    }

    /**
     * Indicating if the client is playing over HTTPS
     */
    public Player withSecure(boolean secure) {
        Utils.checkNotNull(secure, "secure");
        this.secure = Optional.ofNullable(secure);
        return this;
    }


    /**
     * Indicating if the client is playing over HTTPS
     */
    public Player withSecure(Optional<Boolean> secure) {
        Utils.checkNotNull(secure, "secure");
        this.secure = secure;
        return this;
    }

    /**
     * The client's last reported state
     */
    public Player withState(String state) {
        Utils.checkNotNull(state, "state");
        this.state = Optional.ofNullable(state);
        return this;
    }


    /**
     * The client's last reported state
     */
    public Player withState(Optional<String> state) {
        Utils.checkNotNull(state, "state");
        this.state = state;
        return this;
    }

    /**
     * The id of the user
     */
    public Player withUserID(long userID) {
        Utils.checkNotNull(userID, "userID");
        this.userID = Optional.ofNullable(userID);
        return this;
    }


    /**
     * The id of the user
     */
    public Player withUserID(Optional<Long> userID) {
        Utils.checkNotNull(userID, "userID");
        this.userID = userID;
        return this;
    }

    /**
     * The vendor of the client
     */
    public Player withVendor(String vendor) {
        Utils.checkNotNull(vendor, "vendor");
        this.vendor = Optional.ofNullable(vendor);
        return this;
    }


    /**
     * The vendor of the client
     */
    public Player withVendor(Optional<String> vendor) {
        Utils.checkNotNull(vendor, "vendor");
        this.vendor = vendor;
        return this;
    }

    /**
     * The version of the client
     */
    public Player withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }


    /**
     * The version of the client
     */
    public Player withVersion(Optional<String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Player other = (Player) o;
        return 
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.address, other.address) &&
            Utils.enhancedDeepEquals(this.local, other.local) &&
            Utils.enhancedDeepEquals(this.machineIdentifier, other.machineIdentifier) &&
            Utils.enhancedDeepEquals(this.model, other.model) &&
            Utils.enhancedDeepEquals(this.platform, other.platform) &&
            Utils.enhancedDeepEquals(this.platformVersion, other.platformVersion) &&
            Utils.enhancedDeepEquals(this.product, other.product) &&
            Utils.enhancedDeepEquals(this.relayed, other.relayed) &&
            Utils.enhancedDeepEquals(this.remotePublicAddress, other.remotePublicAddress) &&
            Utils.enhancedDeepEquals(this.secure, other.secure) &&
            Utils.enhancedDeepEquals(this.state, other.state) &&
            Utils.enhancedDeepEquals(this.userID, other.userID) &&
            Utils.enhancedDeepEquals(this.vendor, other.vendor) &&
            Utils.enhancedDeepEquals(this.version, other.version);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            title, address, local,
            machineIdentifier, model, platform,
            platformVersion, product, relayed,
            remotePublicAddress, secure, state,
            userID, vendor, version);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Player.class,
                "title", title,
                "address", address,
                "local", local,
                "machineIdentifier", machineIdentifier,
                "model", model,
                "platform", platform,
                "platformVersion", platformVersion,
                "product", product,
                "relayed", relayed,
                "remotePublicAddress", remotePublicAddress,
                "secure", secure,
                "state", state,
                "userID", userID,
                "vendor", vendor,
                "version", version);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> title = Optional.empty();

        private Optional<String> address = Optional.empty();

        private Optional<Boolean> local = Optional.empty();

        private Optional<String> machineIdentifier = Optional.empty();

        private Optional<String> model = Optional.empty();

        private Optional<String> platform = Optional.empty();

        private Optional<String> platformVersion = Optional.empty();

        private Optional<String> product = Optional.empty();

        private Optional<Boolean> relayed = Optional.empty();

        private Optional<String> remotePublicAddress = Optional.empty();

        private Optional<Boolean> secure = Optional.empty();

        private Optional<String> state = Optional.empty();

        private Optional<Long> userID = Optional.empty();

        private Optional<String> vendor = Optional.empty();

        private Optional<String> version = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * The title of the client
         */
        public Builder title(String title) {
            Utils.checkNotNull(title, "title");
            this.title = Optional.ofNullable(title);
            return this;
        }

        /**
         * The title of the client
         */
        public Builder title(Optional<String> title) {
            Utils.checkNotNull(title, "title");
            this.title = title;
            return this;
        }


        /**
         * The remote address
         */
        public Builder address(String address) {
            Utils.checkNotNull(address, "address");
            this.address = Optional.ofNullable(address);
            return this;
        }

        /**
         * The remote address
         */
        public Builder address(Optional<String> address) {
            Utils.checkNotNull(address, "address");
            this.address = address;
            return this;
        }


        /**
         * Indicating if the client is playing from the local LAN
         */
        public Builder local(boolean local) {
            Utils.checkNotNull(local, "local");
            this.local = Optional.ofNullable(local);
            return this;
        }

        /**
         * Indicating if the client is playing from the local LAN
         */
        public Builder local(Optional<Boolean> local) {
            Utils.checkNotNull(local, "local");
            this.local = local;
            return this;
        }


        /**
         * The identifier of the client
         */
        public Builder machineIdentifier(String machineIdentifier) {
            Utils.checkNotNull(machineIdentifier, "machineIdentifier");
            this.machineIdentifier = Optional.ofNullable(machineIdentifier);
            return this;
        }

        /**
         * The identifier of the client
         */
        public Builder machineIdentifier(Optional<String> machineIdentifier) {
            Utils.checkNotNull(machineIdentifier, "machineIdentifier");
            this.machineIdentifier = machineIdentifier;
            return this;
        }


        /**
         * The model of the client
         */
        public Builder model(String model) {
            Utils.checkNotNull(model, "model");
            this.model = Optional.ofNullable(model);
            return this;
        }

        /**
         * The model of the client
         */
        public Builder model(Optional<String> model) {
            Utils.checkNotNull(model, "model");
            this.model = model;
            return this;
        }


        /**
         * The platform of the client
         */
        public Builder platform(String platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = Optional.ofNullable(platform);
            return this;
        }

        /**
         * The platform of the client
         */
        public Builder platform(Optional<String> platform) {
            Utils.checkNotNull(platform, "platform");
            this.platform = platform;
            return this;
        }


        /**
         * The platformVersion of the client
         */
        public Builder platformVersion(String platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = Optional.ofNullable(platformVersion);
            return this;
        }

        /**
         * The platformVersion of the client
         */
        public Builder platformVersion(Optional<String> platformVersion) {
            Utils.checkNotNull(platformVersion, "platformVersion");
            this.platformVersion = platformVersion;
            return this;
        }


        /**
         * The product name of the client
         */
        public Builder product(String product) {
            Utils.checkNotNull(product, "product");
            this.product = Optional.ofNullable(product);
            return this;
        }

        /**
         * The product name of the client
         */
        public Builder product(Optional<String> product) {
            Utils.checkNotNull(product, "product");
            this.product = product;
            return this;
        }


        /**
         * Indicating if the client is playing over a relay connection
         */
        public Builder relayed(boolean relayed) {
            Utils.checkNotNull(relayed, "relayed");
            this.relayed = Optional.ofNullable(relayed);
            return this;
        }

        /**
         * Indicating if the client is playing over a relay connection
         */
        public Builder relayed(Optional<Boolean> relayed) {
            Utils.checkNotNull(relayed, "relayed");
            this.relayed = relayed;
            return this;
        }


        /**
         * The client's public address
         */
        public Builder remotePublicAddress(String remotePublicAddress) {
            Utils.checkNotNull(remotePublicAddress, "remotePublicAddress");
            this.remotePublicAddress = Optional.ofNullable(remotePublicAddress);
            return this;
        }

        /**
         * The client's public address
         */
        public Builder remotePublicAddress(Optional<String> remotePublicAddress) {
            Utils.checkNotNull(remotePublicAddress, "remotePublicAddress");
            this.remotePublicAddress = remotePublicAddress;
            return this;
        }


        /**
         * Indicating if the client is playing over HTTPS
         */
        public Builder secure(boolean secure) {
            Utils.checkNotNull(secure, "secure");
            this.secure = Optional.ofNullable(secure);
            return this;
        }

        /**
         * Indicating if the client is playing over HTTPS
         */
        public Builder secure(Optional<Boolean> secure) {
            Utils.checkNotNull(secure, "secure");
            this.secure = secure;
            return this;
        }


        /**
         * The client's last reported state
         */
        public Builder state(String state) {
            Utils.checkNotNull(state, "state");
            this.state = Optional.ofNullable(state);
            return this;
        }

        /**
         * The client's last reported state
         */
        public Builder state(Optional<String> state) {
            Utils.checkNotNull(state, "state");
            this.state = state;
            return this;
        }


        /**
         * The id of the user
         */
        public Builder userID(long userID) {
            Utils.checkNotNull(userID, "userID");
            this.userID = Optional.ofNullable(userID);
            return this;
        }

        /**
         * The id of the user
         */
        public Builder userID(Optional<Long> userID) {
            Utils.checkNotNull(userID, "userID");
            this.userID = userID;
            return this;
        }


        /**
         * The vendor of the client
         */
        public Builder vendor(String vendor) {
            Utils.checkNotNull(vendor, "vendor");
            this.vendor = Optional.ofNullable(vendor);
            return this;
        }

        /**
         * The vendor of the client
         */
        public Builder vendor(Optional<String> vendor) {
            Utils.checkNotNull(vendor, "vendor");
            this.vendor = vendor;
            return this;
        }


        /**
         * The version of the client
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * The version of the client
         */
        public Builder version(Optional<String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }

        public Player build() {

            return new Player(
                title, address, local,
                machineIdentifier, model, platform,
                platformVersion, product, relayed,
                remotePublicAddress, secure, state,
                userID, vendor, version);
        }

    }
}
