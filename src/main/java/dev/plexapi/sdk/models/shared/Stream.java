/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * Stream
 * 
 * <p>`Stream` represents a particular stream from a media item, such as the video stream, audio stream, or subtitle stream. The stream may either be part of the file represented by the parent `Part` or, especially for subtitles, an external file. The stream contains more detailed information about the specific stream. For example, a video may include the `aspectRatio` at the `Media` level, but detailed information about the video stream like the color space will be included on the `Stream` for the video stream.  Note that photos do not have streams (mostly as an optimization).
 */
public class Stream {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("default")
    private Optional<Boolean> default_;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("audioChannelLayout")
    private Optional<? extends Object> audioChannelLayout;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bitDepth")
    private Optional<Long> bitDepth;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bitrate")
    private Optional<Long> bitrate;

    /**
     * For subtitle streams only. If `true` then the server can attempt to automatically sync the subtitle timestamps with the video.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canAutoSync")
    private Optional<Boolean> canAutoSync;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("chromaLocation")
    private Optional<? extends Object> chromaLocation;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("chromaSubsampling")
    private Optional<? extends Object> chromaSubsampling;

    /**
     * The codec of the stream, such as `h264` or `aac`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("codec")
    private Optional<? extends Object> codec;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colorPrimaries")
    private Optional<? extends Object> colorPrimaries;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colorRange")
    private Optional<? extends Object> colorRange;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colorSpace")
    private Optional<? extends Object> colorSpace;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colorTrc")
    private Optional<? extends Object> colorTrc;

    /**
     * A friendly name for the stream, often comprised of the language and codec information
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("displayTitle")
    private Optional<? extends Object> displayTitle;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("frameRate")
    private Optional<Double> frameRate;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hasScalingMatrix")
    private Optional<? extends Object> hasScalingMatrix;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("height")
    private Optional<Long> height;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<Long> id;

    /**
     * If the stream is part of the `Part` and not an external resource, the index of the stream within that part
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("index")
    private Optional<Long> index;

    /**
     * If the stream is independently streamable, the key from which it can be streamed
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("key")
    private Optional<? extends Object> key;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("language")
    private Optional<? extends Object> language;

    /**
     * The three character language code for the stream contents
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("languageCode")
    private Optional<? extends Object> languageCode;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("level")
    private Optional<Long> level;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profile")
    private Optional<? extends Object> profile;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("refFrames")
    private Optional<Long> refFrames;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("samplingRate")
    private Optional<Long> samplingRate;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("selected")
    private Optional<Boolean> selected;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("streamIdentifier")
    private Optional<Long> streamIdentifier;

    /**
     * A number indicating the type of the stream. `1` for video, `2` for audio, `3` for subtitles, `4` for lyrics
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("streamType")
    private Optional<Long> streamType;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("width")
    private Optional<Long> width;


    @JsonIgnore
    private Map<String, Object> additionalProperties;

    @JsonCreator
    public Stream(
            @JsonProperty("default") Optional<Boolean> default_,
            @JsonProperty("audioChannelLayout") Optional<? extends Object> audioChannelLayout,
            @JsonProperty("bitDepth") Optional<Long> bitDepth,
            @JsonProperty("bitrate") Optional<Long> bitrate,
            @JsonProperty("canAutoSync") Optional<Boolean> canAutoSync,
            @JsonProperty("chromaLocation") Optional<? extends Object> chromaLocation,
            @JsonProperty("chromaSubsampling") Optional<? extends Object> chromaSubsampling,
            @JsonProperty("codec") Optional<? extends Object> codec,
            @JsonProperty("colorPrimaries") Optional<? extends Object> colorPrimaries,
            @JsonProperty("colorRange") Optional<? extends Object> colorRange,
            @JsonProperty("colorSpace") Optional<? extends Object> colorSpace,
            @JsonProperty("colorTrc") Optional<? extends Object> colorTrc,
            @JsonProperty("displayTitle") Optional<? extends Object> displayTitle,
            @JsonProperty("frameRate") Optional<Double> frameRate,
            @JsonProperty("hasScalingMatrix") Optional<? extends Object> hasScalingMatrix,
            @JsonProperty("height") Optional<Long> height,
            @JsonProperty("id") Optional<Long> id,
            @JsonProperty("index") Optional<Long> index,
            @JsonProperty("key") Optional<? extends Object> key,
            @JsonProperty("language") Optional<? extends Object> language,
            @JsonProperty("languageCode") Optional<? extends Object> languageCode,
            @JsonProperty("level") Optional<Long> level,
            @JsonProperty("profile") Optional<? extends Object> profile,
            @JsonProperty("refFrames") Optional<Long> refFrames,
            @JsonProperty("samplingRate") Optional<Long> samplingRate,
            @JsonProperty("selected") Optional<Boolean> selected,
            @JsonProperty("streamIdentifier") Optional<Long> streamIdentifier,
            @JsonProperty("streamType") Optional<Long> streamType,
            @JsonProperty("width") Optional<Long> width) {
        Utils.checkNotNull(default_, "default_");
        Utils.checkNotNull(audioChannelLayout, "audioChannelLayout");
        Utils.checkNotNull(bitDepth, "bitDepth");
        Utils.checkNotNull(bitrate, "bitrate");
        Utils.checkNotNull(canAutoSync, "canAutoSync");
        Utils.checkNotNull(chromaLocation, "chromaLocation");
        Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
        Utils.checkNotNull(codec, "codec");
        Utils.checkNotNull(colorPrimaries, "colorPrimaries");
        Utils.checkNotNull(colorRange, "colorRange");
        Utils.checkNotNull(colorSpace, "colorSpace");
        Utils.checkNotNull(colorTrc, "colorTrc");
        Utils.checkNotNull(displayTitle, "displayTitle");
        Utils.checkNotNull(frameRate, "frameRate");
        Utils.checkNotNull(hasScalingMatrix, "hasScalingMatrix");
        Utils.checkNotNull(height, "height");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(index, "index");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(language, "language");
        Utils.checkNotNull(languageCode, "languageCode");
        Utils.checkNotNull(level, "level");
        Utils.checkNotNull(profile, "profile");
        Utils.checkNotNull(refFrames, "refFrames");
        Utils.checkNotNull(samplingRate, "samplingRate");
        Utils.checkNotNull(selected, "selected");
        Utils.checkNotNull(streamIdentifier, "streamIdentifier");
        Utils.checkNotNull(streamType, "streamType");
        Utils.checkNotNull(width, "width");
        this.default_ = default_;
        this.audioChannelLayout = audioChannelLayout;
        this.bitDepth = bitDepth;
        this.bitrate = bitrate;
        this.canAutoSync = canAutoSync;
        this.chromaLocation = chromaLocation;
        this.chromaSubsampling = chromaSubsampling;
        this.codec = codec;
        this.colorPrimaries = colorPrimaries;
        this.colorRange = colorRange;
        this.colorSpace = colorSpace;
        this.colorTrc = colorTrc;
        this.displayTitle = displayTitle;
        this.frameRate = frameRate;
        this.hasScalingMatrix = hasScalingMatrix;
        this.height = height;
        this.id = id;
        this.index = index;
        this.key = key;
        this.language = language;
        this.languageCode = languageCode;
        this.level = level;
        this.profile = profile;
        this.refFrames = refFrames;
        this.samplingRate = samplingRate;
        this.selected = selected;
        this.streamIdentifier = streamIdentifier;
        this.streamType = streamType;
        this.width = width;
        this.additionalProperties = new HashMap<>();
    }
    
    public Stream() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty());
    }

    @JsonIgnore
    public Optional<Boolean> default_() {
        return default_;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> audioChannelLayout() {
        return (Optional<Object>) audioChannelLayout;
    }

    @JsonIgnore
    public Optional<Long> bitDepth() {
        return bitDepth;
    }

    @JsonIgnore
    public Optional<Long> bitrate() {
        return bitrate;
    }

    /**
     * For subtitle streams only. If `true` then the server can attempt to automatically sync the subtitle timestamps with the video.
     */
    @JsonIgnore
    public Optional<Boolean> canAutoSync() {
        return canAutoSync;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> chromaLocation() {
        return (Optional<Object>) chromaLocation;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> chromaSubsampling() {
        return (Optional<Object>) chromaSubsampling;
    }

    /**
     * The codec of the stream, such as `h264` or `aac`
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> codec() {
        return (Optional<Object>) codec;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> colorPrimaries() {
        return (Optional<Object>) colorPrimaries;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> colorRange() {
        return (Optional<Object>) colorRange;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> colorSpace() {
        return (Optional<Object>) colorSpace;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> colorTrc() {
        return (Optional<Object>) colorTrc;
    }

    /**
     * A friendly name for the stream, often comprised of the language and codec information
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> displayTitle() {
        return (Optional<Object>) displayTitle;
    }

    @JsonIgnore
    public Optional<Double> frameRate() {
        return frameRate;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> hasScalingMatrix() {
        return (Optional<Object>) hasScalingMatrix;
    }

    @JsonIgnore
    public Optional<Long> height() {
        return height;
    }

    @JsonIgnore
    public Optional<Long> id() {
        return id;
    }

    /**
     * If the stream is part of the `Part` and not an external resource, the index of the stream within that part
     */
    @JsonIgnore
    public Optional<Long> index() {
        return index;
    }

    /**
     * If the stream is independently streamable, the key from which it can be streamed
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> key() {
        return (Optional<Object>) key;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> language() {
        return (Optional<Object>) language;
    }

    /**
     * The three character language code for the stream contents
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> languageCode() {
        return (Optional<Object>) languageCode;
    }

    @JsonIgnore
    public Optional<Long> level() {
        return level;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Object> profile() {
        return (Optional<Object>) profile;
    }

    @JsonIgnore
    public Optional<Long> refFrames() {
        return refFrames;
    }

    @JsonIgnore
    public Optional<Long> samplingRate() {
        return samplingRate;
    }

    @JsonIgnore
    public Optional<Boolean> selected() {
        return selected;
    }

    @JsonIgnore
    public Optional<Long> streamIdentifier() {
        return streamIdentifier;
    }

    /**
     * A number indicating the type of the stream. `1` for video, `2` for audio, `3` for subtitles, `4` for lyrics
     */
    @JsonIgnore
    public Optional<Long> streamType() {
        return streamType;
    }

    @JsonIgnore
    public Optional<Long> width() {
        return width;
    }

    @JsonAnyGetter
    public Map<String, Object> additionalProperties() {
        return additionalProperties;
    }

    public static Builder builder() {
        return new Builder();
    }


    public Stream withDefault(boolean default_) {
        Utils.checkNotNull(default_, "default_");
        this.default_ = Optional.ofNullable(default_);
        return this;
    }


    public Stream withDefault(Optional<Boolean> default_) {
        Utils.checkNotNull(default_, "default_");
        this.default_ = default_;
        return this;
    }

    public Stream withAudioChannelLayout(Object audioChannelLayout) {
        Utils.checkNotNull(audioChannelLayout, "audioChannelLayout");
        this.audioChannelLayout = Optional.ofNullable(audioChannelLayout);
        return this;
    }


    public Stream withAudioChannelLayout(Optional<? extends Object> audioChannelLayout) {
        Utils.checkNotNull(audioChannelLayout, "audioChannelLayout");
        this.audioChannelLayout = audioChannelLayout;
        return this;
    }

    public Stream withBitDepth(long bitDepth) {
        Utils.checkNotNull(bitDepth, "bitDepth");
        this.bitDepth = Optional.ofNullable(bitDepth);
        return this;
    }


    public Stream withBitDepth(Optional<Long> bitDepth) {
        Utils.checkNotNull(bitDepth, "bitDepth");
        this.bitDepth = bitDepth;
        return this;
    }

    public Stream withBitrate(long bitrate) {
        Utils.checkNotNull(bitrate, "bitrate");
        this.bitrate = Optional.ofNullable(bitrate);
        return this;
    }


    public Stream withBitrate(Optional<Long> bitrate) {
        Utils.checkNotNull(bitrate, "bitrate");
        this.bitrate = bitrate;
        return this;
    }

    /**
     * For subtitle streams only. If `true` then the server can attempt to automatically sync the subtitle timestamps with the video.
     */
    public Stream withCanAutoSync(boolean canAutoSync) {
        Utils.checkNotNull(canAutoSync, "canAutoSync");
        this.canAutoSync = Optional.ofNullable(canAutoSync);
        return this;
    }


    /**
     * For subtitle streams only. If `true` then the server can attempt to automatically sync the subtitle timestamps with the video.
     */
    public Stream withCanAutoSync(Optional<Boolean> canAutoSync) {
        Utils.checkNotNull(canAutoSync, "canAutoSync");
        this.canAutoSync = canAutoSync;
        return this;
    }

    public Stream withChromaLocation(Object chromaLocation) {
        Utils.checkNotNull(chromaLocation, "chromaLocation");
        this.chromaLocation = Optional.ofNullable(chromaLocation);
        return this;
    }


    public Stream withChromaLocation(Optional<? extends Object> chromaLocation) {
        Utils.checkNotNull(chromaLocation, "chromaLocation");
        this.chromaLocation = chromaLocation;
        return this;
    }

    public Stream withChromaSubsampling(Object chromaSubsampling) {
        Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
        this.chromaSubsampling = Optional.ofNullable(chromaSubsampling);
        return this;
    }


    public Stream withChromaSubsampling(Optional<? extends Object> chromaSubsampling) {
        Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
        this.chromaSubsampling = chromaSubsampling;
        return this;
    }

    /**
     * The codec of the stream, such as `h264` or `aac`
     */
    public Stream withCodec(Object codec) {
        Utils.checkNotNull(codec, "codec");
        this.codec = Optional.ofNullable(codec);
        return this;
    }


    /**
     * The codec of the stream, such as `h264` or `aac`
     */
    public Stream withCodec(Optional<? extends Object> codec) {
        Utils.checkNotNull(codec, "codec");
        this.codec = codec;
        return this;
    }

    public Stream withColorPrimaries(Object colorPrimaries) {
        Utils.checkNotNull(colorPrimaries, "colorPrimaries");
        this.colorPrimaries = Optional.ofNullable(colorPrimaries);
        return this;
    }


    public Stream withColorPrimaries(Optional<? extends Object> colorPrimaries) {
        Utils.checkNotNull(colorPrimaries, "colorPrimaries");
        this.colorPrimaries = colorPrimaries;
        return this;
    }

    public Stream withColorRange(Object colorRange) {
        Utils.checkNotNull(colorRange, "colorRange");
        this.colorRange = Optional.ofNullable(colorRange);
        return this;
    }


    public Stream withColorRange(Optional<? extends Object> colorRange) {
        Utils.checkNotNull(colorRange, "colorRange");
        this.colorRange = colorRange;
        return this;
    }

    public Stream withColorSpace(Object colorSpace) {
        Utils.checkNotNull(colorSpace, "colorSpace");
        this.colorSpace = Optional.ofNullable(colorSpace);
        return this;
    }


    public Stream withColorSpace(Optional<? extends Object> colorSpace) {
        Utils.checkNotNull(colorSpace, "colorSpace");
        this.colorSpace = colorSpace;
        return this;
    }

    public Stream withColorTrc(Object colorTrc) {
        Utils.checkNotNull(colorTrc, "colorTrc");
        this.colorTrc = Optional.ofNullable(colorTrc);
        return this;
    }


    public Stream withColorTrc(Optional<? extends Object> colorTrc) {
        Utils.checkNotNull(colorTrc, "colorTrc");
        this.colorTrc = colorTrc;
        return this;
    }

    /**
     * A friendly name for the stream, often comprised of the language and codec information
     */
    public Stream withDisplayTitle(Object displayTitle) {
        Utils.checkNotNull(displayTitle, "displayTitle");
        this.displayTitle = Optional.ofNullable(displayTitle);
        return this;
    }


    /**
     * A friendly name for the stream, often comprised of the language and codec information
     */
    public Stream withDisplayTitle(Optional<? extends Object> displayTitle) {
        Utils.checkNotNull(displayTitle, "displayTitle");
        this.displayTitle = displayTitle;
        return this;
    }

    public Stream withFrameRate(double frameRate) {
        Utils.checkNotNull(frameRate, "frameRate");
        this.frameRate = Optional.ofNullable(frameRate);
        return this;
    }


    public Stream withFrameRate(Optional<Double> frameRate) {
        Utils.checkNotNull(frameRate, "frameRate");
        this.frameRate = frameRate;
        return this;
    }

    public Stream withHasScalingMatrix(Object hasScalingMatrix) {
        Utils.checkNotNull(hasScalingMatrix, "hasScalingMatrix");
        this.hasScalingMatrix = Optional.ofNullable(hasScalingMatrix);
        return this;
    }


    public Stream withHasScalingMatrix(Optional<? extends Object> hasScalingMatrix) {
        Utils.checkNotNull(hasScalingMatrix, "hasScalingMatrix");
        this.hasScalingMatrix = hasScalingMatrix;
        return this;
    }

    public Stream withHeight(long height) {
        Utils.checkNotNull(height, "height");
        this.height = Optional.ofNullable(height);
        return this;
    }


    public Stream withHeight(Optional<Long> height) {
        Utils.checkNotNull(height, "height");
        this.height = height;
        return this;
    }

    public Stream withId(long id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }


    public Stream withId(Optional<Long> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * If the stream is part of the `Part` and not an external resource, the index of the stream within that part
     */
    public Stream withIndex(long index) {
        Utils.checkNotNull(index, "index");
        this.index = Optional.ofNullable(index);
        return this;
    }


    /**
     * If the stream is part of the `Part` and not an external resource, the index of the stream within that part
     */
    public Stream withIndex(Optional<Long> index) {
        Utils.checkNotNull(index, "index");
        this.index = index;
        return this;
    }

    /**
     * If the stream is independently streamable, the key from which it can be streamed
     */
    public Stream withKey(Object key) {
        Utils.checkNotNull(key, "key");
        this.key = Optional.ofNullable(key);
        return this;
    }


    /**
     * If the stream is independently streamable, the key from which it can be streamed
     */
    public Stream withKey(Optional<? extends Object> key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    public Stream withLanguage(Object language) {
        Utils.checkNotNull(language, "language");
        this.language = Optional.ofNullable(language);
        return this;
    }


    public Stream withLanguage(Optional<? extends Object> language) {
        Utils.checkNotNull(language, "language");
        this.language = language;
        return this;
    }

    /**
     * The three character language code for the stream contents
     */
    public Stream withLanguageCode(Object languageCode) {
        Utils.checkNotNull(languageCode, "languageCode");
        this.languageCode = Optional.ofNullable(languageCode);
        return this;
    }


    /**
     * The three character language code for the stream contents
     */
    public Stream withLanguageCode(Optional<? extends Object> languageCode) {
        Utils.checkNotNull(languageCode, "languageCode");
        this.languageCode = languageCode;
        return this;
    }

    public Stream withLevel(long level) {
        Utils.checkNotNull(level, "level");
        this.level = Optional.ofNullable(level);
        return this;
    }


    public Stream withLevel(Optional<Long> level) {
        Utils.checkNotNull(level, "level");
        this.level = level;
        return this;
    }

    public Stream withProfile(Object profile) {
        Utils.checkNotNull(profile, "profile");
        this.profile = Optional.ofNullable(profile);
        return this;
    }


    public Stream withProfile(Optional<? extends Object> profile) {
        Utils.checkNotNull(profile, "profile");
        this.profile = profile;
        return this;
    }

    public Stream withRefFrames(long refFrames) {
        Utils.checkNotNull(refFrames, "refFrames");
        this.refFrames = Optional.ofNullable(refFrames);
        return this;
    }


    public Stream withRefFrames(Optional<Long> refFrames) {
        Utils.checkNotNull(refFrames, "refFrames");
        this.refFrames = refFrames;
        return this;
    }

    public Stream withSamplingRate(long samplingRate) {
        Utils.checkNotNull(samplingRate, "samplingRate");
        this.samplingRate = Optional.ofNullable(samplingRate);
        return this;
    }


    public Stream withSamplingRate(Optional<Long> samplingRate) {
        Utils.checkNotNull(samplingRate, "samplingRate");
        this.samplingRate = samplingRate;
        return this;
    }

    public Stream withSelected(boolean selected) {
        Utils.checkNotNull(selected, "selected");
        this.selected = Optional.ofNullable(selected);
        return this;
    }


    public Stream withSelected(Optional<Boolean> selected) {
        Utils.checkNotNull(selected, "selected");
        this.selected = selected;
        return this;
    }

    public Stream withStreamIdentifier(long streamIdentifier) {
        Utils.checkNotNull(streamIdentifier, "streamIdentifier");
        this.streamIdentifier = Optional.ofNullable(streamIdentifier);
        return this;
    }


    public Stream withStreamIdentifier(Optional<Long> streamIdentifier) {
        Utils.checkNotNull(streamIdentifier, "streamIdentifier");
        this.streamIdentifier = streamIdentifier;
        return this;
    }

    /**
     * A number indicating the type of the stream. `1` for video, `2` for audio, `3` for subtitles, `4` for lyrics
     */
    public Stream withStreamType(long streamType) {
        Utils.checkNotNull(streamType, "streamType");
        this.streamType = Optional.ofNullable(streamType);
        return this;
    }


    /**
     * A number indicating the type of the stream. `1` for video, `2` for audio, `3` for subtitles, `4` for lyrics
     */
    public Stream withStreamType(Optional<Long> streamType) {
        Utils.checkNotNull(streamType, "streamType");
        this.streamType = streamType;
        return this;
    }

    public Stream withWidth(long width) {
        Utils.checkNotNull(width, "width");
        this.width = Optional.ofNullable(width);
        return this;
    }


    public Stream withWidth(Optional<Long> width) {
        Utils.checkNotNull(width, "width");
        this.width = width;
        return this;
    }

    @JsonAnySetter
    public Stream withAdditionalProperty(String key, Object value) {
        // note that value can be null because of the way JsonAnySetter works
        Utils.checkNotNull(key, "key");
        additionalProperties.put(key, value); 
        return this;
    }
    public Stream withAdditionalProperties(Map<String, Object> additionalProperties) {
        Utils.checkNotNull(additionalProperties, "additionalProperties");
        this.additionalProperties = additionalProperties;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Stream other = (Stream) o;
        return 
            Utils.enhancedDeepEquals(this.default_, other.default_) &&
            Utils.enhancedDeepEquals(this.audioChannelLayout, other.audioChannelLayout) &&
            Utils.enhancedDeepEquals(this.bitDepth, other.bitDepth) &&
            Utils.enhancedDeepEquals(this.bitrate, other.bitrate) &&
            Utils.enhancedDeepEquals(this.canAutoSync, other.canAutoSync) &&
            Utils.enhancedDeepEquals(this.chromaLocation, other.chromaLocation) &&
            Utils.enhancedDeepEquals(this.chromaSubsampling, other.chromaSubsampling) &&
            Utils.enhancedDeepEquals(this.codec, other.codec) &&
            Utils.enhancedDeepEquals(this.colorPrimaries, other.colorPrimaries) &&
            Utils.enhancedDeepEquals(this.colorRange, other.colorRange) &&
            Utils.enhancedDeepEquals(this.colorSpace, other.colorSpace) &&
            Utils.enhancedDeepEquals(this.colorTrc, other.colorTrc) &&
            Utils.enhancedDeepEquals(this.displayTitle, other.displayTitle) &&
            Utils.enhancedDeepEquals(this.frameRate, other.frameRate) &&
            Utils.enhancedDeepEquals(this.hasScalingMatrix, other.hasScalingMatrix) &&
            Utils.enhancedDeepEquals(this.height, other.height) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.index, other.index) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.language, other.language) &&
            Utils.enhancedDeepEquals(this.languageCode, other.languageCode) &&
            Utils.enhancedDeepEquals(this.level, other.level) &&
            Utils.enhancedDeepEquals(this.profile, other.profile) &&
            Utils.enhancedDeepEquals(this.refFrames, other.refFrames) &&
            Utils.enhancedDeepEquals(this.samplingRate, other.samplingRate) &&
            Utils.enhancedDeepEquals(this.selected, other.selected) &&
            Utils.enhancedDeepEquals(this.streamIdentifier, other.streamIdentifier) &&
            Utils.enhancedDeepEquals(this.streamType, other.streamType) &&
            Utils.enhancedDeepEquals(this.width, other.width) &&
            Utils.enhancedDeepEquals(this.additionalProperties, other.additionalProperties);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            default_, audioChannelLayout, bitDepth,
            bitrate, canAutoSync, chromaLocation,
            chromaSubsampling, codec, colorPrimaries,
            colorRange, colorSpace, colorTrc,
            displayTitle, frameRate, hasScalingMatrix,
            height, id, index,
            key, language, languageCode,
            level, profile, refFrames,
            samplingRate, selected, streamIdentifier,
            streamType, width, additionalProperties);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Stream.class,
                "default_", default_,
                "audioChannelLayout", audioChannelLayout,
                "bitDepth", bitDepth,
                "bitrate", bitrate,
                "canAutoSync", canAutoSync,
                "chromaLocation", chromaLocation,
                "chromaSubsampling", chromaSubsampling,
                "codec", codec,
                "colorPrimaries", colorPrimaries,
                "colorRange", colorRange,
                "colorSpace", colorSpace,
                "colorTrc", colorTrc,
                "displayTitle", displayTitle,
                "frameRate", frameRate,
                "hasScalingMatrix", hasScalingMatrix,
                "height", height,
                "id", id,
                "index", index,
                "key", key,
                "language", language,
                "languageCode", languageCode,
                "level", level,
                "profile", profile,
                "refFrames", refFrames,
                "samplingRate", samplingRate,
                "selected", selected,
                "streamIdentifier", streamIdentifier,
                "streamType", streamType,
                "width", width,
                "additionalProperties", additionalProperties);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<Boolean> default_ = Optional.empty();

        private Optional<? extends Object> audioChannelLayout = Optional.empty();

        private Optional<Long> bitDepth = Optional.empty();

        private Optional<Long> bitrate = Optional.empty();

        private Optional<Boolean> canAutoSync = Optional.empty();

        private Optional<? extends Object> chromaLocation = Optional.empty();

        private Optional<? extends Object> chromaSubsampling = Optional.empty();

        private Optional<? extends Object> codec = Optional.empty();

        private Optional<? extends Object> colorPrimaries = Optional.empty();

        private Optional<? extends Object> colorRange = Optional.empty();

        private Optional<? extends Object> colorSpace = Optional.empty();

        private Optional<? extends Object> colorTrc = Optional.empty();

        private Optional<? extends Object> displayTitle = Optional.empty();

        private Optional<Double> frameRate = Optional.empty();

        private Optional<? extends Object> hasScalingMatrix = Optional.empty();

        private Optional<Long> height = Optional.empty();

        private Optional<Long> id = Optional.empty();

        private Optional<Long> index = Optional.empty();

        private Optional<? extends Object> key = Optional.empty();

        private Optional<? extends Object> language = Optional.empty();

        private Optional<? extends Object> languageCode = Optional.empty();

        private Optional<Long> level = Optional.empty();

        private Optional<? extends Object> profile = Optional.empty();

        private Optional<Long> refFrames = Optional.empty();

        private Optional<Long> samplingRate = Optional.empty();

        private Optional<Boolean> selected = Optional.empty();

        private Optional<Long> streamIdentifier = Optional.empty();

        private Optional<Long> streamType = Optional.empty();

        private Optional<Long> width = Optional.empty();

        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {
          // force use of static builder() method
        }


        public Builder default_(boolean default_) {
            Utils.checkNotNull(default_, "default_");
            this.default_ = Optional.ofNullable(default_);
            return this;
        }

        public Builder default_(Optional<Boolean> default_) {
            Utils.checkNotNull(default_, "default_");
            this.default_ = default_;
            return this;
        }


        public Builder audioChannelLayout(Object audioChannelLayout) {
            Utils.checkNotNull(audioChannelLayout, "audioChannelLayout");
            this.audioChannelLayout = Optional.ofNullable(audioChannelLayout);
            return this;
        }

        public Builder audioChannelLayout(Optional<? extends Object> audioChannelLayout) {
            Utils.checkNotNull(audioChannelLayout, "audioChannelLayout");
            this.audioChannelLayout = audioChannelLayout;
            return this;
        }


        public Builder bitDepth(long bitDepth) {
            Utils.checkNotNull(bitDepth, "bitDepth");
            this.bitDepth = Optional.ofNullable(bitDepth);
            return this;
        }

        public Builder bitDepth(Optional<Long> bitDepth) {
            Utils.checkNotNull(bitDepth, "bitDepth");
            this.bitDepth = bitDepth;
            return this;
        }


        public Builder bitrate(long bitrate) {
            Utils.checkNotNull(bitrate, "bitrate");
            this.bitrate = Optional.ofNullable(bitrate);
            return this;
        }

        public Builder bitrate(Optional<Long> bitrate) {
            Utils.checkNotNull(bitrate, "bitrate");
            this.bitrate = bitrate;
            return this;
        }


        /**
         * For subtitle streams only. If `true` then the server can attempt to automatically sync the subtitle timestamps with the video.
         */
        public Builder canAutoSync(boolean canAutoSync) {
            Utils.checkNotNull(canAutoSync, "canAutoSync");
            this.canAutoSync = Optional.ofNullable(canAutoSync);
            return this;
        }

        /**
         * For subtitle streams only. If `true` then the server can attempt to automatically sync the subtitle timestamps with the video.
         */
        public Builder canAutoSync(Optional<Boolean> canAutoSync) {
            Utils.checkNotNull(canAutoSync, "canAutoSync");
            this.canAutoSync = canAutoSync;
            return this;
        }


        public Builder chromaLocation(Object chromaLocation) {
            Utils.checkNotNull(chromaLocation, "chromaLocation");
            this.chromaLocation = Optional.ofNullable(chromaLocation);
            return this;
        }

        public Builder chromaLocation(Optional<? extends Object> chromaLocation) {
            Utils.checkNotNull(chromaLocation, "chromaLocation");
            this.chromaLocation = chromaLocation;
            return this;
        }


        public Builder chromaSubsampling(Object chromaSubsampling) {
            Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
            this.chromaSubsampling = Optional.ofNullable(chromaSubsampling);
            return this;
        }

        public Builder chromaSubsampling(Optional<? extends Object> chromaSubsampling) {
            Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
            this.chromaSubsampling = chromaSubsampling;
            return this;
        }


        /**
         * The codec of the stream, such as `h264` or `aac`
         */
        public Builder codec(Object codec) {
            Utils.checkNotNull(codec, "codec");
            this.codec = Optional.ofNullable(codec);
            return this;
        }

        /**
         * The codec of the stream, such as `h264` or `aac`
         */
        public Builder codec(Optional<? extends Object> codec) {
            Utils.checkNotNull(codec, "codec");
            this.codec = codec;
            return this;
        }


        public Builder colorPrimaries(Object colorPrimaries) {
            Utils.checkNotNull(colorPrimaries, "colorPrimaries");
            this.colorPrimaries = Optional.ofNullable(colorPrimaries);
            return this;
        }

        public Builder colorPrimaries(Optional<? extends Object> colorPrimaries) {
            Utils.checkNotNull(colorPrimaries, "colorPrimaries");
            this.colorPrimaries = colorPrimaries;
            return this;
        }


        public Builder colorRange(Object colorRange) {
            Utils.checkNotNull(colorRange, "colorRange");
            this.colorRange = Optional.ofNullable(colorRange);
            return this;
        }

        public Builder colorRange(Optional<? extends Object> colorRange) {
            Utils.checkNotNull(colorRange, "colorRange");
            this.colorRange = colorRange;
            return this;
        }


        public Builder colorSpace(Object colorSpace) {
            Utils.checkNotNull(colorSpace, "colorSpace");
            this.colorSpace = Optional.ofNullable(colorSpace);
            return this;
        }

        public Builder colorSpace(Optional<? extends Object> colorSpace) {
            Utils.checkNotNull(colorSpace, "colorSpace");
            this.colorSpace = colorSpace;
            return this;
        }


        public Builder colorTrc(Object colorTrc) {
            Utils.checkNotNull(colorTrc, "colorTrc");
            this.colorTrc = Optional.ofNullable(colorTrc);
            return this;
        }

        public Builder colorTrc(Optional<? extends Object> colorTrc) {
            Utils.checkNotNull(colorTrc, "colorTrc");
            this.colorTrc = colorTrc;
            return this;
        }


        /**
         * A friendly name for the stream, often comprised of the language and codec information
         */
        public Builder displayTitle(Object displayTitle) {
            Utils.checkNotNull(displayTitle, "displayTitle");
            this.displayTitle = Optional.ofNullable(displayTitle);
            return this;
        }

        /**
         * A friendly name for the stream, often comprised of the language and codec information
         */
        public Builder displayTitle(Optional<? extends Object> displayTitle) {
            Utils.checkNotNull(displayTitle, "displayTitle");
            this.displayTitle = displayTitle;
            return this;
        }


        public Builder frameRate(double frameRate) {
            Utils.checkNotNull(frameRate, "frameRate");
            this.frameRate = Optional.ofNullable(frameRate);
            return this;
        }

        public Builder frameRate(Optional<Double> frameRate) {
            Utils.checkNotNull(frameRate, "frameRate");
            this.frameRate = frameRate;
            return this;
        }


        public Builder hasScalingMatrix(Object hasScalingMatrix) {
            Utils.checkNotNull(hasScalingMatrix, "hasScalingMatrix");
            this.hasScalingMatrix = Optional.ofNullable(hasScalingMatrix);
            return this;
        }

        public Builder hasScalingMatrix(Optional<? extends Object> hasScalingMatrix) {
            Utils.checkNotNull(hasScalingMatrix, "hasScalingMatrix");
            this.hasScalingMatrix = hasScalingMatrix;
            return this;
        }


        public Builder height(long height) {
            Utils.checkNotNull(height, "height");
            this.height = Optional.ofNullable(height);
            return this;
        }

        public Builder height(Optional<Long> height) {
            Utils.checkNotNull(height, "height");
            this.height = height;
            return this;
        }


        public Builder id(long id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        public Builder id(Optional<Long> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * If the stream is part of the `Part` and not an external resource, the index of the stream within that part
         */
        public Builder index(long index) {
            Utils.checkNotNull(index, "index");
            this.index = Optional.ofNullable(index);
            return this;
        }

        /**
         * If the stream is part of the `Part` and not an external resource, the index of the stream within that part
         */
        public Builder index(Optional<Long> index) {
            Utils.checkNotNull(index, "index");
            this.index = index;
            return this;
        }


        /**
         * If the stream is independently streamable, the key from which it can be streamed
         */
        public Builder key(Object key) {
            Utils.checkNotNull(key, "key");
            this.key = Optional.ofNullable(key);
            return this;
        }

        /**
         * If the stream is independently streamable, the key from which it can be streamed
         */
        public Builder key(Optional<? extends Object> key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        public Builder language(Object language) {
            Utils.checkNotNull(language, "language");
            this.language = Optional.ofNullable(language);
            return this;
        }

        public Builder language(Optional<? extends Object> language) {
            Utils.checkNotNull(language, "language");
            this.language = language;
            return this;
        }


        /**
         * The three character language code for the stream contents
         */
        public Builder languageCode(Object languageCode) {
            Utils.checkNotNull(languageCode, "languageCode");
            this.languageCode = Optional.ofNullable(languageCode);
            return this;
        }

        /**
         * The three character language code for the stream contents
         */
        public Builder languageCode(Optional<? extends Object> languageCode) {
            Utils.checkNotNull(languageCode, "languageCode");
            this.languageCode = languageCode;
            return this;
        }


        public Builder level(long level) {
            Utils.checkNotNull(level, "level");
            this.level = Optional.ofNullable(level);
            return this;
        }

        public Builder level(Optional<Long> level) {
            Utils.checkNotNull(level, "level");
            this.level = level;
            return this;
        }


        public Builder profile(Object profile) {
            Utils.checkNotNull(profile, "profile");
            this.profile = Optional.ofNullable(profile);
            return this;
        }

        public Builder profile(Optional<? extends Object> profile) {
            Utils.checkNotNull(profile, "profile");
            this.profile = profile;
            return this;
        }


        public Builder refFrames(long refFrames) {
            Utils.checkNotNull(refFrames, "refFrames");
            this.refFrames = Optional.ofNullable(refFrames);
            return this;
        }

        public Builder refFrames(Optional<Long> refFrames) {
            Utils.checkNotNull(refFrames, "refFrames");
            this.refFrames = refFrames;
            return this;
        }


        public Builder samplingRate(long samplingRate) {
            Utils.checkNotNull(samplingRate, "samplingRate");
            this.samplingRate = Optional.ofNullable(samplingRate);
            return this;
        }

        public Builder samplingRate(Optional<Long> samplingRate) {
            Utils.checkNotNull(samplingRate, "samplingRate");
            this.samplingRate = samplingRate;
            return this;
        }


        public Builder selected(boolean selected) {
            Utils.checkNotNull(selected, "selected");
            this.selected = Optional.ofNullable(selected);
            return this;
        }

        public Builder selected(Optional<Boolean> selected) {
            Utils.checkNotNull(selected, "selected");
            this.selected = selected;
            return this;
        }


        public Builder streamIdentifier(long streamIdentifier) {
            Utils.checkNotNull(streamIdentifier, "streamIdentifier");
            this.streamIdentifier = Optional.ofNullable(streamIdentifier);
            return this;
        }

        public Builder streamIdentifier(Optional<Long> streamIdentifier) {
            Utils.checkNotNull(streamIdentifier, "streamIdentifier");
            this.streamIdentifier = streamIdentifier;
            return this;
        }


        /**
         * A number indicating the type of the stream. `1` for video, `2` for audio, `3` for subtitles, `4` for lyrics
         */
        public Builder streamType(long streamType) {
            Utils.checkNotNull(streamType, "streamType");
            this.streamType = Optional.ofNullable(streamType);
            return this;
        }

        /**
         * A number indicating the type of the stream. `1` for video, `2` for audio, `3` for subtitles, `4` for lyrics
         */
        public Builder streamType(Optional<Long> streamType) {
            Utils.checkNotNull(streamType, "streamType");
            this.streamType = streamType;
            return this;
        }


        public Builder width(long width) {
            Utils.checkNotNull(width, "width");
            this.width = Optional.ofNullable(width);
            return this;
        }

        public Builder width(Optional<Long> width) {
            Utils.checkNotNull(width, "width");
            this.width = width;
            return this;
        }

        public Builder additionalProperty(String key, Object value) {
            Utils.checkNotNull(key, "key");
            // we could be strict about null values (force the user
            // to pass `JsonNullable.of(null)`) but likely to be a bit 
            // annoying for additional properties building so we'll 
            // relax preconditions.
            this.additionalProperties.put(key, value);
            return this;
        }

        public Builder additionalProperties(Map<String, Object> additionalProperties) {
            Utils.checkNotNull(additionalProperties, "additionalProperties");
            this.additionalProperties = additionalProperties;
            return this;
        }

        public Stream build() {

            return new Stream(
                default_, audioChannelLayout, bitDepth,
                bitrate, canAutoSync, chromaLocation,
                chromaSubsampling, codec, colorPrimaries,
                colorRange, colorSpace, colorTrc,
                displayTitle, frameRate, hasScalingMatrix,
                height, id, index,
                key, language, languageCode,
                level, profile, refFrames,
                samplingRate, selected, streamIdentifier,
                streamType, width)
                .withAdditionalProperties(additionalProperties);
        }

    }
}
