/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import dev.plexapi.sdk.utils.LazySingletonValue;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Float;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * Stream
 * 
 * <p>`Stream` represents a particular stream from a media item, such as the video stream, audio stream, or subtitle stream. The stream may either be part of the file represented by the parent `Part` or, especially for subtitles, an external file. The stream contains more detailed information about the specific stream. For example, a video may include the `aspectRatio` at the `Media` level, but detailed information about the video stream like the color space will be included on the `Stream` for the video stream.  Note that photos do not have streams (mostly as an optimization).
 */
public class Stream {
    /**
     * Indicates if this stream is default.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("default")
    private Optional<Boolean> default_;

    /**
     * Audio channel layout.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("audioChannelLayout")
    private Optional<String> audioChannelLayout;

    /**
     * Number of audio channels (for audio streams).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("channels")
    private Optional<Integer> channels;

    /**
     * Bit depth of the video stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bitDepth")
    private Optional<Integer> bitDepth;

    /**
     * Dolby Vision BL compatibility ID.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("DOVIBLCompatID")
    private Optional<Integer> doviblCompatID;

    /**
     * Indicates if Dolby Vision BL is present.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("DOVIBLPresent")
    private Optional<Boolean> doviblPresent;

    /**
     * Indicates if Dolby Vision EL is present.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("DOVIELPresent")
    private Optional<Boolean> dovielPresent;

    /**
     * Dolby Vision level.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("DOVILevel")
    private Optional<Integer> doviLevel;

    /**
     * Indicates if Dolby Vision is present.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("DOVIPresent")
    private Optional<Boolean> doviPresent;

    /**
     * Dolby Vision profile.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("DOVIProfile")
    private Optional<Integer> doviProfile;

    /**
     * Indicates if Dolby Vision RPU is present.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("DOVIRPUPresent")
    private Optional<Boolean> dovirpuPresent;

    /**
     * Dolby Vision version.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("DOVIVersion")
    private Optional<String> doviVersion;

    /**
     * Bitrate of the stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bitrate")
    private Optional<Integer> bitrate;

    /**
     * Indicates if the stream can auto-sync.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canAutoSync")
    private Optional<Boolean> canAutoSync;

    /**
     * Chroma sample location.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("chromaLocation")
    private Optional<String> chromaLocation;

    /**
     * Chroma subsampling format.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("chromaSubsampling")
    private Optional<String> chromaSubsampling;

    /**
     * Coded video height.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("codedHeight")
    private Optional<Integer> codedHeight;

    /**
     * Coded video width.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("codedWidth")
    private Optional<Integer> codedWidth;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("closedCaptions")
    private Optional<Boolean> closedCaptions;

    /**
     * Codec used by the stream.
     */
    @JsonProperty("codec")
    private String codec;

    /**
     * Color primaries used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colorPrimaries")
    private Optional<String> colorPrimaries;

    /**
     * Color range (e.g., tv).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colorRange")
    private Optional<String> colorRange;

    /**
     * Color space.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colorSpace")
    private Optional<String> colorSpace;

    /**
     * Color transfer characteristics.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colorTrc")
    private Optional<String> colorTrc;

    /**
     * Display title for the stream.
     */
    @JsonProperty("displayTitle")
    private String displayTitle;

    /**
     * Extended display title for the stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("extendedDisplayTitle")
    private Optional<String> extendedDisplayTitle;

    /**
     * Frame rate of the stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("frameRate")
    private Optional<Float> frameRate;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hasScalingMatrix")
    private Optional<Boolean> hasScalingMatrix;

    /**
     * Height of the video stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("height")
    private Optional<Integer> height;

    /**
     * Unique stream identifier.
     */
    @JsonProperty("id")
    private int id;

    /**
     * Index of the stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("index")
    private Optional<Integer> index;

    /**
     * Key to access this stream part.
     */
    @JsonProperty("key")
    private String key;

    /**
     * Language of the stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("language")
    private Optional<String> language;

    /**
     * ISO language code.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("languageCode")
    private Optional<String> languageCode;

    /**
     * Language tag (e.g., en).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("languageTag")
    private Optional<String> languageTag;

    /**
     * Format of the stream (e.g., srt).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("format")
    private Optional<String> format;

    /**
     * Indicates whether header compression is enabled.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("headerCompression")
    private Optional<Boolean> headerCompression;

    /**
     * Video level.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("level")
    private Optional<Integer> level;

    /**
     * Indicates if this is the original stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("original")
    private Optional<Boolean> original;

    /**
     * Video profile.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profile")
    private Optional<String> profile;

    /**
     * Number of reference frames.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("refFrames")
    private Optional<Integer> refFrames;

    /**
     * Sampling rate for the audio stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("samplingRate")
    private Optional<Integer> samplingRate;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("scanType")
    private Optional<String> scanType;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("embeddedInVideo")
    private Optional<String> embeddedInVideo;

    /**
     * Indicates if this stream is selected (applicable for audio streams).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("selected")
    private Optional<Boolean> selected;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("forced")
    private Optional<Boolean> forced;

    /**
     * Indicates if the stream is for the hearing impaired.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hearingImpaired")
    private Optional<Boolean> hearingImpaired;

    /**
     * Indicates if the stream is a dub.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dub")
    private Optional<Boolean> dub;

    /**
     * Optional title for the stream (e.g., language variant).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title")
    private Optional<String> title;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("streamIdentifier")
    private Optional<Integer> streamIdentifier;

    /**
     * Stream type:
     *   - VIDEO = 1
     *   - AUDIO = 2
     *   - SUBTITLE = 3
     */
    @JsonProperty("streamType")
    private long streamType;

    /**
     * Width of the video stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("width")
    private Optional<Integer> width;


    @JsonIgnore
    private Map<String, Object> additionalProperties;

    @JsonCreator
    public Stream(
            @JsonProperty("default") Optional<Boolean> default_,
            @JsonProperty("audioChannelLayout") Optional<String> audioChannelLayout,
            @JsonProperty("channels") Optional<Integer> channels,
            @JsonProperty("bitDepth") Optional<Integer> bitDepth,
            @JsonProperty("DOVIBLCompatID") Optional<Integer> doviblCompatID,
            @JsonProperty("DOVIBLPresent") Optional<Boolean> doviblPresent,
            @JsonProperty("DOVIELPresent") Optional<Boolean> dovielPresent,
            @JsonProperty("DOVILevel") Optional<Integer> doviLevel,
            @JsonProperty("DOVIPresent") Optional<Boolean> doviPresent,
            @JsonProperty("DOVIProfile") Optional<Integer> doviProfile,
            @JsonProperty("DOVIRPUPresent") Optional<Boolean> dovirpuPresent,
            @JsonProperty("DOVIVersion") Optional<String> doviVersion,
            @JsonProperty("bitrate") Optional<Integer> bitrate,
            @JsonProperty("canAutoSync") Optional<Boolean> canAutoSync,
            @JsonProperty("chromaLocation") Optional<String> chromaLocation,
            @JsonProperty("chromaSubsampling") Optional<String> chromaSubsampling,
            @JsonProperty("codedHeight") Optional<Integer> codedHeight,
            @JsonProperty("codedWidth") Optional<Integer> codedWidth,
            @JsonProperty("closedCaptions") Optional<Boolean> closedCaptions,
            @JsonProperty("codec") String codec,
            @JsonProperty("colorPrimaries") Optional<String> colorPrimaries,
            @JsonProperty("colorRange") Optional<String> colorRange,
            @JsonProperty("colorSpace") Optional<String> colorSpace,
            @JsonProperty("colorTrc") Optional<String> colorTrc,
            @JsonProperty("displayTitle") String displayTitle,
            @JsonProperty("extendedDisplayTitle") Optional<String> extendedDisplayTitle,
            @JsonProperty("frameRate") Optional<Float> frameRate,
            @JsonProperty("hasScalingMatrix") Optional<Boolean> hasScalingMatrix,
            @JsonProperty("height") Optional<Integer> height,
            @JsonProperty("id") int id,
            @JsonProperty("index") Optional<Integer> index,
            @JsonProperty("key") String key,
            @JsonProperty("language") Optional<String> language,
            @JsonProperty("languageCode") Optional<String> languageCode,
            @JsonProperty("languageTag") Optional<String> languageTag,
            @JsonProperty("format") Optional<String> format,
            @JsonProperty("headerCompression") Optional<Boolean> headerCompression,
            @JsonProperty("level") Optional<Integer> level,
            @JsonProperty("original") Optional<Boolean> original,
            @JsonProperty("profile") Optional<String> profile,
            @JsonProperty("refFrames") Optional<Integer> refFrames,
            @JsonProperty("samplingRate") Optional<Integer> samplingRate,
            @JsonProperty("scanType") Optional<String> scanType,
            @JsonProperty("embeddedInVideo") Optional<String> embeddedInVideo,
            @JsonProperty("selected") Optional<Boolean> selected,
            @JsonProperty("forced") Optional<Boolean> forced,
            @JsonProperty("hearingImpaired") Optional<Boolean> hearingImpaired,
            @JsonProperty("dub") Optional<Boolean> dub,
            @JsonProperty("title") Optional<String> title,
            @JsonProperty("streamIdentifier") Optional<Integer> streamIdentifier,
            @JsonProperty("width") Optional<Integer> width) {
        Utils.checkNotNull(default_, "default_");
        Utils.checkNotNull(audioChannelLayout, "audioChannelLayout");
        Utils.checkNotNull(channels, "channels");
        Utils.checkNotNull(bitDepth, "bitDepth");
        Utils.checkNotNull(doviblCompatID, "doviblCompatID");
        Utils.checkNotNull(doviblPresent, "doviblPresent");
        Utils.checkNotNull(dovielPresent, "dovielPresent");
        Utils.checkNotNull(doviLevel, "doviLevel");
        Utils.checkNotNull(doviPresent, "doviPresent");
        Utils.checkNotNull(doviProfile, "doviProfile");
        Utils.checkNotNull(dovirpuPresent, "dovirpuPresent");
        Utils.checkNotNull(doviVersion, "doviVersion");
        Utils.checkNotNull(bitrate, "bitrate");
        Utils.checkNotNull(canAutoSync, "canAutoSync");
        Utils.checkNotNull(chromaLocation, "chromaLocation");
        Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
        Utils.checkNotNull(codedHeight, "codedHeight");
        Utils.checkNotNull(codedWidth, "codedWidth");
        Utils.checkNotNull(closedCaptions, "closedCaptions");
        Utils.checkNotNull(codec, "codec");
        Utils.checkNotNull(colorPrimaries, "colorPrimaries");
        Utils.checkNotNull(colorRange, "colorRange");
        Utils.checkNotNull(colorSpace, "colorSpace");
        Utils.checkNotNull(colorTrc, "colorTrc");
        Utils.checkNotNull(displayTitle, "displayTitle");
        Utils.checkNotNull(extendedDisplayTitle, "extendedDisplayTitle");
        Utils.checkNotNull(frameRate, "frameRate");
        Utils.checkNotNull(hasScalingMatrix, "hasScalingMatrix");
        Utils.checkNotNull(height, "height");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(index, "index");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(language, "language");
        Utils.checkNotNull(languageCode, "languageCode");
        Utils.checkNotNull(languageTag, "languageTag");
        Utils.checkNotNull(format, "format");
        Utils.checkNotNull(headerCompression, "headerCompression");
        Utils.checkNotNull(level, "level");
        Utils.checkNotNull(original, "original");
        Utils.checkNotNull(profile, "profile");
        Utils.checkNotNull(refFrames, "refFrames");
        Utils.checkNotNull(samplingRate, "samplingRate");
        Utils.checkNotNull(scanType, "scanType");
        Utils.checkNotNull(embeddedInVideo, "embeddedInVideo");
        Utils.checkNotNull(selected, "selected");
        Utils.checkNotNull(forced, "forced");
        Utils.checkNotNull(hearingImpaired, "hearingImpaired");
        Utils.checkNotNull(dub, "dub");
        Utils.checkNotNull(title, "title");
        Utils.checkNotNull(streamIdentifier, "streamIdentifier");
        Utils.checkNotNull(width, "width");
        this.default_ = default_;
        this.audioChannelLayout = audioChannelLayout;
        this.channels = channels;
        this.bitDepth = bitDepth;
        this.doviblCompatID = doviblCompatID;
        this.doviblPresent = doviblPresent;
        this.dovielPresent = dovielPresent;
        this.doviLevel = doviLevel;
        this.doviPresent = doviPresent;
        this.doviProfile = doviProfile;
        this.dovirpuPresent = dovirpuPresent;
        this.doviVersion = doviVersion;
        this.bitrate = bitrate;
        this.canAutoSync = canAutoSync;
        this.chromaLocation = chromaLocation;
        this.chromaSubsampling = chromaSubsampling;
        this.codedHeight = codedHeight;
        this.codedWidth = codedWidth;
        this.closedCaptions = closedCaptions;
        this.codec = codec;
        this.colorPrimaries = colorPrimaries;
        this.colorRange = colorRange;
        this.colorSpace = colorSpace;
        this.colorTrc = colorTrc;
        this.displayTitle = displayTitle;
        this.extendedDisplayTitle = extendedDisplayTitle;
        this.frameRate = frameRate;
        this.hasScalingMatrix = hasScalingMatrix;
        this.height = height;
        this.id = id;
        this.index = index;
        this.key = key;
        this.language = language;
        this.languageCode = languageCode;
        this.languageTag = languageTag;
        this.format = format;
        this.headerCompression = headerCompression;
        this.level = level;
        this.original = original;
        this.profile = profile;
        this.refFrames = refFrames;
        this.samplingRate = samplingRate;
        this.scanType = scanType;
        this.embeddedInVideo = embeddedInVideo;
        this.selected = selected;
        this.forced = forced;
        this.hearingImpaired = hearingImpaired;
        this.dub = dub;
        this.title = title;
        this.streamIdentifier = streamIdentifier;
        this.streamType = Builder._SINGLETON_VALUE_StreamType.value();
        this.width = width;
        this.additionalProperties = new HashMap<>();
    }
    
    public Stream(
            String codec,
            String displayTitle,
            int id,
            String key) {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), codec, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            displayTitle, Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), id,
            Optional.empty(), key, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Indicates if this stream is default.
     */
    @JsonIgnore
    public Optional<Boolean> default_() {
        return default_;
    }

    /**
     * Audio channel layout.
     */
    @JsonIgnore
    public Optional<String> audioChannelLayout() {
        return audioChannelLayout;
    }

    /**
     * Number of audio channels (for audio streams).
     */
    @JsonIgnore
    public Optional<Integer> channels() {
        return channels;
    }

    /**
     * Bit depth of the video stream.
     */
    @JsonIgnore
    public Optional<Integer> bitDepth() {
        return bitDepth;
    }

    /**
     * Dolby Vision BL compatibility ID.
     */
    @JsonIgnore
    public Optional<Integer> doviblCompatID() {
        return doviblCompatID;
    }

    /**
     * Indicates if Dolby Vision BL is present.
     */
    @JsonIgnore
    public Optional<Boolean> doviblPresent() {
        return doviblPresent;
    }

    /**
     * Indicates if Dolby Vision EL is present.
     */
    @JsonIgnore
    public Optional<Boolean> dovielPresent() {
        return dovielPresent;
    }

    /**
     * Dolby Vision level.
     */
    @JsonIgnore
    public Optional<Integer> doviLevel() {
        return doviLevel;
    }

    /**
     * Indicates if Dolby Vision is present.
     */
    @JsonIgnore
    public Optional<Boolean> doviPresent() {
        return doviPresent;
    }

    /**
     * Dolby Vision profile.
     */
    @JsonIgnore
    public Optional<Integer> doviProfile() {
        return doviProfile;
    }

    /**
     * Indicates if Dolby Vision RPU is present.
     */
    @JsonIgnore
    public Optional<Boolean> dovirpuPresent() {
        return dovirpuPresent;
    }

    /**
     * Dolby Vision version.
     */
    @JsonIgnore
    public Optional<String> doviVersion() {
        return doviVersion;
    }

    /**
     * Bitrate of the stream.
     */
    @JsonIgnore
    public Optional<Integer> bitrate() {
        return bitrate;
    }

    /**
     * Indicates if the stream can auto-sync.
     */
    @JsonIgnore
    public Optional<Boolean> canAutoSync() {
        return canAutoSync;
    }

    /**
     * Chroma sample location.
     */
    @JsonIgnore
    public Optional<String> chromaLocation() {
        return chromaLocation;
    }

    /**
     * Chroma subsampling format.
     */
    @JsonIgnore
    public Optional<String> chromaSubsampling() {
        return chromaSubsampling;
    }

    /**
     * Coded video height.
     */
    @JsonIgnore
    public Optional<Integer> codedHeight() {
        return codedHeight;
    }

    /**
     * Coded video width.
     */
    @JsonIgnore
    public Optional<Integer> codedWidth() {
        return codedWidth;
    }

    @JsonIgnore
    public Optional<Boolean> closedCaptions() {
        return closedCaptions;
    }

    /**
     * Codec used by the stream.
     */
    @JsonIgnore
    public String codec() {
        return codec;
    }

    /**
     * Color primaries used.
     */
    @JsonIgnore
    public Optional<String> colorPrimaries() {
        return colorPrimaries;
    }

    /**
     * Color range (e.g., tv).
     */
    @JsonIgnore
    public Optional<String> colorRange() {
        return colorRange;
    }

    /**
     * Color space.
     */
    @JsonIgnore
    public Optional<String> colorSpace() {
        return colorSpace;
    }

    /**
     * Color transfer characteristics.
     */
    @JsonIgnore
    public Optional<String> colorTrc() {
        return colorTrc;
    }

    /**
     * Display title for the stream.
     */
    @JsonIgnore
    public String displayTitle() {
        return displayTitle;
    }

    /**
     * Extended display title for the stream.
     */
    @JsonIgnore
    public Optional<String> extendedDisplayTitle() {
        return extendedDisplayTitle;
    }

    /**
     * Frame rate of the stream.
     */
    @JsonIgnore
    public Optional<Float> frameRate() {
        return frameRate;
    }

    @JsonIgnore
    public Optional<Boolean> hasScalingMatrix() {
        return hasScalingMatrix;
    }

    /**
     * Height of the video stream.
     */
    @JsonIgnore
    public Optional<Integer> height() {
        return height;
    }

    /**
     * Unique stream identifier.
     */
    @JsonIgnore
    public int id() {
        return id;
    }

    /**
     * Index of the stream.
     */
    @JsonIgnore
    public Optional<Integer> index() {
        return index;
    }

    /**
     * Key to access this stream part.
     */
    @JsonIgnore
    public String key() {
        return key;
    }

    /**
     * Language of the stream.
     */
    @JsonIgnore
    public Optional<String> language() {
        return language;
    }

    /**
     * ISO language code.
     */
    @JsonIgnore
    public Optional<String> languageCode() {
        return languageCode;
    }

    /**
     * Language tag (e.g., en).
     */
    @JsonIgnore
    public Optional<String> languageTag() {
        return languageTag;
    }

    /**
     * Format of the stream (e.g., srt).
     */
    @JsonIgnore
    public Optional<String> format() {
        return format;
    }

    /**
     * Indicates whether header compression is enabled.
     */
    @JsonIgnore
    public Optional<Boolean> headerCompression() {
        return headerCompression;
    }

    /**
     * Video level.
     */
    @JsonIgnore
    public Optional<Integer> level() {
        return level;
    }

    /**
     * Indicates if this is the original stream.
     */
    @JsonIgnore
    public Optional<Boolean> original() {
        return original;
    }

    /**
     * Video profile.
     */
    @JsonIgnore
    public Optional<String> profile() {
        return profile;
    }

    /**
     * Number of reference frames.
     */
    @JsonIgnore
    public Optional<Integer> refFrames() {
        return refFrames;
    }

    /**
     * Sampling rate for the audio stream.
     */
    @JsonIgnore
    public Optional<Integer> samplingRate() {
        return samplingRate;
    }

    @JsonIgnore
    public Optional<String> scanType() {
        return scanType;
    }

    @JsonIgnore
    public Optional<String> embeddedInVideo() {
        return embeddedInVideo;
    }

    /**
     * Indicates if this stream is selected (applicable for audio streams).
     */
    @JsonIgnore
    public Optional<Boolean> selected() {
        return selected;
    }

    @JsonIgnore
    public Optional<Boolean> forced() {
        return forced;
    }

    /**
     * Indicates if the stream is for the hearing impaired.
     */
    @JsonIgnore
    public Optional<Boolean> hearingImpaired() {
        return hearingImpaired;
    }

    /**
     * Indicates if the stream is a dub.
     */
    @JsonIgnore
    public Optional<Boolean> dub() {
        return dub;
    }

    /**
     * Optional title for the stream (e.g., language variant).
     */
    @JsonIgnore
    public Optional<String> title() {
        return title;
    }

    @JsonIgnore
    public Optional<Integer> streamIdentifier() {
        return streamIdentifier;
    }

    /**
     * Stream type:
     *   - VIDEO = 1
     *   - AUDIO = 2
     *   - SUBTITLE = 3
     */
    @JsonIgnore
    public long streamType() {
        return streamType;
    }

    /**
     * Width of the video stream.
     */
    @JsonIgnore
    public Optional<Integer> width() {
        return width;
    }

    @JsonAnyGetter
    public Map<String, Object> additionalProperties() {
        return additionalProperties;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates if this stream is default.
     */
    public Stream withDefault(boolean default_) {
        Utils.checkNotNull(default_, "default_");
        this.default_ = Optional.ofNullable(default_);
        return this;
    }


    /**
     * Indicates if this stream is default.
     */
    public Stream withDefault(Optional<Boolean> default_) {
        Utils.checkNotNull(default_, "default_");
        this.default_ = default_;
        return this;
    }

    /**
     * Audio channel layout.
     */
    public Stream withAudioChannelLayout(String audioChannelLayout) {
        Utils.checkNotNull(audioChannelLayout, "audioChannelLayout");
        this.audioChannelLayout = Optional.ofNullable(audioChannelLayout);
        return this;
    }


    /**
     * Audio channel layout.
     */
    public Stream withAudioChannelLayout(Optional<String> audioChannelLayout) {
        Utils.checkNotNull(audioChannelLayout, "audioChannelLayout");
        this.audioChannelLayout = audioChannelLayout;
        return this;
    }

    /**
     * Number of audio channels (for audio streams).
     */
    public Stream withChannels(int channels) {
        Utils.checkNotNull(channels, "channels");
        this.channels = Optional.ofNullable(channels);
        return this;
    }


    /**
     * Number of audio channels (for audio streams).
     */
    public Stream withChannels(Optional<Integer> channels) {
        Utils.checkNotNull(channels, "channels");
        this.channels = channels;
        return this;
    }

    /**
     * Bit depth of the video stream.
     */
    public Stream withBitDepth(int bitDepth) {
        Utils.checkNotNull(bitDepth, "bitDepth");
        this.bitDepth = Optional.ofNullable(bitDepth);
        return this;
    }


    /**
     * Bit depth of the video stream.
     */
    public Stream withBitDepth(Optional<Integer> bitDepth) {
        Utils.checkNotNull(bitDepth, "bitDepth");
        this.bitDepth = bitDepth;
        return this;
    }

    /**
     * Dolby Vision BL compatibility ID.
     */
    public Stream withDOVIBLCompatID(int doviblCompatID) {
        Utils.checkNotNull(doviblCompatID, "doviblCompatID");
        this.doviblCompatID = Optional.ofNullable(doviblCompatID);
        return this;
    }


    /**
     * Dolby Vision BL compatibility ID.
     */
    public Stream withDOVIBLCompatID(Optional<Integer> doviblCompatID) {
        Utils.checkNotNull(doviblCompatID, "doviblCompatID");
        this.doviblCompatID = doviblCompatID;
        return this;
    }

    /**
     * Indicates if Dolby Vision BL is present.
     */
    public Stream withDOVIBLPresent(boolean doviblPresent) {
        Utils.checkNotNull(doviblPresent, "doviblPresent");
        this.doviblPresent = Optional.ofNullable(doviblPresent);
        return this;
    }


    /**
     * Indicates if Dolby Vision BL is present.
     */
    public Stream withDOVIBLPresent(Optional<Boolean> doviblPresent) {
        Utils.checkNotNull(doviblPresent, "doviblPresent");
        this.doviblPresent = doviblPresent;
        return this;
    }

    /**
     * Indicates if Dolby Vision EL is present.
     */
    public Stream withDOVIELPresent(boolean dovielPresent) {
        Utils.checkNotNull(dovielPresent, "dovielPresent");
        this.dovielPresent = Optional.ofNullable(dovielPresent);
        return this;
    }


    /**
     * Indicates if Dolby Vision EL is present.
     */
    public Stream withDOVIELPresent(Optional<Boolean> dovielPresent) {
        Utils.checkNotNull(dovielPresent, "dovielPresent");
        this.dovielPresent = dovielPresent;
        return this;
    }

    /**
     * Dolby Vision level.
     */
    public Stream withDOVILevel(int doviLevel) {
        Utils.checkNotNull(doviLevel, "doviLevel");
        this.doviLevel = Optional.ofNullable(doviLevel);
        return this;
    }


    /**
     * Dolby Vision level.
     */
    public Stream withDOVILevel(Optional<Integer> doviLevel) {
        Utils.checkNotNull(doviLevel, "doviLevel");
        this.doviLevel = doviLevel;
        return this;
    }

    /**
     * Indicates if Dolby Vision is present.
     */
    public Stream withDOVIPresent(boolean doviPresent) {
        Utils.checkNotNull(doviPresent, "doviPresent");
        this.doviPresent = Optional.ofNullable(doviPresent);
        return this;
    }


    /**
     * Indicates if Dolby Vision is present.
     */
    public Stream withDOVIPresent(Optional<Boolean> doviPresent) {
        Utils.checkNotNull(doviPresent, "doviPresent");
        this.doviPresent = doviPresent;
        return this;
    }

    /**
     * Dolby Vision profile.
     */
    public Stream withDOVIProfile(int doviProfile) {
        Utils.checkNotNull(doviProfile, "doviProfile");
        this.doviProfile = Optional.ofNullable(doviProfile);
        return this;
    }


    /**
     * Dolby Vision profile.
     */
    public Stream withDOVIProfile(Optional<Integer> doviProfile) {
        Utils.checkNotNull(doviProfile, "doviProfile");
        this.doviProfile = doviProfile;
        return this;
    }

    /**
     * Indicates if Dolby Vision RPU is present.
     */
    public Stream withDOVIRPUPresent(boolean dovirpuPresent) {
        Utils.checkNotNull(dovirpuPresent, "dovirpuPresent");
        this.dovirpuPresent = Optional.ofNullable(dovirpuPresent);
        return this;
    }


    /**
     * Indicates if Dolby Vision RPU is present.
     */
    public Stream withDOVIRPUPresent(Optional<Boolean> dovirpuPresent) {
        Utils.checkNotNull(dovirpuPresent, "dovirpuPresent");
        this.dovirpuPresent = dovirpuPresent;
        return this;
    }

    /**
     * Dolby Vision version.
     */
    public Stream withDOVIVersion(String doviVersion) {
        Utils.checkNotNull(doviVersion, "doviVersion");
        this.doviVersion = Optional.ofNullable(doviVersion);
        return this;
    }


    /**
     * Dolby Vision version.
     */
    public Stream withDOVIVersion(Optional<String> doviVersion) {
        Utils.checkNotNull(doviVersion, "doviVersion");
        this.doviVersion = doviVersion;
        return this;
    }

    /**
     * Bitrate of the stream.
     */
    public Stream withBitrate(int bitrate) {
        Utils.checkNotNull(bitrate, "bitrate");
        this.bitrate = Optional.ofNullable(bitrate);
        return this;
    }


    /**
     * Bitrate of the stream.
     */
    public Stream withBitrate(Optional<Integer> bitrate) {
        Utils.checkNotNull(bitrate, "bitrate");
        this.bitrate = bitrate;
        return this;
    }

    /**
     * Indicates if the stream can auto-sync.
     */
    public Stream withCanAutoSync(boolean canAutoSync) {
        Utils.checkNotNull(canAutoSync, "canAutoSync");
        this.canAutoSync = Optional.ofNullable(canAutoSync);
        return this;
    }


    /**
     * Indicates if the stream can auto-sync.
     */
    public Stream withCanAutoSync(Optional<Boolean> canAutoSync) {
        Utils.checkNotNull(canAutoSync, "canAutoSync");
        this.canAutoSync = canAutoSync;
        return this;
    }

    /**
     * Chroma sample location.
     */
    public Stream withChromaLocation(String chromaLocation) {
        Utils.checkNotNull(chromaLocation, "chromaLocation");
        this.chromaLocation = Optional.ofNullable(chromaLocation);
        return this;
    }


    /**
     * Chroma sample location.
     */
    public Stream withChromaLocation(Optional<String> chromaLocation) {
        Utils.checkNotNull(chromaLocation, "chromaLocation");
        this.chromaLocation = chromaLocation;
        return this;
    }

    /**
     * Chroma subsampling format.
     */
    public Stream withChromaSubsampling(String chromaSubsampling) {
        Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
        this.chromaSubsampling = Optional.ofNullable(chromaSubsampling);
        return this;
    }


    /**
     * Chroma subsampling format.
     */
    public Stream withChromaSubsampling(Optional<String> chromaSubsampling) {
        Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
        this.chromaSubsampling = chromaSubsampling;
        return this;
    }

    /**
     * Coded video height.
     */
    public Stream withCodedHeight(int codedHeight) {
        Utils.checkNotNull(codedHeight, "codedHeight");
        this.codedHeight = Optional.ofNullable(codedHeight);
        return this;
    }


    /**
     * Coded video height.
     */
    public Stream withCodedHeight(Optional<Integer> codedHeight) {
        Utils.checkNotNull(codedHeight, "codedHeight");
        this.codedHeight = codedHeight;
        return this;
    }

    /**
     * Coded video width.
     */
    public Stream withCodedWidth(int codedWidth) {
        Utils.checkNotNull(codedWidth, "codedWidth");
        this.codedWidth = Optional.ofNullable(codedWidth);
        return this;
    }


    /**
     * Coded video width.
     */
    public Stream withCodedWidth(Optional<Integer> codedWidth) {
        Utils.checkNotNull(codedWidth, "codedWidth");
        this.codedWidth = codedWidth;
        return this;
    }

    public Stream withClosedCaptions(boolean closedCaptions) {
        Utils.checkNotNull(closedCaptions, "closedCaptions");
        this.closedCaptions = Optional.ofNullable(closedCaptions);
        return this;
    }


    public Stream withClosedCaptions(Optional<Boolean> closedCaptions) {
        Utils.checkNotNull(closedCaptions, "closedCaptions");
        this.closedCaptions = closedCaptions;
        return this;
    }

    /**
     * Codec used by the stream.
     */
    public Stream withCodec(String codec) {
        Utils.checkNotNull(codec, "codec");
        this.codec = codec;
        return this;
    }

    /**
     * Color primaries used.
     */
    public Stream withColorPrimaries(String colorPrimaries) {
        Utils.checkNotNull(colorPrimaries, "colorPrimaries");
        this.colorPrimaries = Optional.ofNullable(colorPrimaries);
        return this;
    }


    /**
     * Color primaries used.
     */
    public Stream withColorPrimaries(Optional<String> colorPrimaries) {
        Utils.checkNotNull(colorPrimaries, "colorPrimaries");
        this.colorPrimaries = colorPrimaries;
        return this;
    }

    /**
     * Color range (e.g., tv).
     */
    public Stream withColorRange(String colorRange) {
        Utils.checkNotNull(colorRange, "colorRange");
        this.colorRange = Optional.ofNullable(colorRange);
        return this;
    }


    /**
     * Color range (e.g., tv).
     */
    public Stream withColorRange(Optional<String> colorRange) {
        Utils.checkNotNull(colorRange, "colorRange");
        this.colorRange = colorRange;
        return this;
    }

    /**
     * Color space.
     */
    public Stream withColorSpace(String colorSpace) {
        Utils.checkNotNull(colorSpace, "colorSpace");
        this.colorSpace = Optional.ofNullable(colorSpace);
        return this;
    }


    /**
     * Color space.
     */
    public Stream withColorSpace(Optional<String> colorSpace) {
        Utils.checkNotNull(colorSpace, "colorSpace");
        this.colorSpace = colorSpace;
        return this;
    }

    /**
     * Color transfer characteristics.
     */
    public Stream withColorTrc(String colorTrc) {
        Utils.checkNotNull(colorTrc, "colorTrc");
        this.colorTrc = Optional.ofNullable(colorTrc);
        return this;
    }


    /**
     * Color transfer characteristics.
     */
    public Stream withColorTrc(Optional<String> colorTrc) {
        Utils.checkNotNull(colorTrc, "colorTrc");
        this.colorTrc = colorTrc;
        return this;
    }

    /**
     * Display title for the stream.
     */
    public Stream withDisplayTitle(String displayTitle) {
        Utils.checkNotNull(displayTitle, "displayTitle");
        this.displayTitle = displayTitle;
        return this;
    }

    /**
     * Extended display title for the stream.
     */
    public Stream withExtendedDisplayTitle(String extendedDisplayTitle) {
        Utils.checkNotNull(extendedDisplayTitle, "extendedDisplayTitle");
        this.extendedDisplayTitle = Optional.ofNullable(extendedDisplayTitle);
        return this;
    }


    /**
     * Extended display title for the stream.
     */
    public Stream withExtendedDisplayTitle(Optional<String> extendedDisplayTitle) {
        Utils.checkNotNull(extendedDisplayTitle, "extendedDisplayTitle");
        this.extendedDisplayTitle = extendedDisplayTitle;
        return this;
    }

    /**
     * Frame rate of the stream.
     */
    public Stream withFrameRate(float frameRate) {
        Utils.checkNotNull(frameRate, "frameRate");
        this.frameRate = Optional.ofNullable(frameRate);
        return this;
    }


    /**
     * Frame rate of the stream.
     */
    public Stream withFrameRate(Optional<Float> frameRate) {
        Utils.checkNotNull(frameRate, "frameRate");
        this.frameRate = frameRate;
        return this;
    }

    public Stream withHasScalingMatrix(boolean hasScalingMatrix) {
        Utils.checkNotNull(hasScalingMatrix, "hasScalingMatrix");
        this.hasScalingMatrix = Optional.ofNullable(hasScalingMatrix);
        return this;
    }


    public Stream withHasScalingMatrix(Optional<Boolean> hasScalingMatrix) {
        Utils.checkNotNull(hasScalingMatrix, "hasScalingMatrix");
        this.hasScalingMatrix = hasScalingMatrix;
        return this;
    }

    /**
     * Height of the video stream.
     */
    public Stream withHeight(int height) {
        Utils.checkNotNull(height, "height");
        this.height = Optional.ofNullable(height);
        return this;
    }


    /**
     * Height of the video stream.
     */
    public Stream withHeight(Optional<Integer> height) {
        Utils.checkNotNull(height, "height");
        this.height = height;
        return this;
    }

    /**
     * Unique stream identifier.
     */
    public Stream withId(int id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Index of the stream.
     */
    public Stream withIndex(int index) {
        Utils.checkNotNull(index, "index");
        this.index = Optional.ofNullable(index);
        return this;
    }


    /**
     * Index of the stream.
     */
    public Stream withIndex(Optional<Integer> index) {
        Utils.checkNotNull(index, "index");
        this.index = index;
        return this;
    }

    /**
     * Key to access this stream part.
     */
    public Stream withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    /**
     * Language of the stream.
     */
    public Stream withLanguage(String language) {
        Utils.checkNotNull(language, "language");
        this.language = Optional.ofNullable(language);
        return this;
    }


    /**
     * Language of the stream.
     */
    public Stream withLanguage(Optional<String> language) {
        Utils.checkNotNull(language, "language");
        this.language = language;
        return this;
    }

    /**
     * ISO language code.
     */
    public Stream withLanguageCode(String languageCode) {
        Utils.checkNotNull(languageCode, "languageCode");
        this.languageCode = Optional.ofNullable(languageCode);
        return this;
    }


    /**
     * ISO language code.
     */
    public Stream withLanguageCode(Optional<String> languageCode) {
        Utils.checkNotNull(languageCode, "languageCode");
        this.languageCode = languageCode;
        return this;
    }

    /**
     * Language tag (e.g., en).
     */
    public Stream withLanguageTag(String languageTag) {
        Utils.checkNotNull(languageTag, "languageTag");
        this.languageTag = Optional.ofNullable(languageTag);
        return this;
    }


    /**
     * Language tag (e.g., en).
     */
    public Stream withLanguageTag(Optional<String> languageTag) {
        Utils.checkNotNull(languageTag, "languageTag");
        this.languageTag = languageTag;
        return this;
    }

    /**
     * Format of the stream (e.g., srt).
     */
    public Stream withFormat(String format) {
        Utils.checkNotNull(format, "format");
        this.format = Optional.ofNullable(format);
        return this;
    }


    /**
     * Format of the stream (e.g., srt).
     */
    public Stream withFormat(Optional<String> format) {
        Utils.checkNotNull(format, "format");
        this.format = format;
        return this;
    }

    /**
     * Indicates whether header compression is enabled.
     */
    public Stream withHeaderCompression(boolean headerCompression) {
        Utils.checkNotNull(headerCompression, "headerCompression");
        this.headerCompression = Optional.ofNullable(headerCompression);
        return this;
    }


    /**
     * Indicates whether header compression is enabled.
     */
    public Stream withHeaderCompression(Optional<Boolean> headerCompression) {
        Utils.checkNotNull(headerCompression, "headerCompression");
        this.headerCompression = headerCompression;
        return this;
    }

    /**
     * Video level.
     */
    public Stream withLevel(int level) {
        Utils.checkNotNull(level, "level");
        this.level = Optional.ofNullable(level);
        return this;
    }


    /**
     * Video level.
     */
    public Stream withLevel(Optional<Integer> level) {
        Utils.checkNotNull(level, "level");
        this.level = level;
        return this;
    }

    /**
     * Indicates if this is the original stream.
     */
    public Stream withOriginal(boolean original) {
        Utils.checkNotNull(original, "original");
        this.original = Optional.ofNullable(original);
        return this;
    }


    /**
     * Indicates if this is the original stream.
     */
    public Stream withOriginal(Optional<Boolean> original) {
        Utils.checkNotNull(original, "original");
        this.original = original;
        return this;
    }

    /**
     * Video profile.
     */
    public Stream withProfile(String profile) {
        Utils.checkNotNull(profile, "profile");
        this.profile = Optional.ofNullable(profile);
        return this;
    }


    /**
     * Video profile.
     */
    public Stream withProfile(Optional<String> profile) {
        Utils.checkNotNull(profile, "profile");
        this.profile = profile;
        return this;
    }

    /**
     * Number of reference frames.
     */
    public Stream withRefFrames(int refFrames) {
        Utils.checkNotNull(refFrames, "refFrames");
        this.refFrames = Optional.ofNullable(refFrames);
        return this;
    }


    /**
     * Number of reference frames.
     */
    public Stream withRefFrames(Optional<Integer> refFrames) {
        Utils.checkNotNull(refFrames, "refFrames");
        this.refFrames = refFrames;
        return this;
    }

    /**
     * Sampling rate for the audio stream.
     */
    public Stream withSamplingRate(int samplingRate) {
        Utils.checkNotNull(samplingRate, "samplingRate");
        this.samplingRate = Optional.ofNullable(samplingRate);
        return this;
    }


    /**
     * Sampling rate for the audio stream.
     */
    public Stream withSamplingRate(Optional<Integer> samplingRate) {
        Utils.checkNotNull(samplingRate, "samplingRate");
        this.samplingRate = samplingRate;
        return this;
    }

    public Stream withScanType(String scanType) {
        Utils.checkNotNull(scanType, "scanType");
        this.scanType = Optional.ofNullable(scanType);
        return this;
    }


    public Stream withScanType(Optional<String> scanType) {
        Utils.checkNotNull(scanType, "scanType");
        this.scanType = scanType;
        return this;
    }

    public Stream withEmbeddedInVideo(String embeddedInVideo) {
        Utils.checkNotNull(embeddedInVideo, "embeddedInVideo");
        this.embeddedInVideo = Optional.ofNullable(embeddedInVideo);
        return this;
    }


    public Stream withEmbeddedInVideo(Optional<String> embeddedInVideo) {
        Utils.checkNotNull(embeddedInVideo, "embeddedInVideo");
        this.embeddedInVideo = embeddedInVideo;
        return this;
    }

    /**
     * Indicates if this stream is selected (applicable for audio streams).
     */
    public Stream withSelected(boolean selected) {
        Utils.checkNotNull(selected, "selected");
        this.selected = Optional.ofNullable(selected);
        return this;
    }


    /**
     * Indicates if this stream is selected (applicable for audio streams).
     */
    public Stream withSelected(Optional<Boolean> selected) {
        Utils.checkNotNull(selected, "selected");
        this.selected = selected;
        return this;
    }

    public Stream withForced(boolean forced) {
        Utils.checkNotNull(forced, "forced");
        this.forced = Optional.ofNullable(forced);
        return this;
    }


    public Stream withForced(Optional<Boolean> forced) {
        Utils.checkNotNull(forced, "forced");
        this.forced = forced;
        return this;
    }

    /**
     * Indicates if the stream is for the hearing impaired.
     */
    public Stream withHearingImpaired(boolean hearingImpaired) {
        Utils.checkNotNull(hearingImpaired, "hearingImpaired");
        this.hearingImpaired = Optional.ofNullable(hearingImpaired);
        return this;
    }


    /**
     * Indicates if the stream is for the hearing impaired.
     */
    public Stream withHearingImpaired(Optional<Boolean> hearingImpaired) {
        Utils.checkNotNull(hearingImpaired, "hearingImpaired");
        this.hearingImpaired = hearingImpaired;
        return this;
    }

    /**
     * Indicates if the stream is a dub.
     */
    public Stream withDub(boolean dub) {
        Utils.checkNotNull(dub, "dub");
        this.dub = Optional.ofNullable(dub);
        return this;
    }


    /**
     * Indicates if the stream is a dub.
     */
    public Stream withDub(Optional<Boolean> dub) {
        Utils.checkNotNull(dub, "dub");
        this.dub = dub;
        return this;
    }

    /**
     * Optional title for the stream (e.g., language variant).
     */
    public Stream withTitle(String title) {
        Utils.checkNotNull(title, "title");
        this.title = Optional.ofNullable(title);
        return this;
    }


    /**
     * Optional title for the stream (e.g., language variant).
     */
    public Stream withTitle(Optional<String> title) {
        Utils.checkNotNull(title, "title");
        this.title = title;
        return this;
    }

    public Stream withStreamIdentifier(int streamIdentifier) {
        Utils.checkNotNull(streamIdentifier, "streamIdentifier");
        this.streamIdentifier = Optional.ofNullable(streamIdentifier);
        return this;
    }


    public Stream withStreamIdentifier(Optional<Integer> streamIdentifier) {
        Utils.checkNotNull(streamIdentifier, "streamIdentifier");
        this.streamIdentifier = streamIdentifier;
        return this;
    }

    /**
     * Width of the video stream.
     */
    public Stream withWidth(int width) {
        Utils.checkNotNull(width, "width");
        this.width = Optional.ofNullable(width);
        return this;
    }


    /**
     * Width of the video stream.
     */
    public Stream withWidth(Optional<Integer> width) {
        Utils.checkNotNull(width, "width");
        this.width = width;
        return this;
    }

    @JsonAnySetter
    public Stream withAdditionalProperty(String key, Object value) {
        // note that value can be null because of the way JsonAnySetter works
        Utils.checkNotNull(key, "key");
        additionalProperties.put(key, value); 
        return this;
    }
    public Stream withAdditionalProperties(Map<String, Object> additionalProperties) {
        Utils.checkNotNull(additionalProperties, "additionalProperties");
        this.additionalProperties = additionalProperties;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Stream other = (Stream) o;
        return 
            Utils.enhancedDeepEquals(this.default_, other.default_) &&
            Utils.enhancedDeepEquals(this.audioChannelLayout, other.audioChannelLayout) &&
            Utils.enhancedDeepEquals(this.channels, other.channels) &&
            Utils.enhancedDeepEquals(this.bitDepth, other.bitDepth) &&
            Utils.enhancedDeepEquals(this.doviblCompatID, other.doviblCompatID) &&
            Utils.enhancedDeepEquals(this.doviblPresent, other.doviblPresent) &&
            Utils.enhancedDeepEquals(this.dovielPresent, other.dovielPresent) &&
            Utils.enhancedDeepEquals(this.doviLevel, other.doviLevel) &&
            Utils.enhancedDeepEquals(this.doviPresent, other.doviPresent) &&
            Utils.enhancedDeepEquals(this.doviProfile, other.doviProfile) &&
            Utils.enhancedDeepEquals(this.dovirpuPresent, other.dovirpuPresent) &&
            Utils.enhancedDeepEquals(this.doviVersion, other.doviVersion) &&
            Utils.enhancedDeepEquals(this.bitrate, other.bitrate) &&
            Utils.enhancedDeepEquals(this.canAutoSync, other.canAutoSync) &&
            Utils.enhancedDeepEquals(this.chromaLocation, other.chromaLocation) &&
            Utils.enhancedDeepEquals(this.chromaSubsampling, other.chromaSubsampling) &&
            Utils.enhancedDeepEquals(this.codedHeight, other.codedHeight) &&
            Utils.enhancedDeepEquals(this.codedWidth, other.codedWidth) &&
            Utils.enhancedDeepEquals(this.closedCaptions, other.closedCaptions) &&
            Utils.enhancedDeepEquals(this.codec, other.codec) &&
            Utils.enhancedDeepEquals(this.colorPrimaries, other.colorPrimaries) &&
            Utils.enhancedDeepEquals(this.colorRange, other.colorRange) &&
            Utils.enhancedDeepEquals(this.colorSpace, other.colorSpace) &&
            Utils.enhancedDeepEquals(this.colorTrc, other.colorTrc) &&
            Utils.enhancedDeepEquals(this.displayTitle, other.displayTitle) &&
            Utils.enhancedDeepEquals(this.extendedDisplayTitle, other.extendedDisplayTitle) &&
            Utils.enhancedDeepEquals(this.frameRate, other.frameRate) &&
            Utils.enhancedDeepEquals(this.hasScalingMatrix, other.hasScalingMatrix) &&
            Utils.enhancedDeepEquals(this.height, other.height) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.index, other.index) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.language, other.language) &&
            Utils.enhancedDeepEquals(this.languageCode, other.languageCode) &&
            Utils.enhancedDeepEquals(this.languageTag, other.languageTag) &&
            Utils.enhancedDeepEquals(this.format, other.format) &&
            Utils.enhancedDeepEquals(this.headerCompression, other.headerCompression) &&
            Utils.enhancedDeepEquals(this.level, other.level) &&
            Utils.enhancedDeepEquals(this.original, other.original) &&
            Utils.enhancedDeepEquals(this.profile, other.profile) &&
            Utils.enhancedDeepEquals(this.refFrames, other.refFrames) &&
            Utils.enhancedDeepEquals(this.samplingRate, other.samplingRate) &&
            Utils.enhancedDeepEquals(this.scanType, other.scanType) &&
            Utils.enhancedDeepEquals(this.embeddedInVideo, other.embeddedInVideo) &&
            Utils.enhancedDeepEquals(this.selected, other.selected) &&
            Utils.enhancedDeepEquals(this.forced, other.forced) &&
            Utils.enhancedDeepEquals(this.hearingImpaired, other.hearingImpaired) &&
            Utils.enhancedDeepEquals(this.dub, other.dub) &&
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.streamIdentifier, other.streamIdentifier) &&
            Utils.enhancedDeepEquals(this.streamType, other.streamType) &&
            Utils.enhancedDeepEquals(this.width, other.width) &&
            Utils.enhancedDeepEquals(this.additionalProperties, other.additionalProperties);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            default_, audioChannelLayout, channels,
            bitDepth, doviblCompatID, doviblPresent,
            dovielPresent, doviLevel, doviPresent,
            doviProfile, dovirpuPresent, doviVersion,
            bitrate, canAutoSync, chromaLocation,
            chromaSubsampling, codedHeight, codedWidth,
            closedCaptions, codec, colorPrimaries,
            colorRange, colorSpace, colorTrc,
            displayTitle, extendedDisplayTitle, frameRate,
            hasScalingMatrix, height, id,
            index, key, language,
            languageCode, languageTag, format,
            headerCompression, level, original,
            profile, refFrames, samplingRate,
            scanType, embeddedInVideo, selected,
            forced, hearingImpaired, dub,
            title, streamIdentifier, streamType,
            width, additionalProperties);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Stream.class,
                "default_", default_,
                "audioChannelLayout", audioChannelLayout,
                "channels", channels,
                "bitDepth", bitDepth,
                "doviblCompatID", doviblCompatID,
                "doviblPresent", doviblPresent,
                "dovielPresent", dovielPresent,
                "doviLevel", doviLevel,
                "doviPresent", doviPresent,
                "doviProfile", doviProfile,
                "dovirpuPresent", dovirpuPresent,
                "doviVersion", doviVersion,
                "bitrate", bitrate,
                "canAutoSync", canAutoSync,
                "chromaLocation", chromaLocation,
                "chromaSubsampling", chromaSubsampling,
                "codedHeight", codedHeight,
                "codedWidth", codedWidth,
                "closedCaptions", closedCaptions,
                "codec", codec,
                "colorPrimaries", colorPrimaries,
                "colorRange", colorRange,
                "colorSpace", colorSpace,
                "colorTrc", colorTrc,
                "displayTitle", displayTitle,
                "extendedDisplayTitle", extendedDisplayTitle,
                "frameRate", frameRate,
                "hasScalingMatrix", hasScalingMatrix,
                "height", height,
                "id", id,
                "index", index,
                "key", key,
                "language", language,
                "languageCode", languageCode,
                "languageTag", languageTag,
                "format", format,
                "headerCompression", headerCompression,
                "level", level,
                "original", original,
                "profile", profile,
                "refFrames", refFrames,
                "samplingRate", samplingRate,
                "scanType", scanType,
                "embeddedInVideo", embeddedInVideo,
                "selected", selected,
                "forced", forced,
                "hearingImpaired", hearingImpaired,
                "dub", dub,
                "title", title,
                "streamIdentifier", streamIdentifier,
                "streamType", streamType,
                "width", width,
                "additionalProperties", additionalProperties);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<Boolean> default_ = Optional.empty();

        private Optional<String> audioChannelLayout = Optional.empty();

        private Optional<Integer> channels = Optional.empty();

        private Optional<Integer> bitDepth = Optional.empty();

        private Optional<Integer> doviblCompatID = Optional.empty();

        private Optional<Boolean> doviblPresent = Optional.empty();

        private Optional<Boolean> dovielPresent = Optional.empty();

        private Optional<Integer> doviLevel = Optional.empty();

        private Optional<Boolean> doviPresent = Optional.empty();

        private Optional<Integer> doviProfile = Optional.empty();

        private Optional<Boolean> dovirpuPresent = Optional.empty();

        private Optional<String> doviVersion = Optional.empty();

        private Optional<Integer> bitrate = Optional.empty();

        private Optional<Boolean> canAutoSync = Optional.empty();

        private Optional<String> chromaLocation = Optional.empty();

        private Optional<String> chromaSubsampling = Optional.empty();

        private Optional<Integer> codedHeight = Optional.empty();

        private Optional<Integer> codedWidth = Optional.empty();

        private Optional<Boolean> closedCaptions = Optional.empty();

        private String codec;

        private Optional<String> colorPrimaries = Optional.empty();

        private Optional<String> colorRange = Optional.empty();

        private Optional<String> colorSpace = Optional.empty();

        private Optional<String> colorTrc = Optional.empty();

        private String displayTitle;

        private Optional<String> extendedDisplayTitle = Optional.empty();

        private Optional<Float> frameRate = Optional.empty();

        private Optional<Boolean> hasScalingMatrix = Optional.empty();

        private Optional<Integer> height = Optional.empty();

        private Integer id;

        private Optional<Integer> index = Optional.empty();

        private String key;

        private Optional<String> language = Optional.empty();

        private Optional<String> languageCode = Optional.empty();

        private Optional<String> languageTag = Optional.empty();

        private Optional<String> format = Optional.empty();

        private Optional<Boolean> headerCompression = Optional.empty();

        private Optional<Integer> level = Optional.empty();

        private Optional<Boolean> original = Optional.empty();

        private Optional<String> profile = Optional.empty();

        private Optional<Integer> refFrames = Optional.empty();

        private Optional<Integer> samplingRate = Optional.empty();

        private Optional<String> scanType = Optional.empty();

        private Optional<String> embeddedInVideo = Optional.empty();

        private Optional<Boolean> selected = Optional.empty();

        private Optional<Boolean> forced = Optional.empty();

        private Optional<Boolean> hearingImpaired = Optional.empty();

        private Optional<Boolean> dub = Optional.empty();

        private Optional<String> title = Optional.empty();

        private Optional<Integer> streamIdentifier = Optional.empty();

        private Optional<Integer> width = Optional.empty();

        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates if this stream is default.
         */
        public Builder default_(boolean default_) {
            Utils.checkNotNull(default_, "default_");
            this.default_ = Optional.ofNullable(default_);
            return this;
        }

        /**
         * Indicates if this stream is default.
         */
        public Builder default_(Optional<Boolean> default_) {
            Utils.checkNotNull(default_, "default_");
            this.default_ = default_;
            return this;
        }


        /**
         * Audio channel layout.
         */
        public Builder audioChannelLayout(String audioChannelLayout) {
            Utils.checkNotNull(audioChannelLayout, "audioChannelLayout");
            this.audioChannelLayout = Optional.ofNullable(audioChannelLayout);
            return this;
        }

        /**
         * Audio channel layout.
         */
        public Builder audioChannelLayout(Optional<String> audioChannelLayout) {
            Utils.checkNotNull(audioChannelLayout, "audioChannelLayout");
            this.audioChannelLayout = audioChannelLayout;
            return this;
        }


        /**
         * Number of audio channels (for audio streams).
         */
        public Builder channels(int channels) {
            Utils.checkNotNull(channels, "channels");
            this.channels = Optional.ofNullable(channels);
            return this;
        }

        /**
         * Number of audio channels (for audio streams).
         */
        public Builder channels(Optional<Integer> channels) {
            Utils.checkNotNull(channels, "channels");
            this.channels = channels;
            return this;
        }


        /**
         * Bit depth of the video stream.
         */
        public Builder bitDepth(int bitDepth) {
            Utils.checkNotNull(bitDepth, "bitDepth");
            this.bitDepth = Optional.ofNullable(bitDepth);
            return this;
        }

        /**
         * Bit depth of the video stream.
         */
        public Builder bitDepth(Optional<Integer> bitDepth) {
            Utils.checkNotNull(bitDepth, "bitDepth");
            this.bitDepth = bitDepth;
            return this;
        }


        /**
         * Dolby Vision BL compatibility ID.
         */
        public Builder doviblCompatID(int doviblCompatID) {
            Utils.checkNotNull(doviblCompatID, "doviblCompatID");
            this.doviblCompatID = Optional.ofNullable(doviblCompatID);
            return this;
        }

        /**
         * Dolby Vision BL compatibility ID.
         */
        public Builder doviblCompatID(Optional<Integer> doviblCompatID) {
            Utils.checkNotNull(doviblCompatID, "doviblCompatID");
            this.doviblCompatID = doviblCompatID;
            return this;
        }


        /**
         * Indicates if Dolby Vision BL is present.
         */
        public Builder doviblPresent(boolean doviblPresent) {
            Utils.checkNotNull(doviblPresent, "doviblPresent");
            this.doviblPresent = Optional.ofNullable(doviblPresent);
            return this;
        }

        /**
         * Indicates if Dolby Vision BL is present.
         */
        public Builder doviblPresent(Optional<Boolean> doviblPresent) {
            Utils.checkNotNull(doviblPresent, "doviblPresent");
            this.doviblPresent = doviblPresent;
            return this;
        }


        /**
         * Indicates if Dolby Vision EL is present.
         */
        public Builder dovielPresent(boolean dovielPresent) {
            Utils.checkNotNull(dovielPresent, "dovielPresent");
            this.dovielPresent = Optional.ofNullable(dovielPresent);
            return this;
        }

        /**
         * Indicates if Dolby Vision EL is present.
         */
        public Builder dovielPresent(Optional<Boolean> dovielPresent) {
            Utils.checkNotNull(dovielPresent, "dovielPresent");
            this.dovielPresent = dovielPresent;
            return this;
        }


        /**
         * Dolby Vision level.
         */
        public Builder doviLevel(int doviLevel) {
            Utils.checkNotNull(doviLevel, "doviLevel");
            this.doviLevel = Optional.ofNullable(doviLevel);
            return this;
        }

        /**
         * Dolby Vision level.
         */
        public Builder doviLevel(Optional<Integer> doviLevel) {
            Utils.checkNotNull(doviLevel, "doviLevel");
            this.doviLevel = doviLevel;
            return this;
        }


        /**
         * Indicates if Dolby Vision is present.
         */
        public Builder doviPresent(boolean doviPresent) {
            Utils.checkNotNull(doviPresent, "doviPresent");
            this.doviPresent = Optional.ofNullable(doviPresent);
            return this;
        }

        /**
         * Indicates if Dolby Vision is present.
         */
        public Builder doviPresent(Optional<Boolean> doviPresent) {
            Utils.checkNotNull(doviPresent, "doviPresent");
            this.doviPresent = doviPresent;
            return this;
        }


        /**
         * Dolby Vision profile.
         */
        public Builder doviProfile(int doviProfile) {
            Utils.checkNotNull(doviProfile, "doviProfile");
            this.doviProfile = Optional.ofNullable(doviProfile);
            return this;
        }

        /**
         * Dolby Vision profile.
         */
        public Builder doviProfile(Optional<Integer> doviProfile) {
            Utils.checkNotNull(doviProfile, "doviProfile");
            this.doviProfile = doviProfile;
            return this;
        }


        /**
         * Indicates if Dolby Vision RPU is present.
         */
        public Builder dovirpuPresent(boolean dovirpuPresent) {
            Utils.checkNotNull(dovirpuPresent, "dovirpuPresent");
            this.dovirpuPresent = Optional.ofNullable(dovirpuPresent);
            return this;
        }

        /**
         * Indicates if Dolby Vision RPU is present.
         */
        public Builder dovirpuPresent(Optional<Boolean> dovirpuPresent) {
            Utils.checkNotNull(dovirpuPresent, "dovirpuPresent");
            this.dovirpuPresent = dovirpuPresent;
            return this;
        }


        /**
         * Dolby Vision version.
         */
        public Builder doviVersion(String doviVersion) {
            Utils.checkNotNull(doviVersion, "doviVersion");
            this.doviVersion = Optional.ofNullable(doviVersion);
            return this;
        }

        /**
         * Dolby Vision version.
         */
        public Builder doviVersion(Optional<String> doviVersion) {
            Utils.checkNotNull(doviVersion, "doviVersion");
            this.doviVersion = doviVersion;
            return this;
        }


        /**
         * Bitrate of the stream.
         */
        public Builder bitrate(int bitrate) {
            Utils.checkNotNull(bitrate, "bitrate");
            this.bitrate = Optional.ofNullable(bitrate);
            return this;
        }

        /**
         * Bitrate of the stream.
         */
        public Builder bitrate(Optional<Integer> bitrate) {
            Utils.checkNotNull(bitrate, "bitrate");
            this.bitrate = bitrate;
            return this;
        }


        /**
         * Indicates if the stream can auto-sync.
         */
        public Builder canAutoSync(boolean canAutoSync) {
            Utils.checkNotNull(canAutoSync, "canAutoSync");
            this.canAutoSync = Optional.ofNullable(canAutoSync);
            return this;
        }

        /**
         * Indicates if the stream can auto-sync.
         */
        public Builder canAutoSync(Optional<Boolean> canAutoSync) {
            Utils.checkNotNull(canAutoSync, "canAutoSync");
            this.canAutoSync = canAutoSync;
            return this;
        }


        /**
         * Chroma sample location.
         */
        public Builder chromaLocation(String chromaLocation) {
            Utils.checkNotNull(chromaLocation, "chromaLocation");
            this.chromaLocation = Optional.ofNullable(chromaLocation);
            return this;
        }

        /**
         * Chroma sample location.
         */
        public Builder chromaLocation(Optional<String> chromaLocation) {
            Utils.checkNotNull(chromaLocation, "chromaLocation");
            this.chromaLocation = chromaLocation;
            return this;
        }


        /**
         * Chroma subsampling format.
         */
        public Builder chromaSubsampling(String chromaSubsampling) {
            Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
            this.chromaSubsampling = Optional.ofNullable(chromaSubsampling);
            return this;
        }

        /**
         * Chroma subsampling format.
         */
        public Builder chromaSubsampling(Optional<String> chromaSubsampling) {
            Utils.checkNotNull(chromaSubsampling, "chromaSubsampling");
            this.chromaSubsampling = chromaSubsampling;
            return this;
        }


        /**
         * Coded video height.
         */
        public Builder codedHeight(int codedHeight) {
            Utils.checkNotNull(codedHeight, "codedHeight");
            this.codedHeight = Optional.ofNullable(codedHeight);
            return this;
        }

        /**
         * Coded video height.
         */
        public Builder codedHeight(Optional<Integer> codedHeight) {
            Utils.checkNotNull(codedHeight, "codedHeight");
            this.codedHeight = codedHeight;
            return this;
        }


        /**
         * Coded video width.
         */
        public Builder codedWidth(int codedWidth) {
            Utils.checkNotNull(codedWidth, "codedWidth");
            this.codedWidth = Optional.ofNullable(codedWidth);
            return this;
        }

        /**
         * Coded video width.
         */
        public Builder codedWidth(Optional<Integer> codedWidth) {
            Utils.checkNotNull(codedWidth, "codedWidth");
            this.codedWidth = codedWidth;
            return this;
        }


        public Builder closedCaptions(boolean closedCaptions) {
            Utils.checkNotNull(closedCaptions, "closedCaptions");
            this.closedCaptions = Optional.ofNullable(closedCaptions);
            return this;
        }

        public Builder closedCaptions(Optional<Boolean> closedCaptions) {
            Utils.checkNotNull(closedCaptions, "closedCaptions");
            this.closedCaptions = closedCaptions;
            return this;
        }


        /**
         * Codec used by the stream.
         */
        public Builder codec(String codec) {
            Utils.checkNotNull(codec, "codec");
            this.codec = codec;
            return this;
        }


        /**
         * Color primaries used.
         */
        public Builder colorPrimaries(String colorPrimaries) {
            Utils.checkNotNull(colorPrimaries, "colorPrimaries");
            this.colorPrimaries = Optional.ofNullable(colorPrimaries);
            return this;
        }

        /**
         * Color primaries used.
         */
        public Builder colorPrimaries(Optional<String> colorPrimaries) {
            Utils.checkNotNull(colorPrimaries, "colorPrimaries");
            this.colorPrimaries = colorPrimaries;
            return this;
        }


        /**
         * Color range (e.g., tv).
         */
        public Builder colorRange(String colorRange) {
            Utils.checkNotNull(colorRange, "colorRange");
            this.colorRange = Optional.ofNullable(colorRange);
            return this;
        }

        /**
         * Color range (e.g., tv).
         */
        public Builder colorRange(Optional<String> colorRange) {
            Utils.checkNotNull(colorRange, "colorRange");
            this.colorRange = colorRange;
            return this;
        }


        /**
         * Color space.
         */
        public Builder colorSpace(String colorSpace) {
            Utils.checkNotNull(colorSpace, "colorSpace");
            this.colorSpace = Optional.ofNullable(colorSpace);
            return this;
        }

        /**
         * Color space.
         */
        public Builder colorSpace(Optional<String> colorSpace) {
            Utils.checkNotNull(colorSpace, "colorSpace");
            this.colorSpace = colorSpace;
            return this;
        }


        /**
         * Color transfer characteristics.
         */
        public Builder colorTrc(String colorTrc) {
            Utils.checkNotNull(colorTrc, "colorTrc");
            this.colorTrc = Optional.ofNullable(colorTrc);
            return this;
        }

        /**
         * Color transfer characteristics.
         */
        public Builder colorTrc(Optional<String> colorTrc) {
            Utils.checkNotNull(colorTrc, "colorTrc");
            this.colorTrc = colorTrc;
            return this;
        }


        /**
         * Display title for the stream.
         */
        public Builder displayTitle(String displayTitle) {
            Utils.checkNotNull(displayTitle, "displayTitle");
            this.displayTitle = displayTitle;
            return this;
        }


        /**
         * Extended display title for the stream.
         */
        public Builder extendedDisplayTitle(String extendedDisplayTitle) {
            Utils.checkNotNull(extendedDisplayTitle, "extendedDisplayTitle");
            this.extendedDisplayTitle = Optional.ofNullable(extendedDisplayTitle);
            return this;
        }

        /**
         * Extended display title for the stream.
         */
        public Builder extendedDisplayTitle(Optional<String> extendedDisplayTitle) {
            Utils.checkNotNull(extendedDisplayTitle, "extendedDisplayTitle");
            this.extendedDisplayTitle = extendedDisplayTitle;
            return this;
        }


        /**
         * Frame rate of the stream.
         */
        public Builder frameRate(float frameRate) {
            Utils.checkNotNull(frameRate, "frameRate");
            this.frameRate = Optional.ofNullable(frameRate);
            return this;
        }

        /**
         * Frame rate of the stream.
         */
        public Builder frameRate(Optional<Float> frameRate) {
            Utils.checkNotNull(frameRate, "frameRate");
            this.frameRate = frameRate;
            return this;
        }


        public Builder hasScalingMatrix(boolean hasScalingMatrix) {
            Utils.checkNotNull(hasScalingMatrix, "hasScalingMatrix");
            this.hasScalingMatrix = Optional.ofNullable(hasScalingMatrix);
            return this;
        }

        public Builder hasScalingMatrix(Optional<Boolean> hasScalingMatrix) {
            Utils.checkNotNull(hasScalingMatrix, "hasScalingMatrix");
            this.hasScalingMatrix = hasScalingMatrix;
            return this;
        }


        /**
         * Height of the video stream.
         */
        public Builder height(int height) {
            Utils.checkNotNull(height, "height");
            this.height = Optional.ofNullable(height);
            return this;
        }

        /**
         * Height of the video stream.
         */
        public Builder height(Optional<Integer> height) {
            Utils.checkNotNull(height, "height");
            this.height = height;
            return this;
        }


        /**
         * Unique stream identifier.
         */
        public Builder id(int id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * Index of the stream.
         */
        public Builder index(int index) {
            Utils.checkNotNull(index, "index");
            this.index = Optional.ofNullable(index);
            return this;
        }

        /**
         * Index of the stream.
         */
        public Builder index(Optional<Integer> index) {
            Utils.checkNotNull(index, "index");
            this.index = index;
            return this;
        }


        /**
         * Key to access this stream part.
         */
        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        /**
         * Language of the stream.
         */
        public Builder language(String language) {
            Utils.checkNotNull(language, "language");
            this.language = Optional.ofNullable(language);
            return this;
        }

        /**
         * Language of the stream.
         */
        public Builder language(Optional<String> language) {
            Utils.checkNotNull(language, "language");
            this.language = language;
            return this;
        }


        /**
         * ISO language code.
         */
        public Builder languageCode(String languageCode) {
            Utils.checkNotNull(languageCode, "languageCode");
            this.languageCode = Optional.ofNullable(languageCode);
            return this;
        }

        /**
         * ISO language code.
         */
        public Builder languageCode(Optional<String> languageCode) {
            Utils.checkNotNull(languageCode, "languageCode");
            this.languageCode = languageCode;
            return this;
        }


        /**
         * Language tag (e.g., en).
         */
        public Builder languageTag(String languageTag) {
            Utils.checkNotNull(languageTag, "languageTag");
            this.languageTag = Optional.ofNullable(languageTag);
            return this;
        }

        /**
         * Language tag (e.g., en).
         */
        public Builder languageTag(Optional<String> languageTag) {
            Utils.checkNotNull(languageTag, "languageTag");
            this.languageTag = languageTag;
            return this;
        }


        /**
         * Format of the stream (e.g., srt).
         */
        public Builder format(String format) {
            Utils.checkNotNull(format, "format");
            this.format = Optional.ofNullable(format);
            return this;
        }

        /**
         * Format of the stream (e.g., srt).
         */
        public Builder format(Optional<String> format) {
            Utils.checkNotNull(format, "format");
            this.format = format;
            return this;
        }


        /**
         * Indicates whether header compression is enabled.
         */
        public Builder headerCompression(boolean headerCompression) {
            Utils.checkNotNull(headerCompression, "headerCompression");
            this.headerCompression = Optional.ofNullable(headerCompression);
            return this;
        }

        /**
         * Indicates whether header compression is enabled.
         */
        public Builder headerCompression(Optional<Boolean> headerCompression) {
            Utils.checkNotNull(headerCompression, "headerCompression");
            this.headerCompression = headerCompression;
            return this;
        }


        /**
         * Video level.
         */
        public Builder level(int level) {
            Utils.checkNotNull(level, "level");
            this.level = Optional.ofNullable(level);
            return this;
        }

        /**
         * Video level.
         */
        public Builder level(Optional<Integer> level) {
            Utils.checkNotNull(level, "level");
            this.level = level;
            return this;
        }


        /**
         * Indicates if this is the original stream.
         */
        public Builder original(boolean original) {
            Utils.checkNotNull(original, "original");
            this.original = Optional.ofNullable(original);
            return this;
        }

        /**
         * Indicates if this is the original stream.
         */
        public Builder original(Optional<Boolean> original) {
            Utils.checkNotNull(original, "original");
            this.original = original;
            return this;
        }


        /**
         * Video profile.
         */
        public Builder profile(String profile) {
            Utils.checkNotNull(profile, "profile");
            this.profile = Optional.ofNullable(profile);
            return this;
        }

        /**
         * Video profile.
         */
        public Builder profile(Optional<String> profile) {
            Utils.checkNotNull(profile, "profile");
            this.profile = profile;
            return this;
        }


        /**
         * Number of reference frames.
         */
        public Builder refFrames(int refFrames) {
            Utils.checkNotNull(refFrames, "refFrames");
            this.refFrames = Optional.ofNullable(refFrames);
            return this;
        }

        /**
         * Number of reference frames.
         */
        public Builder refFrames(Optional<Integer> refFrames) {
            Utils.checkNotNull(refFrames, "refFrames");
            this.refFrames = refFrames;
            return this;
        }


        /**
         * Sampling rate for the audio stream.
         */
        public Builder samplingRate(int samplingRate) {
            Utils.checkNotNull(samplingRate, "samplingRate");
            this.samplingRate = Optional.ofNullable(samplingRate);
            return this;
        }

        /**
         * Sampling rate for the audio stream.
         */
        public Builder samplingRate(Optional<Integer> samplingRate) {
            Utils.checkNotNull(samplingRate, "samplingRate");
            this.samplingRate = samplingRate;
            return this;
        }


        public Builder scanType(String scanType) {
            Utils.checkNotNull(scanType, "scanType");
            this.scanType = Optional.ofNullable(scanType);
            return this;
        }

        public Builder scanType(Optional<String> scanType) {
            Utils.checkNotNull(scanType, "scanType");
            this.scanType = scanType;
            return this;
        }


        public Builder embeddedInVideo(String embeddedInVideo) {
            Utils.checkNotNull(embeddedInVideo, "embeddedInVideo");
            this.embeddedInVideo = Optional.ofNullable(embeddedInVideo);
            return this;
        }

        public Builder embeddedInVideo(Optional<String> embeddedInVideo) {
            Utils.checkNotNull(embeddedInVideo, "embeddedInVideo");
            this.embeddedInVideo = embeddedInVideo;
            return this;
        }


        /**
         * Indicates if this stream is selected (applicable for audio streams).
         */
        public Builder selected(boolean selected) {
            Utils.checkNotNull(selected, "selected");
            this.selected = Optional.ofNullable(selected);
            return this;
        }

        /**
         * Indicates if this stream is selected (applicable for audio streams).
         */
        public Builder selected(Optional<Boolean> selected) {
            Utils.checkNotNull(selected, "selected");
            this.selected = selected;
            return this;
        }


        public Builder forced(boolean forced) {
            Utils.checkNotNull(forced, "forced");
            this.forced = Optional.ofNullable(forced);
            return this;
        }

        public Builder forced(Optional<Boolean> forced) {
            Utils.checkNotNull(forced, "forced");
            this.forced = forced;
            return this;
        }


        /**
         * Indicates if the stream is for the hearing impaired.
         */
        public Builder hearingImpaired(boolean hearingImpaired) {
            Utils.checkNotNull(hearingImpaired, "hearingImpaired");
            this.hearingImpaired = Optional.ofNullable(hearingImpaired);
            return this;
        }

        /**
         * Indicates if the stream is for the hearing impaired.
         */
        public Builder hearingImpaired(Optional<Boolean> hearingImpaired) {
            Utils.checkNotNull(hearingImpaired, "hearingImpaired");
            this.hearingImpaired = hearingImpaired;
            return this;
        }


        /**
         * Indicates if the stream is a dub.
         */
        public Builder dub(boolean dub) {
            Utils.checkNotNull(dub, "dub");
            this.dub = Optional.ofNullable(dub);
            return this;
        }

        /**
         * Indicates if the stream is a dub.
         */
        public Builder dub(Optional<Boolean> dub) {
            Utils.checkNotNull(dub, "dub");
            this.dub = dub;
            return this;
        }


        /**
         * Optional title for the stream (e.g., language variant).
         */
        public Builder title(String title) {
            Utils.checkNotNull(title, "title");
            this.title = Optional.ofNullable(title);
            return this;
        }

        /**
         * Optional title for the stream (e.g., language variant).
         */
        public Builder title(Optional<String> title) {
            Utils.checkNotNull(title, "title");
            this.title = title;
            return this;
        }


        public Builder streamIdentifier(int streamIdentifier) {
            Utils.checkNotNull(streamIdentifier, "streamIdentifier");
            this.streamIdentifier = Optional.ofNullable(streamIdentifier);
            return this;
        }

        public Builder streamIdentifier(Optional<Integer> streamIdentifier) {
            Utils.checkNotNull(streamIdentifier, "streamIdentifier");
            this.streamIdentifier = streamIdentifier;
            return this;
        }


        /**
         * Width of the video stream.
         */
        public Builder width(int width) {
            Utils.checkNotNull(width, "width");
            this.width = Optional.ofNullable(width);
            return this;
        }

        /**
         * Width of the video stream.
         */
        public Builder width(Optional<Integer> width) {
            Utils.checkNotNull(width, "width");
            this.width = width;
            return this;
        }

        public Builder additionalProperty(String key, Object value) {
            Utils.checkNotNull(key, "key");
            // we could be strict about null values (force the user
            // to pass `JsonNullable.of(null)`) but likely to be a bit 
            // annoying for additional properties building so we'll 
            // relax preconditions.
            this.additionalProperties.put(key, value);
            return this;
        }

        public Builder additionalProperties(Map<String, Object> additionalProperties) {
            Utils.checkNotNull(additionalProperties, "additionalProperties");
            this.additionalProperties = additionalProperties;
            return this;
        }

        public Stream build() {

            return new Stream(
                default_, audioChannelLayout, channels,
                bitDepth, doviblCompatID, doviblPresent,
                dovielPresent, doviLevel, doviPresent,
                doviProfile, dovirpuPresent, doviVersion,
                bitrate, canAutoSync, chromaLocation,
                chromaSubsampling, codedHeight, codedWidth,
                closedCaptions, codec, colorPrimaries,
                colorRange, colorSpace, colorTrc,
                displayTitle, extendedDisplayTitle, frameRate,
                hasScalingMatrix, height, id,
                index, key, language,
                languageCode, languageTag, format,
                headerCompression, level, original,
                profile, refFrames, samplingRate,
                scanType, embeddedInVideo, selected,
                forced, hearingImpaired, dub,
                title, streamIdentifier, width)
                .withAdditionalProperties(additionalProperties);
        }


        private static final LazySingletonValue<Long> _SINGLETON_VALUE_StreamType =
                new LazySingletonValue<>(
                        "streamType",
                        "1",
                        new TypeReference<Long>() {});
    }
}
