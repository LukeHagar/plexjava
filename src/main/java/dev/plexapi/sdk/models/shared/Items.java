/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Float;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Items
 * 
 * <p>Items in a library are referred to as "metadata items." These metadata items are distinct from "media items" which represent actual instances of media that can be consumed. Consider a TV library that has a single video file in it for a particular episode of a show. The library has a single media item, but it has three metadata items: one for the show, one for the season, and one for the episode. Consider a movie library that has two video files in it: the same movie, but two different resolutions. The library has a single metadata item for the movie, but that metadata item has two media items, one for each resolution. Additionally a "media item" will have one or more "media parts" where the the parts are intended to be watched together, such as a CD1 and CD2 parts of the same movie.
 * 
 * <p>Note that when a metadata item has multiple media items, those media items should be isomorphic. That is, a 4K version and 1080p version of a movie are different versions of the same movie. They have the same duration, same summary, same rating, etc. and they can generally be considered interchangeable. A theatrical release vs. director's cut vs. unrated version on the other hand would be separate metadata items.
 * 
 * <p>Metadata items can often live in a hierarchy with relationships between them.  For example, the metadata item for an episodes is associated with a season metadata item which is associated with a show metadata item.  A similar hierarchy exists with track, album, and artist and photos and photo album.  The relationships may be expressed via relative terms and absolute terms.  For example, "leaves" refer to metadata items which has associated media (there is no media for a season nor show).  A show will have "children" in the form of seasons and a season will have "children" in the form of episodes and episodes have "parent" in the form of a season which has a "parent" in the form of a show.  Similarly, a show has "grandchildren" in the form of episodse and an episode has a "grandparent" in the form of a show.
 */
public class Items {
    /**
     * The title of the item (e.g. “300” or “The Simpsons”)
     */
    @JsonProperty("title")
    private String title;

    /**
     * The type of the video item, such as `movie`, `episode`, or `clip`.
     */
    @JsonProperty("type")
    private String type;

    /**
     * When present, contains the disc number for a track on multi-disc albums.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("absoluteIndex")
    private Optional<Integer> absoluteIndex;

    /**
     * In units of seconds since the epoch, returns the time at which the item was added to the library.
     */
    @JsonProperty("addedAt")
    private long addedAt;

    /**
     * When present, the URL for the background artwork for the item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("art")
    private Optional<String> art;

    /**
     * Some rating systems separate reviewer ratings from audience ratings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("audienceRating")
    private Optional<Float> audienceRating;

    /**
     * A URI representing the image to be shown with the audience rating (e.g. rottentomatoes://image.rating.spilled).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("audienceRatingImage")
    private Optional<String> audienceRatingImage;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Autotag")
    private Optional<? extends List<Tag>> autotag;

    /**
     * When present, the URL for a banner graphic for the item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("banner")
    private Optional<String> banner;

    /**
     * When present, indicates the source for the chapters in the media file. Can be media (the chapters were embedded in the media itself), agent (a metadata agent computed them), or mixed (a combination of the two).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("chapterSource")
    private Optional<String> chapterSource;

    /**
     * The number of child items associated with this media item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("childCount")
    private Optional<Integer> childCount;

    /**
     * When present, the URL for a composite image for descendent items (e.g. photo albums or playlists).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("composite")
    private Optional<String> composite;

    /**
     * If known, the content rating (e.g. MPAA) for an item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("contentRating")
    private Optional<String> contentRating;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Country")
    private Optional<? extends List<Tag>> country;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Director")
    private Optional<? extends List<Tag>> director;

    /**
     * When present, the duration for the item, in units of milliseconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("duration")
    private Optional<Integer> duration;

    /**
     * Typically only seen in metadata at a library's top level
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Filter")
    private Optional<? extends List<Filter>> filter;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Genre")
    private Optional<? extends List<Tag>> genre;

    /**
     * The `art` of the grandparent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grandparentArt")
    private Optional<String> grandparentArt;

    /**
     * The GUID of the grandparent media item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grandparentGuid")
    private Optional<String> grandparentGuid;

    /**
     * The `hero` of the grandparent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grandparentHero")
    private Optional<String> grandparentHero;

    /**
     * The `key` of the grandparent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grandparentKey")
    private Optional<String> grandparentKey;

    /**
     * The `ratingKey` of the grandparent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grandparentRatingKey")
    private Optional<String> grandparentRatingKey;

    /**
     * The `theme` of the grandparent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grandparentTheme")
    private Optional<String> grandparentTheme;

    /**
     * The `thumb` of the grandparent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grandparentThumb")
    private Optional<String> grandparentThumb;

    /**
     * The `title` of the grandparent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("grandparentTitle")
    private Optional<String> grandparentTitle;

    /**
     * The globally unique identifier for the media item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("guid")
    private Optional<String> guid;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Guid")
    private Optional<? extends List<ItemsGuids>> guids;

    /**
     * When present, the URL for a hero image for the item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hero")
    private Optional<String> hero;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Image")
    private Optional<? extends List<Image>> image;

    /**
     * When present, this represents the episode number for episodes, season number for seasons, or track number for audio tracks.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("index")
    private Optional<Integer> index;

    /**
     * The key at which the item's details can be fetched.  In many cases a metadata item may be passed without all the details (such as in a hub) and this key corresponds to the endpoint to fetch additional details.
     */
    @JsonProperty("key")
    private String key;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastViewedAt")
    private Optional<Long> lastViewedAt;

    /**
     * For shows and seasons, contains the number of total episodes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("leafCount")
    private Optional<Integer> leafCount;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Media")
    private Optional<? extends List<Media>> media;

    /**
     * When present, in the format YYYY-MM-DD [HH:MM:SS] (the hours/minutes/seconds part is not always present). The air date, or a higher resolution release date for an item, depending on type. For example, episodes usually have air date like 1979-08-10 (we don't use epoch seconds because media existed prior to 1970). In some cases, recorded over-the-air content has higher resolution air date which includes a time component. Albums and movies may have day-resolution release dates as well.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("originallyAvailableAt")
    private Optional<LocalDate> originallyAvailableAt;

    /**
     * When present, used to indicate an item's original title, e.g. a movie's foreign title.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("originalTitle")
    private Optional<String> originalTitle;

    /**
     * The GUID of the parent media item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentGuid")
    private Optional<String> parentGuid;

    /**
     * The `hero` of the parent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentHero")
    private Optional<String> parentHero;

    /**
     * The `index` of the parent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentIndex")
    private Optional<Integer> parentIndex;

    /**
     * The `key` of the parent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentKey")
    private Optional<String> parentKey;

    /**
     * The `ratingKey` of the parent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentRatingKey")
    private Optional<String> parentRatingKey;

    /**
     * The `thumb` of the parent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentThumb")
    private Optional<String> parentThumb;

    /**
     * The `title` of the parent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parentTitle")
    private Optional<String> parentTitle;

    /**
     * Indicates that the item has a primary extra; for a movie, this is a trailer, and for a music track it is a music video. The URL points to the metadata details endpoint for the item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("primaryExtraKey")
    private Optional<String> primaryExtraKey;

    /**
     * Prompt to give the user for this directory (such as `Search Movies`)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("prompt")
    private Optional<String> prompt;

    /**
     * When present, the rating for the item. The exact meaning and representation depends on where the rating was sourced from.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("rating")
    private Optional<Float> rating;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Rating")
    private Optional<? extends List<Tag>> ratingArray;

    /**
     * Number of ratings under this metadata
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ratingCount")
    private Optional<Integer> ratingCount;

    /**
     * When present, indicates an image to be shown with the rating. This is passed back as a small set of defined URI values, e.g. rottentomatoes://image.rating.rotten.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ratingImage")
    private Optional<String> ratingImage;

    /**
     * This is the opaque string to be passed into timeline, scrobble, and rating endpoints to identify them.  While it often appears to be numeric, this is not guaranteed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ratingKey")
    private Optional<String> ratingKey;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Role")
    private Optional<? extends List<Tag>> role;

    /**
     * Indicates this is a search directory
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("search")
    private Optional<Boolean> search;

    /**
     * Used by old clients to provide nested menus allowing for primative (but structured) navigation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("secondary")
    private Optional<Boolean> secondary;

    /**
     * When found on a show item, indicates that the children (seasons) should be skipped in favor of the grandchildren (episodes). Useful for mini-series, etc.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("skipChildren")
    private Optional<Boolean> skipChildren;

    /**
     * When present on an episode or track item, indicates parent should be skipped in favor of grandparent (show).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("skipParent")
    private Optional<Boolean> skipParent;

    /**
     * Typically only seen in metadata at a library's top level
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Sort")
    private Optional<? extends List<Sort>> sort;

    /**
     * When present, the studio or label which produced an item (e.g. movie studio for movies, record label for albums).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("studio")
    private Optional<String> studio;

    /**
     * The subtype of the video item, such as `photo` when the video item is in a photo library
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subtype")
    private Optional<String> subtype;

    /**
     * When present, the extended textual information about the item (e.g. movie plot, artist biography, album review).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("summary")
    private Optional<String> summary;

    /**
     * When present, a pithy one-liner about the item (usually only seen for movies).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tagline")
    private Optional<String> tagline;

    /**
     * When present, the URL for theme music for the item (usually only for TV shows).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("theme")
    private Optional<String> theme;

    /**
     * When present, the URL for the poster or thumbnail for the item. When available for types like movie, it will be the poster graphic, but fall-back to the extracted media thumbnail.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thumb")
    private Optional<String> thumb;

    /**
     * Whene present, this is the string used for sorting the item. It's usually the title with any leading articles removed (e.g. “Simpsons”).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("titleSort")
    private Optional<String> titleSort;

    /**
     * In units of seconds since the epoch, returns the time at which the item was last changed (e.g. had its metadata updated).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updatedAt")
    private Optional<Long> updatedAt;

    /**
     * When the user has rated an item, this contains the user rating
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userRating")
    private Optional<Float> userRating;

    /**
     * When a users has completed watched or listened to an item, this attribute contains the number of consumptions.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("viewCount")
    private Optional<Integer> viewCount;

    /**
     * For shows and seasons, contains the number of viewed episodes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("viewedLeafCount")
    private Optional<Integer> viewedLeafCount;

    /**
     * When a user is in the process of viewing or listening to this item, this attribute contains the current offset, in units of milliseconds.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("viewOffset")
    private Optional<Integer> viewOffset;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Writer")
    private Optional<? extends List<Tag>> writer;

    /**
     * When present, the year associated with the item's release (e.g. release year for a movie).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("year")
    private Optional<Integer> year;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("MetadataItem")
    private Optional<? extends List<Items>> metadataItem;


    @JsonIgnore
    private Map<String, Object> additionalProperties;

    @JsonCreator
    public Items(
            @JsonProperty("title") String title,
            @JsonProperty("type") String type,
            @JsonProperty("absoluteIndex") Optional<Integer> absoluteIndex,
            @JsonProperty("addedAt") long addedAt,
            @JsonProperty("art") Optional<String> art,
            @JsonProperty("audienceRating") Optional<Float> audienceRating,
            @JsonProperty("audienceRatingImage") Optional<String> audienceRatingImage,
            @JsonProperty("Autotag") Optional<? extends List<Tag>> autotag,
            @JsonProperty("banner") Optional<String> banner,
            @JsonProperty("chapterSource") Optional<String> chapterSource,
            @JsonProperty("childCount") Optional<Integer> childCount,
            @JsonProperty("composite") Optional<String> composite,
            @JsonProperty("contentRating") Optional<String> contentRating,
            @JsonProperty("Country") Optional<? extends List<Tag>> country,
            @JsonProperty("Director") Optional<? extends List<Tag>> director,
            @JsonProperty("duration") Optional<Integer> duration,
            @JsonProperty("Filter") Optional<? extends List<Filter>> filter,
            @JsonProperty("Genre") Optional<? extends List<Tag>> genre,
            @JsonProperty("grandparentArt") Optional<String> grandparentArt,
            @JsonProperty("grandparentGuid") Optional<String> grandparentGuid,
            @JsonProperty("grandparentHero") Optional<String> grandparentHero,
            @JsonProperty("grandparentKey") Optional<String> grandparentKey,
            @JsonProperty("grandparentRatingKey") Optional<String> grandparentRatingKey,
            @JsonProperty("grandparentTheme") Optional<String> grandparentTheme,
            @JsonProperty("grandparentThumb") Optional<String> grandparentThumb,
            @JsonProperty("grandparentTitle") Optional<String> grandparentTitle,
            @JsonProperty("guid") Optional<String> guid,
            @JsonProperty("Guid") Optional<? extends List<ItemsGuids>> guids,
            @JsonProperty("hero") Optional<String> hero,
            @JsonProperty("Image") Optional<? extends List<Image>> image,
            @JsonProperty("index") Optional<Integer> index,
            @JsonProperty("key") String key,
            @JsonProperty("lastViewedAt") Optional<Long> lastViewedAt,
            @JsonProperty("leafCount") Optional<Integer> leafCount,
            @JsonProperty("Media") Optional<? extends List<Media>> media,
            @JsonProperty("originallyAvailableAt") Optional<LocalDate> originallyAvailableAt,
            @JsonProperty("originalTitle") Optional<String> originalTitle,
            @JsonProperty("parentGuid") Optional<String> parentGuid,
            @JsonProperty("parentHero") Optional<String> parentHero,
            @JsonProperty("parentIndex") Optional<Integer> parentIndex,
            @JsonProperty("parentKey") Optional<String> parentKey,
            @JsonProperty("parentRatingKey") Optional<String> parentRatingKey,
            @JsonProperty("parentThumb") Optional<String> parentThumb,
            @JsonProperty("parentTitle") Optional<String> parentTitle,
            @JsonProperty("primaryExtraKey") Optional<String> primaryExtraKey,
            @JsonProperty("prompt") Optional<String> prompt,
            @JsonProperty("rating") Optional<Float> rating,
            @JsonProperty("Rating") Optional<? extends List<Tag>> ratingArray,
            @JsonProperty("ratingCount") Optional<Integer> ratingCount,
            @JsonProperty("ratingImage") Optional<String> ratingImage,
            @JsonProperty("ratingKey") Optional<String> ratingKey,
            @JsonProperty("Role") Optional<? extends List<Tag>> role,
            @JsonProperty("search") Optional<Boolean> search,
            @JsonProperty("secondary") Optional<Boolean> secondary,
            @JsonProperty("skipChildren") Optional<Boolean> skipChildren,
            @JsonProperty("skipParent") Optional<Boolean> skipParent,
            @JsonProperty("Sort") Optional<? extends List<Sort>> sort,
            @JsonProperty("studio") Optional<String> studio,
            @JsonProperty("subtype") Optional<String> subtype,
            @JsonProperty("summary") Optional<String> summary,
            @JsonProperty("tagline") Optional<String> tagline,
            @JsonProperty("theme") Optional<String> theme,
            @JsonProperty("thumb") Optional<String> thumb,
            @JsonProperty("titleSort") Optional<String> titleSort,
            @JsonProperty("updatedAt") Optional<Long> updatedAt,
            @JsonProperty("userRating") Optional<Float> userRating,
            @JsonProperty("viewCount") Optional<Integer> viewCount,
            @JsonProperty("viewedLeafCount") Optional<Integer> viewedLeafCount,
            @JsonProperty("viewOffset") Optional<Integer> viewOffset,
            @JsonProperty("Writer") Optional<? extends List<Tag>> writer,
            @JsonProperty("year") Optional<Integer> year,
            @JsonProperty("MetadataItem") Optional<? extends List<Items>> metadataItem) {
        Utils.checkNotNull(title, "title");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(absoluteIndex, "absoluteIndex");
        Utils.checkNotNull(addedAt, "addedAt");
        Utils.checkNotNull(art, "art");
        Utils.checkNotNull(audienceRating, "audienceRating");
        Utils.checkNotNull(audienceRatingImage, "audienceRatingImage");
        Utils.checkNotNull(autotag, "autotag");
        Utils.checkNotNull(banner, "banner");
        Utils.checkNotNull(chapterSource, "chapterSource");
        Utils.checkNotNull(childCount, "childCount");
        Utils.checkNotNull(composite, "composite");
        Utils.checkNotNull(contentRating, "contentRating");
        Utils.checkNotNull(country, "country");
        Utils.checkNotNull(director, "director");
        Utils.checkNotNull(duration, "duration");
        Utils.checkNotNull(filter, "filter");
        Utils.checkNotNull(genre, "genre");
        Utils.checkNotNull(grandparentArt, "grandparentArt");
        Utils.checkNotNull(grandparentGuid, "grandparentGuid");
        Utils.checkNotNull(grandparentHero, "grandparentHero");
        Utils.checkNotNull(grandparentKey, "grandparentKey");
        Utils.checkNotNull(grandparentRatingKey, "grandparentRatingKey");
        Utils.checkNotNull(grandparentTheme, "grandparentTheme");
        Utils.checkNotNull(grandparentThumb, "grandparentThumb");
        Utils.checkNotNull(grandparentTitle, "grandparentTitle");
        Utils.checkNotNull(guid, "guid");
        Utils.checkNotNull(guids, "guids");
        Utils.checkNotNull(hero, "hero");
        Utils.checkNotNull(image, "image");
        Utils.checkNotNull(index, "index");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(lastViewedAt, "lastViewedAt");
        Utils.checkNotNull(leafCount, "leafCount");
        Utils.checkNotNull(media, "media");
        Utils.checkNotNull(originallyAvailableAt, "originallyAvailableAt");
        Utils.checkNotNull(originalTitle, "originalTitle");
        Utils.checkNotNull(parentGuid, "parentGuid");
        Utils.checkNotNull(parentHero, "parentHero");
        Utils.checkNotNull(parentIndex, "parentIndex");
        Utils.checkNotNull(parentKey, "parentKey");
        Utils.checkNotNull(parentRatingKey, "parentRatingKey");
        Utils.checkNotNull(parentThumb, "parentThumb");
        Utils.checkNotNull(parentTitle, "parentTitle");
        Utils.checkNotNull(primaryExtraKey, "primaryExtraKey");
        Utils.checkNotNull(prompt, "prompt");
        Utils.checkNotNull(rating, "rating");
        Utils.checkNotNull(ratingArray, "ratingArray");
        Utils.checkNotNull(ratingCount, "ratingCount");
        Utils.checkNotNull(ratingImage, "ratingImage");
        Utils.checkNotNull(ratingKey, "ratingKey");
        Utils.checkNotNull(role, "role");
        Utils.checkNotNull(search, "search");
        Utils.checkNotNull(secondary, "secondary");
        Utils.checkNotNull(skipChildren, "skipChildren");
        Utils.checkNotNull(skipParent, "skipParent");
        Utils.checkNotNull(sort, "sort");
        Utils.checkNotNull(studio, "studio");
        Utils.checkNotNull(subtype, "subtype");
        Utils.checkNotNull(summary, "summary");
        Utils.checkNotNull(tagline, "tagline");
        Utils.checkNotNull(theme, "theme");
        Utils.checkNotNull(thumb, "thumb");
        Utils.checkNotNull(titleSort, "titleSort");
        Utils.checkNotNull(updatedAt, "updatedAt");
        Utils.checkNotNull(userRating, "userRating");
        Utils.checkNotNull(viewCount, "viewCount");
        Utils.checkNotNull(viewedLeafCount, "viewedLeafCount");
        Utils.checkNotNull(viewOffset, "viewOffset");
        Utils.checkNotNull(writer, "writer");
        Utils.checkNotNull(year, "year");
        Utils.checkNotNull(metadataItem, "metadataItem");
        this.title = title;
        this.type = type;
        this.absoluteIndex = absoluteIndex;
        this.addedAt = addedAt;
        this.art = art;
        this.audienceRating = audienceRating;
        this.audienceRatingImage = audienceRatingImage;
        this.autotag = autotag;
        this.banner = banner;
        this.chapterSource = chapterSource;
        this.childCount = childCount;
        this.composite = composite;
        this.contentRating = contentRating;
        this.country = country;
        this.director = director;
        this.duration = duration;
        this.filter = filter;
        this.genre = genre;
        this.grandparentArt = grandparentArt;
        this.grandparentGuid = grandparentGuid;
        this.grandparentHero = grandparentHero;
        this.grandparentKey = grandparentKey;
        this.grandparentRatingKey = grandparentRatingKey;
        this.grandparentTheme = grandparentTheme;
        this.grandparentThumb = grandparentThumb;
        this.grandparentTitle = grandparentTitle;
        this.guid = guid;
        this.guids = guids;
        this.hero = hero;
        this.image = image;
        this.index = index;
        this.key = key;
        this.lastViewedAt = lastViewedAt;
        this.leafCount = leafCount;
        this.media = media;
        this.originallyAvailableAt = originallyAvailableAt;
        this.originalTitle = originalTitle;
        this.parentGuid = parentGuid;
        this.parentHero = parentHero;
        this.parentIndex = parentIndex;
        this.parentKey = parentKey;
        this.parentRatingKey = parentRatingKey;
        this.parentThumb = parentThumb;
        this.parentTitle = parentTitle;
        this.primaryExtraKey = primaryExtraKey;
        this.prompt = prompt;
        this.rating = rating;
        this.ratingArray = ratingArray;
        this.ratingCount = ratingCount;
        this.ratingImage = ratingImage;
        this.ratingKey = ratingKey;
        this.role = role;
        this.search = search;
        this.secondary = secondary;
        this.skipChildren = skipChildren;
        this.skipParent = skipParent;
        this.sort = sort;
        this.studio = studio;
        this.subtype = subtype;
        this.summary = summary;
        this.tagline = tagline;
        this.theme = theme;
        this.thumb = thumb;
        this.titleSort = titleSort;
        this.updatedAt = updatedAt;
        this.userRating = userRating;
        this.viewCount = viewCount;
        this.viewedLeafCount = viewedLeafCount;
        this.viewOffset = viewOffset;
        this.writer = writer;
        this.year = year;
        this.metadataItem = metadataItem;
        this.additionalProperties = new HashMap<>();
    }
    
    public Items(
            String title,
            String type,
            long addedAt,
            String key) {
        this(title, type, Optional.empty(),
            addedAt, Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), key, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The title of the item (e.g. “300” or “The Simpsons”)
     */
    @JsonIgnore
    public String title() {
        return title;
    }

    /**
     * The type of the video item, such as `movie`, `episode`, or `clip`.
     */
    @JsonIgnore
    public String type() {
        return type;
    }

    /**
     * When present, contains the disc number for a track on multi-disc albums.
     */
    @JsonIgnore
    public Optional<Integer> absoluteIndex() {
        return absoluteIndex;
    }

    /**
     * In units of seconds since the epoch, returns the time at which the item was added to the library.
     */
    @JsonIgnore
    public long addedAt() {
        return addedAt;
    }

    /**
     * When present, the URL for the background artwork for the item.
     */
    @JsonIgnore
    public Optional<String> art() {
        return art;
    }

    /**
     * Some rating systems separate reviewer ratings from audience ratings
     */
    @JsonIgnore
    public Optional<Float> audienceRating() {
        return audienceRating;
    }

    /**
     * A URI representing the image to be shown with the audience rating (e.g. rottentomatoes://image.rating.spilled).
     */
    @JsonIgnore
    public Optional<String> audienceRatingImage() {
        return audienceRatingImage;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Tag>> autotag() {
        return (Optional<List<Tag>>) autotag;
    }

    /**
     * When present, the URL for a banner graphic for the item.
     */
    @JsonIgnore
    public Optional<String> banner() {
        return banner;
    }

    /**
     * When present, indicates the source for the chapters in the media file. Can be media (the chapters were embedded in the media itself), agent (a metadata agent computed them), or mixed (a combination of the two).
     */
    @JsonIgnore
    public Optional<String> chapterSource() {
        return chapterSource;
    }

    /**
     * The number of child items associated with this media item.
     */
    @JsonIgnore
    public Optional<Integer> childCount() {
        return childCount;
    }

    /**
     * When present, the URL for a composite image for descendent items (e.g. photo albums or playlists).
     */
    @JsonIgnore
    public Optional<String> composite() {
        return composite;
    }

    /**
     * If known, the content rating (e.g. MPAA) for an item.
     */
    @JsonIgnore
    public Optional<String> contentRating() {
        return contentRating;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Tag>> country() {
        return (Optional<List<Tag>>) country;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Tag>> director() {
        return (Optional<List<Tag>>) director;
    }

    /**
     * When present, the duration for the item, in units of milliseconds.
     */
    @JsonIgnore
    public Optional<Integer> duration() {
        return duration;
    }

    /**
     * Typically only seen in metadata at a library's top level
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Filter>> filter() {
        return (Optional<List<Filter>>) filter;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Tag>> genre() {
        return (Optional<List<Tag>>) genre;
    }

    /**
     * The `art` of the grandparent
     */
    @JsonIgnore
    public Optional<String> grandparentArt() {
        return grandparentArt;
    }

    /**
     * The GUID of the grandparent media item.
     */
    @JsonIgnore
    public Optional<String> grandparentGuid() {
        return grandparentGuid;
    }

    /**
     * The `hero` of the grandparent
     */
    @JsonIgnore
    public Optional<String> grandparentHero() {
        return grandparentHero;
    }

    /**
     * The `key` of the grandparent
     */
    @JsonIgnore
    public Optional<String> grandparentKey() {
        return grandparentKey;
    }

    /**
     * The `ratingKey` of the grandparent
     */
    @JsonIgnore
    public Optional<String> grandparentRatingKey() {
        return grandparentRatingKey;
    }

    /**
     * The `theme` of the grandparent
     */
    @JsonIgnore
    public Optional<String> grandparentTheme() {
        return grandparentTheme;
    }

    /**
     * The `thumb` of the grandparent
     */
    @JsonIgnore
    public Optional<String> grandparentThumb() {
        return grandparentThumb;
    }

    /**
     * The `title` of the grandparent
     */
    @JsonIgnore
    public Optional<String> grandparentTitle() {
        return grandparentTitle;
    }

    /**
     * The globally unique identifier for the media item.
     */
    @JsonIgnore
    public Optional<String> guid() {
        return guid;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<ItemsGuids>> guids() {
        return (Optional<List<ItemsGuids>>) guids;
    }

    /**
     * When present, the URL for a hero image for the item.
     */
    @JsonIgnore
    public Optional<String> hero() {
        return hero;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Image>> image() {
        return (Optional<List<Image>>) image;
    }

    /**
     * When present, this represents the episode number for episodes, season number for seasons, or track number for audio tracks.
     */
    @JsonIgnore
    public Optional<Integer> index() {
        return index;
    }

    /**
     * The key at which the item's details can be fetched.  In many cases a metadata item may be passed without all the details (such as in a hub) and this key corresponds to the endpoint to fetch additional details.
     */
    @JsonIgnore
    public String key() {
        return key;
    }

    @JsonIgnore
    public Optional<Long> lastViewedAt() {
        return lastViewedAt;
    }

    /**
     * For shows and seasons, contains the number of total episodes.
     */
    @JsonIgnore
    public Optional<Integer> leafCount() {
        return leafCount;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Media>> media() {
        return (Optional<List<Media>>) media;
    }

    /**
     * When present, in the format YYYY-MM-DD [HH:MM:SS] (the hours/minutes/seconds part is not always present). The air date, or a higher resolution release date for an item, depending on type. For example, episodes usually have air date like 1979-08-10 (we don't use epoch seconds because media existed prior to 1970). In some cases, recorded over-the-air content has higher resolution air date which includes a time component. Albums and movies may have day-resolution release dates as well.
     */
    @JsonIgnore
    public Optional<LocalDate> originallyAvailableAt() {
        return originallyAvailableAt;
    }

    /**
     * When present, used to indicate an item's original title, e.g. a movie's foreign title.
     */
    @JsonIgnore
    public Optional<String> originalTitle() {
        return originalTitle;
    }

    /**
     * The GUID of the parent media item.
     */
    @JsonIgnore
    public Optional<String> parentGuid() {
        return parentGuid;
    }

    /**
     * The `hero` of the parent
     */
    @JsonIgnore
    public Optional<String> parentHero() {
        return parentHero;
    }

    /**
     * The `index` of the parent
     */
    @JsonIgnore
    public Optional<Integer> parentIndex() {
        return parentIndex;
    }

    /**
     * The `key` of the parent
     */
    @JsonIgnore
    public Optional<String> parentKey() {
        return parentKey;
    }

    /**
     * The `ratingKey` of the parent
     */
    @JsonIgnore
    public Optional<String> parentRatingKey() {
        return parentRatingKey;
    }

    /**
     * The `thumb` of the parent
     */
    @JsonIgnore
    public Optional<String> parentThumb() {
        return parentThumb;
    }

    /**
     * The `title` of the parent
     */
    @JsonIgnore
    public Optional<String> parentTitle() {
        return parentTitle;
    }

    /**
     * Indicates that the item has a primary extra; for a movie, this is a trailer, and for a music track it is a music video. The URL points to the metadata details endpoint for the item.
     */
    @JsonIgnore
    public Optional<String> primaryExtraKey() {
        return primaryExtraKey;
    }

    /**
     * Prompt to give the user for this directory (such as `Search Movies`)
     */
    @JsonIgnore
    public Optional<String> prompt() {
        return prompt;
    }

    /**
     * When present, the rating for the item. The exact meaning and representation depends on where the rating was sourced from.
     */
    @JsonIgnore
    public Optional<Float> rating() {
        return rating;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Tag>> ratingArray() {
        return (Optional<List<Tag>>) ratingArray;
    }

    /**
     * Number of ratings under this metadata
     */
    @JsonIgnore
    public Optional<Integer> ratingCount() {
        return ratingCount;
    }

    /**
     * When present, indicates an image to be shown with the rating. This is passed back as a small set of defined URI values, e.g. rottentomatoes://image.rating.rotten.
     */
    @JsonIgnore
    public Optional<String> ratingImage() {
        return ratingImage;
    }

    /**
     * This is the opaque string to be passed into timeline, scrobble, and rating endpoints to identify them.  While it often appears to be numeric, this is not guaranteed.
     */
    @JsonIgnore
    public Optional<String> ratingKey() {
        return ratingKey;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Tag>> role() {
        return (Optional<List<Tag>>) role;
    }

    /**
     * Indicates this is a search directory
     */
    @JsonIgnore
    public Optional<Boolean> search() {
        return search;
    }

    /**
     * Used by old clients to provide nested menus allowing for primative (but structured) navigation.
     */
    @JsonIgnore
    public Optional<Boolean> secondary() {
        return secondary;
    }

    /**
     * When found on a show item, indicates that the children (seasons) should be skipped in favor of the grandchildren (episodes). Useful for mini-series, etc.
     */
    @JsonIgnore
    public Optional<Boolean> skipChildren() {
        return skipChildren;
    }

    /**
     * When present on an episode or track item, indicates parent should be skipped in favor of grandparent (show).
     */
    @JsonIgnore
    public Optional<Boolean> skipParent() {
        return skipParent;
    }

    /**
     * Typically only seen in metadata at a library's top level
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Sort>> sort() {
        return (Optional<List<Sort>>) sort;
    }

    /**
     * When present, the studio or label which produced an item (e.g. movie studio for movies, record label for albums).
     */
    @JsonIgnore
    public Optional<String> studio() {
        return studio;
    }

    /**
     * The subtype of the video item, such as `photo` when the video item is in a photo library
     */
    @JsonIgnore
    public Optional<String> subtype() {
        return subtype;
    }

    /**
     * When present, the extended textual information about the item (e.g. movie plot, artist biography, album review).
     */
    @JsonIgnore
    public Optional<String> summary() {
        return summary;
    }

    /**
     * When present, a pithy one-liner about the item (usually only seen for movies).
     */
    @JsonIgnore
    public Optional<String> tagline() {
        return tagline;
    }

    /**
     * When present, the URL for theme music for the item (usually only for TV shows).
     */
    @JsonIgnore
    public Optional<String> theme() {
        return theme;
    }

    /**
     * When present, the URL for the poster or thumbnail for the item. When available for types like movie, it will be the poster graphic, but fall-back to the extracted media thumbnail.
     */
    @JsonIgnore
    public Optional<String> thumb() {
        return thumb;
    }

    /**
     * Whene present, this is the string used for sorting the item. It's usually the title with any leading articles removed (e.g. “Simpsons”).
     */
    @JsonIgnore
    public Optional<String> titleSort() {
        return titleSort;
    }

    /**
     * In units of seconds since the epoch, returns the time at which the item was last changed (e.g. had its metadata updated).
     */
    @JsonIgnore
    public Optional<Long> updatedAt() {
        return updatedAt;
    }

    /**
     * When the user has rated an item, this contains the user rating
     */
    @JsonIgnore
    public Optional<Float> userRating() {
        return userRating;
    }

    /**
     * When a users has completed watched or listened to an item, this attribute contains the number of consumptions.
     */
    @JsonIgnore
    public Optional<Integer> viewCount() {
        return viewCount;
    }

    /**
     * For shows and seasons, contains the number of viewed episodes.
     */
    @JsonIgnore
    public Optional<Integer> viewedLeafCount() {
        return viewedLeafCount;
    }

    /**
     * When a user is in the process of viewing or listening to this item, this attribute contains the current offset, in units of milliseconds.
     */
    @JsonIgnore
    public Optional<Integer> viewOffset() {
        return viewOffset;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Tag>> writer() {
        return (Optional<List<Tag>>) writer;
    }

    /**
     * When present, the year associated with the item's release (e.g. release year for a movie).
     */
    @JsonIgnore
    public Optional<Integer> year() {
        return year;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Items>> metadataItem() {
        return (Optional<List<Items>>) metadataItem;
    }

    @JsonAnyGetter
    public Map<String, Object> additionalProperties() {
        return additionalProperties;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The title of the item (e.g. “300” or “The Simpsons”)
     */
    public Items withTitle(String title) {
        Utils.checkNotNull(title, "title");
        this.title = title;
        return this;
    }

    /**
     * The type of the video item, such as `movie`, `episode`, or `clip`.
     */
    public Items withType(String type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * When present, contains the disc number for a track on multi-disc albums.
     */
    public Items withAbsoluteIndex(int absoluteIndex) {
        Utils.checkNotNull(absoluteIndex, "absoluteIndex");
        this.absoluteIndex = Optional.ofNullable(absoluteIndex);
        return this;
    }


    /**
     * When present, contains the disc number for a track on multi-disc albums.
     */
    public Items withAbsoluteIndex(Optional<Integer> absoluteIndex) {
        Utils.checkNotNull(absoluteIndex, "absoluteIndex");
        this.absoluteIndex = absoluteIndex;
        return this;
    }

    /**
     * In units of seconds since the epoch, returns the time at which the item was added to the library.
     */
    public Items withAddedAt(long addedAt) {
        Utils.checkNotNull(addedAt, "addedAt");
        this.addedAt = addedAt;
        return this;
    }

    /**
     * When present, the URL for the background artwork for the item.
     */
    public Items withArt(String art) {
        Utils.checkNotNull(art, "art");
        this.art = Optional.ofNullable(art);
        return this;
    }


    /**
     * When present, the URL for the background artwork for the item.
     */
    public Items withArt(Optional<String> art) {
        Utils.checkNotNull(art, "art");
        this.art = art;
        return this;
    }

    /**
     * Some rating systems separate reviewer ratings from audience ratings
     */
    public Items withAudienceRating(float audienceRating) {
        Utils.checkNotNull(audienceRating, "audienceRating");
        this.audienceRating = Optional.ofNullable(audienceRating);
        return this;
    }


    /**
     * Some rating systems separate reviewer ratings from audience ratings
     */
    public Items withAudienceRating(Optional<Float> audienceRating) {
        Utils.checkNotNull(audienceRating, "audienceRating");
        this.audienceRating = audienceRating;
        return this;
    }

    /**
     * A URI representing the image to be shown with the audience rating (e.g. rottentomatoes://image.rating.spilled).
     */
    public Items withAudienceRatingImage(String audienceRatingImage) {
        Utils.checkNotNull(audienceRatingImage, "audienceRatingImage");
        this.audienceRatingImage = Optional.ofNullable(audienceRatingImage);
        return this;
    }


    /**
     * A URI representing the image to be shown with the audience rating (e.g. rottentomatoes://image.rating.spilled).
     */
    public Items withAudienceRatingImage(Optional<String> audienceRatingImage) {
        Utils.checkNotNull(audienceRatingImage, "audienceRatingImage");
        this.audienceRatingImage = audienceRatingImage;
        return this;
    }

    public Items withAutotag(List<Tag> autotag) {
        Utils.checkNotNull(autotag, "autotag");
        this.autotag = Optional.ofNullable(autotag);
        return this;
    }


    public Items withAutotag(Optional<? extends List<Tag>> autotag) {
        Utils.checkNotNull(autotag, "autotag");
        this.autotag = autotag;
        return this;
    }

    /**
     * When present, the URL for a banner graphic for the item.
     */
    public Items withBanner(String banner) {
        Utils.checkNotNull(banner, "banner");
        this.banner = Optional.ofNullable(banner);
        return this;
    }


    /**
     * When present, the URL for a banner graphic for the item.
     */
    public Items withBanner(Optional<String> banner) {
        Utils.checkNotNull(banner, "banner");
        this.banner = banner;
        return this;
    }

    /**
     * When present, indicates the source for the chapters in the media file. Can be media (the chapters were embedded in the media itself), agent (a metadata agent computed them), or mixed (a combination of the two).
     */
    public Items withChapterSource(String chapterSource) {
        Utils.checkNotNull(chapterSource, "chapterSource");
        this.chapterSource = Optional.ofNullable(chapterSource);
        return this;
    }


    /**
     * When present, indicates the source for the chapters in the media file. Can be media (the chapters were embedded in the media itself), agent (a metadata agent computed them), or mixed (a combination of the two).
     */
    public Items withChapterSource(Optional<String> chapterSource) {
        Utils.checkNotNull(chapterSource, "chapterSource");
        this.chapterSource = chapterSource;
        return this;
    }

    /**
     * The number of child items associated with this media item.
     */
    public Items withChildCount(int childCount) {
        Utils.checkNotNull(childCount, "childCount");
        this.childCount = Optional.ofNullable(childCount);
        return this;
    }


    /**
     * The number of child items associated with this media item.
     */
    public Items withChildCount(Optional<Integer> childCount) {
        Utils.checkNotNull(childCount, "childCount");
        this.childCount = childCount;
        return this;
    }

    /**
     * When present, the URL for a composite image for descendent items (e.g. photo albums or playlists).
     */
    public Items withComposite(String composite) {
        Utils.checkNotNull(composite, "composite");
        this.composite = Optional.ofNullable(composite);
        return this;
    }


    /**
     * When present, the URL for a composite image for descendent items (e.g. photo albums or playlists).
     */
    public Items withComposite(Optional<String> composite) {
        Utils.checkNotNull(composite, "composite");
        this.composite = composite;
        return this;
    }

    /**
     * If known, the content rating (e.g. MPAA) for an item.
     */
    public Items withContentRating(String contentRating) {
        Utils.checkNotNull(contentRating, "contentRating");
        this.contentRating = Optional.ofNullable(contentRating);
        return this;
    }


    /**
     * If known, the content rating (e.g. MPAA) for an item.
     */
    public Items withContentRating(Optional<String> contentRating) {
        Utils.checkNotNull(contentRating, "contentRating");
        this.contentRating = contentRating;
        return this;
    }

    public Items withCountry(List<Tag> country) {
        Utils.checkNotNull(country, "country");
        this.country = Optional.ofNullable(country);
        return this;
    }


    public Items withCountry(Optional<? extends List<Tag>> country) {
        Utils.checkNotNull(country, "country");
        this.country = country;
        return this;
    }

    public Items withDirector(List<Tag> director) {
        Utils.checkNotNull(director, "director");
        this.director = Optional.ofNullable(director);
        return this;
    }


    public Items withDirector(Optional<? extends List<Tag>> director) {
        Utils.checkNotNull(director, "director");
        this.director = director;
        return this;
    }

    /**
     * When present, the duration for the item, in units of milliseconds.
     */
    public Items withDuration(int duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = Optional.ofNullable(duration);
        return this;
    }


    /**
     * When present, the duration for the item, in units of milliseconds.
     */
    public Items withDuration(Optional<Integer> duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = duration;
        return this;
    }

    /**
     * Typically only seen in metadata at a library's top level
     */
    public Items withFilter(List<Filter> filter) {
        Utils.checkNotNull(filter, "filter");
        this.filter = Optional.ofNullable(filter);
        return this;
    }


    /**
     * Typically only seen in metadata at a library's top level
     */
    public Items withFilter(Optional<? extends List<Filter>> filter) {
        Utils.checkNotNull(filter, "filter");
        this.filter = filter;
        return this;
    }

    public Items withGenre(List<Tag> genre) {
        Utils.checkNotNull(genre, "genre");
        this.genre = Optional.ofNullable(genre);
        return this;
    }


    public Items withGenre(Optional<? extends List<Tag>> genre) {
        Utils.checkNotNull(genre, "genre");
        this.genre = genre;
        return this;
    }

    /**
     * The `art` of the grandparent
     */
    public Items withGrandparentArt(String grandparentArt) {
        Utils.checkNotNull(grandparentArt, "grandparentArt");
        this.grandparentArt = Optional.ofNullable(grandparentArt);
        return this;
    }


    /**
     * The `art` of the grandparent
     */
    public Items withGrandparentArt(Optional<String> grandparentArt) {
        Utils.checkNotNull(grandparentArt, "grandparentArt");
        this.grandparentArt = grandparentArt;
        return this;
    }

    /**
     * The GUID of the grandparent media item.
     */
    public Items withGrandparentGuid(String grandparentGuid) {
        Utils.checkNotNull(grandparentGuid, "grandparentGuid");
        this.grandparentGuid = Optional.ofNullable(grandparentGuid);
        return this;
    }


    /**
     * The GUID of the grandparent media item.
     */
    public Items withGrandparentGuid(Optional<String> grandparentGuid) {
        Utils.checkNotNull(grandparentGuid, "grandparentGuid");
        this.grandparentGuid = grandparentGuid;
        return this;
    }

    /**
     * The `hero` of the grandparent
     */
    public Items withGrandparentHero(String grandparentHero) {
        Utils.checkNotNull(grandparentHero, "grandparentHero");
        this.grandparentHero = Optional.ofNullable(grandparentHero);
        return this;
    }


    /**
     * The `hero` of the grandparent
     */
    public Items withGrandparentHero(Optional<String> grandparentHero) {
        Utils.checkNotNull(grandparentHero, "grandparentHero");
        this.grandparentHero = grandparentHero;
        return this;
    }

    /**
     * The `key` of the grandparent
     */
    public Items withGrandparentKey(String grandparentKey) {
        Utils.checkNotNull(grandparentKey, "grandparentKey");
        this.grandparentKey = Optional.ofNullable(grandparentKey);
        return this;
    }


    /**
     * The `key` of the grandparent
     */
    public Items withGrandparentKey(Optional<String> grandparentKey) {
        Utils.checkNotNull(grandparentKey, "grandparentKey");
        this.grandparentKey = grandparentKey;
        return this;
    }

    /**
     * The `ratingKey` of the grandparent
     */
    public Items withGrandparentRatingKey(String grandparentRatingKey) {
        Utils.checkNotNull(grandparentRatingKey, "grandparentRatingKey");
        this.grandparentRatingKey = Optional.ofNullable(grandparentRatingKey);
        return this;
    }


    /**
     * The `ratingKey` of the grandparent
     */
    public Items withGrandparentRatingKey(Optional<String> grandparentRatingKey) {
        Utils.checkNotNull(grandparentRatingKey, "grandparentRatingKey");
        this.grandparentRatingKey = grandparentRatingKey;
        return this;
    }

    /**
     * The `theme` of the grandparent
     */
    public Items withGrandparentTheme(String grandparentTheme) {
        Utils.checkNotNull(grandparentTheme, "grandparentTheme");
        this.grandparentTheme = Optional.ofNullable(grandparentTheme);
        return this;
    }


    /**
     * The `theme` of the grandparent
     */
    public Items withGrandparentTheme(Optional<String> grandparentTheme) {
        Utils.checkNotNull(grandparentTheme, "grandparentTheme");
        this.grandparentTheme = grandparentTheme;
        return this;
    }

    /**
     * The `thumb` of the grandparent
     */
    public Items withGrandparentThumb(String grandparentThumb) {
        Utils.checkNotNull(grandparentThumb, "grandparentThumb");
        this.grandparentThumb = Optional.ofNullable(grandparentThumb);
        return this;
    }


    /**
     * The `thumb` of the grandparent
     */
    public Items withGrandparentThumb(Optional<String> grandparentThumb) {
        Utils.checkNotNull(grandparentThumb, "grandparentThumb");
        this.grandparentThumb = grandparentThumb;
        return this;
    }

    /**
     * The `title` of the grandparent
     */
    public Items withGrandparentTitle(String grandparentTitle) {
        Utils.checkNotNull(grandparentTitle, "grandparentTitle");
        this.grandparentTitle = Optional.ofNullable(grandparentTitle);
        return this;
    }


    /**
     * The `title` of the grandparent
     */
    public Items withGrandparentTitle(Optional<String> grandparentTitle) {
        Utils.checkNotNull(grandparentTitle, "grandparentTitle");
        this.grandparentTitle = grandparentTitle;
        return this;
    }

    /**
     * The globally unique identifier for the media item.
     */
    public Items withGuid(String guid) {
        Utils.checkNotNull(guid, "guid");
        this.guid = Optional.ofNullable(guid);
        return this;
    }


    /**
     * The globally unique identifier for the media item.
     */
    public Items withGuid(Optional<String> guid) {
        Utils.checkNotNull(guid, "guid");
        this.guid = guid;
        return this;
    }

    public Items withGuids(List<ItemsGuids> guids) {
        Utils.checkNotNull(guids, "guids");
        this.guids = Optional.ofNullable(guids);
        return this;
    }


    public Items withGuids(Optional<? extends List<ItemsGuids>> guids) {
        Utils.checkNotNull(guids, "guids");
        this.guids = guids;
        return this;
    }

    /**
     * When present, the URL for a hero image for the item.
     */
    public Items withHero(String hero) {
        Utils.checkNotNull(hero, "hero");
        this.hero = Optional.ofNullable(hero);
        return this;
    }


    /**
     * When present, the URL for a hero image for the item.
     */
    public Items withHero(Optional<String> hero) {
        Utils.checkNotNull(hero, "hero");
        this.hero = hero;
        return this;
    }

    public Items withImage(List<Image> image) {
        Utils.checkNotNull(image, "image");
        this.image = Optional.ofNullable(image);
        return this;
    }


    public Items withImage(Optional<? extends List<Image>> image) {
        Utils.checkNotNull(image, "image");
        this.image = image;
        return this;
    }

    /**
     * When present, this represents the episode number for episodes, season number for seasons, or track number for audio tracks.
     */
    public Items withIndex(int index) {
        Utils.checkNotNull(index, "index");
        this.index = Optional.ofNullable(index);
        return this;
    }


    /**
     * When present, this represents the episode number for episodes, season number for seasons, or track number for audio tracks.
     */
    public Items withIndex(Optional<Integer> index) {
        Utils.checkNotNull(index, "index");
        this.index = index;
        return this;
    }

    /**
     * The key at which the item's details can be fetched.  In many cases a metadata item may be passed without all the details (such as in a hub) and this key corresponds to the endpoint to fetch additional details.
     */
    public Items withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    public Items withLastViewedAt(long lastViewedAt) {
        Utils.checkNotNull(lastViewedAt, "lastViewedAt");
        this.lastViewedAt = Optional.ofNullable(lastViewedAt);
        return this;
    }


    public Items withLastViewedAt(Optional<Long> lastViewedAt) {
        Utils.checkNotNull(lastViewedAt, "lastViewedAt");
        this.lastViewedAt = lastViewedAt;
        return this;
    }

    /**
     * For shows and seasons, contains the number of total episodes.
     */
    public Items withLeafCount(int leafCount) {
        Utils.checkNotNull(leafCount, "leafCount");
        this.leafCount = Optional.ofNullable(leafCount);
        return this;
    }


    /**
     * For shows and seasons, contains the number of total episodes.
     */
    public Items withLeafCount(Optional<Integer> leafCount) {
        Utils.checkNotNull(leafCount, "leafCount");
        this.leafCount = leafCount;
        return this;
    }

    public Items withMedia(List<Media> media) {
        Utils.checkNotNull(media, "media");
        this.media = Optional.ofNullable(media);
        return this;
    }


    public Items withMedia(Optional<? extends List<Media>> media) {
        Utils.checkNotNull(media, "media");
        this.media = media;
        return this;
    }

    /**
     * When present, in the format YYYY-MM-DD [HH:MM:SS] (the hours/minutes/seconds part is not always present). The air date, or a higher resolution release date for an item, depending on type. For example, episodes usually have air date like 1979-08-10 (we don't use epoch seconds because media existed prior to 1970). In some cases, recorded over-the-air content has higher resolution air date which includes a time component. Albums and movies may have day-resolution release dates as well.
     */
    public Items withOriginallyAvailableAt(LocalDate originallyAvailableAt) {
        Utils.checkNotNull(originallyAvailableAt, "originallyAvailableAt");
        this.originallyAvailableAt = Optional.ofNullable(originallyAvailableAt);
        return this;
    }


    /**
     * When present, in the format YYYY-MM-DD [HH:MM:SS] (the hours/minutes/seconds part is not always present). The air date, or a higher resolution release date for an item, depending on type. For example, episodes usually have air date like 1979-08-10 (we don't use epoch seconds because media existed prior to 1970). In some cases, recorded over-the-air content has higher resolution air date which includes a time component. Albums and movies may have day-resolution release dates as well.
     */
    public Items withOriginallyAvailableAt(Optional<LocalDate> originallyAvailableAt) {
        Utils.checkNotNull(originallyAvailableAt, "originallyAvailableAt");
        this.originallyAvailableAt = originallyAvailableAt;
        return this;
    }

    /**
     * When present, used to indicate an item's original title, e.g. a movie's foreign title.
     */
    public Items withOriginalTitle(String originalTitle) {
        Utils.checkNotNull(originalTitle, "originalTitle");
        this.originalTitle = Optional.ofNullable(originalTitle);
        return this;
    }


    /**
     * When present, used to indicate an item's original title, e.g. a movie's foreign title.
     */
    public Items withOriginalTitle(Optional<String> originalTitle) {
        Utils.checkNotNull(originalTitle, "originalTitle");
        this.originalTitle = originalTitle;
        return this;
    }

    /**
     * The GUID of the parent media item.
     */
    public Items withParentGuid(String parentGuid) {
        Utils.checkNotNull(parentGuid, "parentGuid");
        this.parentGuid = Optional.ofNullable(parentGuid);
        return this;
    }


    /**
     * The GUID of the parent media item.
     */
    public Items withParentGuid(Optional<String> parentGuid) {
        Utils.checkNotNull(parentGuid, "parentGuid");
        this.parentGuid = parentGuid;
        return this;
    }

    /**
     * The `hero` of the parent
     */
    public Items withParentHero(String parentHero) {
        Utils.checkNotNull(parentHero, "parentHero");
        this.parentHero = Optional.ofNullable(parentHero);
        return this;
    }


    /**
     * The `hero` of the parent
     */
    public Items withParentHero(Optional<String> parentHero) {
        Utils.checkNotNull(parentHero, "parentHero");
        this.parentHero = parentHero;
        return this;
    }

    /**
     * The `index` of the parent
     */
    public Items withParentIndex(int parentIndex) {
        Utils.checkNotNull(parentIndex, "parentIndex");
        this.parentIndex = Optional.ofNullable(parentIndex);
        return this;
    }


    /**
     * The `index` of the parent
     */
    public Items withParentIndex(Optional<Integer> parentIndex) {
        Utils.checkNotNull(parentIndex, "parentIndex");
        this.parentIndex = parentIndex;
        return this;
    }

    /**
     * The `key` of the parent
     */
    public Items withParentKey(String parentKey) {
        Utils.checkNotNull(parentKey, "parentKey");
        this.parentKey = Optional.ofNullable(parentKey);
        return this;
    }


    /**
     * The `key` of the parent
     */
    public Items withParentKey(Optional<String> parentKey) {
        Utils.checkNotNull(parentKey, "parentKey");
        this.parentKey = parentKey;
        return this;
    }

    /**
     * The `ratingKey` of the parent
     */
    public Items withParentRatingKey(String parentRatingKey) {
        Utils.checkNotNull(parentRatingKey, "parentRatingKey");
        this.parentRatingKey = Optional.ofNullable(parentRatingKey);
        return this;
    }


    /**
     * The `ratingKey` of the parent
     */
    public Items withParentRatingKey(Optional<String> parentRatingKey) {
        Utils.checkNotNull(parentRatingKey, "parentRatingKey");
        this.parentRatingKey = parentRatingKey;
        return this;
    }

    /**
     * The `thumb` of the parent
     */
    public Items withParentThumb(String parentThumb) {
        Utils.checkNotNull(parentThumb, "parentThumb");
        this.parentThumb = Optional.ofNullable(parentThumb);
        return this;
    }


    /**
     * The `thumb` of the parent
     */
    public Items withParentThumb(Optional<String> parentThumb) {
        Utils.checkNotNull(parentThumb, "parentThumb");
        this.parentThumb = parentThumb;
        return this;
    }

    /**
     * The `title` of the parent
     */
    public Items withParentTitle(String parentTitle) {
        Utils.checkNotNull(parentTitle, "parentTitle");
        this.parentTitle = Optional.ofNullable(parentTitle);
        return this;
    }


    /**
     * The `title` of the parent
     */
    public Items withParentTitle(Optional<String> parentTitle) {
        Utils.checkNotNull(parentTitle, "parentTitle");
        this.parentTitle = parentTitle;
        return this;
    }

    /**
     * Indicates that the item has a primary extra; for a movie, this is a trailer, and for a music track it is a music video. The URL points to the metadata details endpoint for the item.
     */
    public Items withPrimaryExtraKey(String primaryExtraKey) {
        Utils.checkNotNull(primaryExtraKey, "primaryExtraKey");
        this.primaryExtraKey = Optional.ofNullable(primaryExtraKey);
        return this;
    }


    /**
     * Indicates that the item has a primary extra; for a movie, this is a trailer, and for a music track it is a music video. The URL points to the metadata details endpoint for the item.
     */
    public Items withPrimaryExtraKey(Optional<String> primaryExtraKey) {
        Utils.checkNotNull(primaryExtraKey, "primaryExtraKey");
        this.primaryExtraKey = primaryExtraKey;
        return this;
    }

    /**
     * Prompt to give the user for this directory (such as `Search Movies`)
     */
    public Items withPrompt(String prompt) {
        Utils.checkNotNull(prompt, "prompt");
        this.prompt = Optional.ofNullable(prompt);
        return this;
    }


    /**
     * Prompt to give the user for this directory (such as `Search Movies`)
     */
    public Items withPrompt(Optional<String> prompt) {
        Utils.checkNotNull(prompt, "prompt");
        this.prompt = prompt;
        return this;
    }

    /**
     * When present, the rating for the item. The exact meaning and representation depends on where the rating was sourced from.
     */
    public Items withRating(float rating) {
        Utils.checkNotNull(rating, "rating");
        this.rating = Optional.ofNullable(rating);
        return this;
    }


    /**
     * When present, the rating for the item. The exact meaning and representation depends on where the rating was sourced from.
     */
    public Items withRating(Optional<Float> rating) {
        Utils.checkNotNull(rating, "rating");
        this.rating = rating;
        return this;
    }

    public Items withRatingArray(List<Tag> ratingArray) {
        Utils.checkNotNull(ratingArray, "ratingArray");
        this.ratingArray = Optional.ofNullable(ratingArray);
        return this;
    }


    public Items withRatingArray(Optional<? extends List<Tag>> ratingArray) {
        Utils.checkNotNull(ratingArray, "ratingArray");
        this.ratingArray = ratingArray;
        return this;
    }

    /**
     * Number of ratings under this metadata
     */
    public Items withRatingCount(int ratingCount) {
        Utils.checkNotNull(ratingCount, "ratingCount");
        this.ratingCount = Optional.ofNullable(ratingCount);
        return this;
    }


    /**
     * Number of ratings under this metadata
     */
    public Items withRatingCount(Optional<Integer> ratingCount) {
        Utils.checkNotNull(ratingCount, "ratingCount");
        this.ratingCount = ratingCount;
        return this;
    }

    /**
     * When present, indicates an image to be shown with the rating. This is passed back as a small set of defined URI values, e.g. rottentomatoes://image.rating.rotten.
     */
    public Items withRatingImage(String ratingImage) {
        Utils.checkNotNull(ratingImage, "ratingImage");
        this.ratingImage = Optional.ofNullable(ratingImage);
        return this;
    }


    /**
     * When present, indicates an image to be shown with the rating. This is passed back as a small set of defined URI values, e.g. rottentomatoes://image.rating.rotten.
     */
    public Items withRatingImage(Optional<String> ratingImage) {
        Utils.checkNotNull(ratingImage, "ratingImage");
        this.ratingImage = ratingImage;
        return this;
    }

    /**
     * This is the opaque string to be passed into timeline, scrobble, and rating endpoints to identify them.  While it often appears to be numeric, this is not guaranteed.
     */
    public Items withRatingKey(String ratingKey) {
        Utils.checkNotNull(ratingKey, "ratingKey");
        this.ratingKey = Optional.ofNullable(ratingKey);
        return this;
    }


    /**
     * This is the opaque string to be passed into timeline, scrobble, and rating endpoints to identify them.  While it often appears to be numeric, this is not guaranteed.
     */
    public Items withRatingKey(Optional<String> ratingKey) {
        Utils.checkNotNull(ratingKey, "ratingKey");
        this.ratingKey = ratingKey;
        return this;
    }

    public Items withRole(List<Tag> role) {
        Utils.checkNotNull(role, "role");
        this.role = Optional.ofNullable(role);
        return this;
    }


    public Items withRole(Optional<? extends List<Tag>> role) {
        Utils.checkNotNull(role, "role");
        this.role = role;
        return this;
    }

    /**
     * Indicates this is a search directory
     */
    public Items withSearch(boolean search) {
        Utils.checkNotNull(search, "search");
        this.search = Optional.ofNullable(search);
        return this;
    }


    /**
     * Indicates this is a search directory
     */
    public Items withSearch(Optional<Boolean> search) {
        Utils.checkNotNull(search, "search");
        this.search = search;
        return this;
    }

    /**
     * Used by old clients to provide nested menus allowing for primative (but structured) navigation.
     */
    public Items withSecondary(boolean secondary) {
        Utils.checkNotNull(secondary, "secondary");
        this.secondary = Optional.ofNullable(secondary);
        return this;
    }


    /**
     * Used by old clients to provide nested menus allowing for primative (but structured) navigation.
     */
    public Items withSecondary(Optional<Boolean> secondary) {
        Utils.checkNotNull(secondary, "secondary");
        this.secondary = secondary;
        return this;
    }

    /**
     * When found on a show item, indicates that the children (seasons) should be skipped in favor of the grandchildren (episodes). Useful for mini-series, etc.
     */
    public Items withSkipChildren(boolean skipChildren) {
        Utils.checkNotNull(skipChildren, "skipChildren");
        this.skipChildren = Optional.ofNullable(skipChildren);
        return this;
    }


    /**
     * When found on a show item, indicates that the children (seasons) should be skipped in favor of the grandchildren (episodes). Useful for mini-series, etc.
     */
    public Items withSkipChildren(Optional<Boolean> skipChildren) {
        Utils.checkNotNull(skipChildren, "skipChildren");
        this.skipChildren = skipChildren;
        return this;
    }

    /**
     * When present on an episode or track item, indicates parent should be skipped in favor of grandparent (show).
     */
    public Items withSkipParent(boolean skipParent) {
        Utils.checkNotNull(skipParent, "skipParent");
        this.skipParent = Optional.ofNullable(skipParent);
        return this;
    }


    /**
     * When present on an episode or track item, indicates parent should be skipped in favor of grandparent (show).
     */
    public Items withSkipParent(Optional<Boolean> skipParent) {
        Utils.checkNotNull(skipParent, "skipParent");
        this.skipParent = skipParent;
        return this;
    }

    /**
     * Typically only seen in metadata at a library's top level
     */
    public Items withSort(List<Sort> sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = Optional.ofNullable(sort);
        return this;
    }


    /**
     * Typically only seen in metadata at a library's top level
     */
    public Items withSort(Optional<? extends List<Sort>> sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = sort;
        return this;
    }

    /**
     * When present, the studio or label which produced an item (e.g. movie studio for movies, record label for albums).
     */
    public Items withStudio(String studio) {
        Utils.checkNotNull(studio, "studio");
        this.studio = Optional.ofNullable(studio);
        return this;
    }


    /**
     * When present, the studio or label which produced an item (e.g. movie studio for movies, record label for albums).
     */
    public Items withStudio(Optional<String> studio) {
        Utils.checkNotNull(studio, "studio");
        this.studio = studio;
        return this;
    }

    /**
     * The subtype of the video item, such as `photo` when the video item is in a photo library
     */
    public Items withSubtype(String subtype) {
        Utils.checkNotNull(subtype, "subtype");
        this.subtype = Optional.ofNullable(subtype);
        return this;
    }


    /**
     * The subtype of the video item, such as `photo` when the video item is in a photo library
     */
    public Items withSubtype(Optional<String> subtype) {
        Utils.checkNotNull(subtype, "subtype");
        this.subtype = subtype;
        return this;
    }

    /**
     * When present, the extended textual information about the item (e.g. movie plot, artist biography, album review).
     */
    public Items withSummary(String summary) {
        Utils.checkNotNull(summary, "summary");
        this.summary = Optional.ofNullable(summary);
        return this;
    }


    /**
     * When present, the extended textual information about the item (e.g. movie plot, artist biography, album review).
     */
    public Items withSummary(Optional<String> summary) {
        Utils.checkNotNull(summary, "summary");
        this.summary = summary;
        return this;
    }

    /**
     * When present, a pithy one-liner about the item (usually only seen for movies).
     */
    public Items withTagline(String tagline) {
        Utils.checkNotNull(tagline, "tagline");
        this.tagline = Optional.ofNullable(tagline);
        return this;
    }


    /**
     * When present, a pithy one-liner about the item (usually only seen for movies).
     */
    public Items withTagline(Optional<String> tagline) {
        Utils.checkNotNull(tagline, "tagline");
        this.tagline = tagline;
        return this;
    }

    /**
     * When present, the URL for theme music for the item (usually only for TV shows).
     */
    public Items withTheme(String theme) {
        Utils.checkNotNull(theme, "theme");
        this.theme = Optional.ofNullable(theme);
        return this;
    }


    /**
     * When present, the URL for theme music for the item (usually only for TV shows).
     */
    public Items withTheme(Optional<String> theme) {
        Utils.checkNotNull(theme, "theme");
        this.theme = theme;
        return this;
    }

    /**
     * When present, the URL for the poster or thumbnail for the item. When available for types like movie, it will be the poster graphic, but fall-back to the extracted media thumbnail.
     */
    public Items withThumb(String thumb) {
        Utils.checkNotNull(thumb, "thumb");
        this.thumb = Optional.ofNullable(thumb);
        return this;
    }


    /**
     * When present, the URL for the poster or thumbnail for the item. When available for types like movie, it will be the poster graphic, but fall-back to the extracted media thumbnail.
     */
    public Items withThumb(Optional<String> thumb) {
        Utils.checkNotNull(thumb, "thumb");
        this.thumb = thumb;
        return this;
    }

    /**
     * Whene present, this is the string used for sorting the item. It's usually the title with any leading articles removed (e.g. “Simpsons”).
     */
    public Items withTitleSort(String titleSort) {
        Utils.checkNotNull(titleSort, "titleSort");
        this.titleSort = Optional.ofNullable(titleSort);
        return this;
    }


    /**
     * Whene present, this is the string used for sorting the item. It's usually the title with any leading articles removed (e.g. “Simpsons”).
     */
    public Items withTitleSort(Optional<String> titleSort) {
        Utils.checkNotNull(titleSort, "titleSort");
        this.titleSort = titleSort;
        return this;
    }

    /**
     * In units of seconds since the epoch, returns the time at which the item was last changed (e.g. had its metadata updated).
     */
    public Items withUpdatedAt(long updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = Optional.ofNullable(updatedAt);
        return this;
    }


    /**
     * In units of seconds since the epoch, returns the time at which the item was last changed (e.g. had its metadata updated).
     */
    public Items withUpdatedAt(Optional<Long> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    /**
     * When the user has rated an item, this contains the user rating
     */
    public Items withUserRating(float userRating) {
        Utils.checkNotNull(userRating, "userRating");
        this.userRating = Optional.ofNullable(userRating);
        return this;
    }


    /**
     * When the user has rated an item, this contains the user rating
     */
    public Items withUserRating(Optional<Float> userRating) {
        Utils.checkNotNull(userRating, "userRating");
        this.userRating = userRating;
        return this;
    }

    /**
     * When a users has completed watched or listened to an item, this attribute contains the number of consumptions.
     */
    public Items withViewCount(int viewCount) {
        Utils.checkNotNull(viewCount, "viewCount");
        this.viewCount = Optional.ofNullable(viewCount);
        return this;
    }


    /**
     * When a users has completed watched or listened to an item, this attribute contains the number of consumptions.
     */
    public Items withViewCount(Optional<Integer> viewCount) {
        Utils.checkNotNull(viewCount, "viewCount");
        this.viewCount = viewCount;
        return this;
    }

    /**
     * For shows and seasons, contains the number of viewed episodes.
     */
    public Items withViewedLeafCount(int viewedLeafCount) {
        Utils.checkNotNull(viewedLeafCount, "viewedLeafCount");
        this.viewedLeafCount = Optional.ofNullable(viewedLeafCount);
        return this;
    }


    /**
     * For shows and seasons, contains the number of viewed episodes.
     */
    public Items withViewedLeafCount(Optional<Integer> viewedLeafCount) {
        Utils.checkNotNull(viewedLeafCount, "viewedLeafCount");
        this.viewedLeafCount = viewedLeafCount;
        return this;
    }

    /**
     * When a user is in the process of viewing or listening to this item, this attribute contains the current offset, in units of milliseconds.
     */
    public Items withViewOffset(int viewOffset) {
        Utils.checkNotNull(viewOffset, "viewOffset");
        this.viewOffset = Optional.ofNullable(viewOffset);
        return this;
    }


    /**
     * When a user is in the process of viewing or listening to this item, this attribute contains the current offset, in units of milliseconds.
     */
    public Items withViewOffset(Optional<Integer> viewOffset) {
        Utils.checkNotNull(viewOffset, "viewOffset");
        this.viewOffset = viewOffset;
        return this;
    }

    public Items withWriter(List<Tag> writer) {
        Utils.checkNotNull(writer, "writer");
        this.writer = Optional.ofNullable(writer);
        return this;
    }


    public Items withWriter(Optional<? extends List<Tag>> writer) {
        Utils.checkNotNull(writer, "writer");
        this.writer = writer;
        return this;
    }

    /**
     * When present, the year associated with the item's release (e.g. release year for a movie).
     */
    public Items withYear(int year) {
        Utils.checkNotNull(year, "year");
        this.year = Optional.ofNullable(year);
        return this;
    }


    /**
     * When present, the year associated with the item's release (e.g. release year for a movie).
     */
    public Items withYear(Optional<Integer> year) {
        Utils.checkNotNull(year, "year");
        this.year = year;
        return this;
    }

    public Items withMetadataItem(List<Items> metadataItem) {
        Utils.checkNotNull(metadataItem, "metadataItem");
        this.metadataItem = Optional.ofNullable(metadataItem);
        return this;
    }


    public Items withMetadataItem(Optional<? extends List<Items>> metadataItem) {
        Utils.checkNotNull(metadataItem, "metadataItem");
        this.metadataItem = metadataItem;
        return this;
    }

    @JsonAnySetter
    public Items withAdditionalProperty(String key, Object value) {
        // note that value can be null because of the way JsonAnySetter works
        Utils.checkNotNull(key, "key");
        additionalProperties.put(key, value); 
        return this;
    }
    public Items withAdditionalProperties(Map<String, Object> additionalProperties) {
        Utils.checkNotNull(additionalProperties, "additionalProperties");
        this.additionalProperties = additionalProperties;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Items other = (Items) o;
        return 
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.absoluteIndex, other.absoluteIndex) &&
            Utils.enhancedDeepEquals(this.addedAt, other.addedAt) &&
            Utils.enhancedDeepEquals(this.art, other.art) &&
            Utils.enhancedDeepEquals(this.audienceRating, other.audienceRating) &&
            Utils.enhancedDeepEquals(this.audienceRatingImage, other.audienceRatingImage) &&
            Utils.enhancedDeepEquals(this.autotag, other.autotag) &&
            Utils.enhancedDeepEquals(this.banner, other.banner) &&
            Utils.enhancedDeepEquals(this.chapterSource, other.chapterSource) &&
            Utils.enhancedDeepEquals(this.childCount, other.childCount) &&
            Utils.enhancedDeepEquals(this.composite, other.composite) &&
            Utils.enhancedDeepEquals(this.contentRating, other.contentRating) &&
            Utils.enhancedDeepEquals(this.country, other.country) &&
            Utils.enhancedDeepEquals(this.director, other.director) &&
            Utils.enhancedDeepEquals(this.duration, other.duration) &&
            Utils.enhancedDeepEquals(this.filter, other.filter) &&
            Utils.enhancedDeepEquals(this.genre, other.genre) &&
            Utils.enhancedDeepEquals(this.grandparentArt, other.grandparentArt) &&
            Utils.enhancedDeepEquals(this.grandparentGuid, other.grandparentGuid) &&
            Utils.enhancedDeepEquals(this.grandparentHero, other.grandparentHero) &&
            Utils.enhancedDeepEquals(this.grandparentKey, other.grandparentKey) &&
            Utils.enhancedDeepEquals(this.grandparentRatingKey, other.grandparentRatingKey) &&
            Utils.enhancedDeepEquals(this.grandparentTheme, other.grandparentTheme) &&
            Utils.enhancedDeepEquals(this.grandparentThumb, other.grandparentThumb) &&
            Utils.enhancedDeepEquals(this.grandparentTitle, other.grandparentTitle) &&
            Utils.enhancedDeepEquals(this.guid, other.guid) &&
            Utils.enhancedDeepEquals(this.guids, other.guids) &&
            Utils.enhancedDeepEquals(this.hero, other.hero) &&
            Utils.enhancedDeepEquals(this.image, other.image) &&
            Utils.enhancedDeepEquals(this.index, other.index) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.lastViewedAt, other.lastViewedAt) &&
            Utils.enhancedDeepEquals(this.leafCount, other.leafCount) &&
            Utils.enhancedDeepEquals(this.media, other.media) &&
            Utils.enhancedDeepEquals(this.originallyAvailableAt, other.originallyAvailableAt) &&
            Utils.enhancedDeepEquals(this.originalTitle, other.originalTitle) &&
            Utils.enhancedDeepEquals(this.parentGuid, other.parentGuid) &&
            Utils.enhancedDeepEquals(this.parentHero, other.parentHero) &&
            Utils.enhancedDeepEquals(this.parentIndex, other.parentIndex) &&
            Utils.enhancedDeepEquals(this.parentKey, other.parentKey) &&
            Utils.enhancedDeepEquals(this.parentRatingKey, other.parentRatingKey) &&
            Utils.enhancedDeepEquals(this.parentThumb, other.parentThumb) &&
            Utils.enhancedDeepEquals(this.parentTitle, other.parentTitle) &&
            Utils.enhancedDeepEquals(this.primaryExtraKey, other.primaryExtraKey) &&
            Utils.enhancedDeepEquals(this.prompt, other.prompt) &&
            Utils.enhancedDeepEquals(this.rating, other.rating) &&
            Utils.enhancedDeepEquals(this.ratingArray, other.ratingArray) &&
            Utils.enhancedDeepEquals(this.ratingCount, other.ratingCount) &&
            Utils.enhancedDeepEquals(this.ratingImage, other.ratingImage) &&
            Utils.enhancedDeepEquals(this.ratingKey, other.ratingKey) &&
            Utils.enhancedDeepEquals(this.role, other.role) &&
            Utils.enhancedDeepEquals(this.search, other.search) &&
            Utils.enhancedDeepEquals(this.secondary, other.secondary) &&
            Utils.enhancedDeepEquals(this.skipChildren, other.skipChildren) &&
            Utils.enhancedDeepEquals(this.skipParent, other.skipParent) &&
            Utils.enhancedDeepEquals(this.sort, other.sort) &&
            Utils.enhancedDeepEquals(this.studio, other.studio) &&
            Utils.enhancedDeepEquals(this.subtype, other.subtype) &&
            Utils.enhancedDeepEquals(this.summary, other.summary) &&
            Utils.enhancedDeepEquals(this.tagline, other.tagline) &&
            Utils.enhancedDeepEquals(this.theme, other.theme) &&
            Utils.enhancedDeepEquals(this.thumb, other.thumb) &&
            Utils.enhancedDeepEquals(this.titleSort, other.titleSort) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt) &&
            Utils.enhancedDeepEquals(this.userRating, other.userRating) &&
            Utils.enhancedDeepEquals(this.viewCount, other.viewCount) &&
            Utils.enhancedDeepEquals(this.viewedLeafCount, other.viewedLeafCount) &&
            Utils.enhancedDeepEquals(this.viewOffset, other.viewOffset) &&
            Utils.enhancedDeepEquals(this.writer, other.writer) &&
            Utils.enhancedDeepEquals(this.year, other.year) &&
            Utils.enhancedDeepEquals(this.metadataItem, other.metadataItem) &&
            Utils.enhancedDeepEquals(this.additionalProperties, other.additionalProperties);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            title, type, absoluteIndex,
            addedAt, art, audienceRating,
            audienceRatingImage, autotag, banner,
            chapterSource, childCount, composite,
            contentRating, country, director,
            duration, filter, genre,
            grandparentArt, grandparentGuid, grandparentHero,
            grandparentKey, grandparentRatingKey, grandparentTheme,
            grandparentThumb, grandparentTitle, guid,
            guids, hero, image,
            index, key, lastViewedAt,
            leafCount, media, originallyAvailableAt,
            originalTitle, parentGuid, parentHero,
            parentIndex, parentKey, parentRatingKey,
            parentThumb, parentTitle, primaryExtraKey,
            prompt, rating, ratingArray,
            ratingCount, ratingImage, ratingKey,
            role, search, secondary,
            skipChildren, skipParent, sort,
            studio, subtype, summary,
            tagline, theme, thumb,
            titleSort, updatedAt, userRating,
            viewCount, viewedLeafCount, viewOffset,
            writer, year, metadataItem,
            additionalProperties);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Items.class,
                "title", title,
                "type", type,
                "absoluteIndex", absoluteIndex,
                "addedAt", addedAt,
                "art", art,
                "audienceRating", audienceRating,
                "audienceRatingImage", audienceRatingImage,
                "autotag", autotag,
                "banner", banner,
                "chapterSource", chapterSource,
                "childCount", childCount,
                "composite", composite,
                "contentRating", contentRating,
                "country", country,
                "director", director,
                "duration", duration,
                "filter", filter,
                "genre", genre,
                "grandparentArt", grandparentArt,
                "grandparentGuid", grandparentGuid,
                "grandparentHero", grandparentHero,
                "grandparentKey", grandparentKey,
                "grandparentRatingKey", grandparentRatingKey,
                "grandparentTheme", grandparentTheme,
                "grandparentThumb", grandparentThumb,
                "grandparentTitle", grandparentTitle,
                "guid", guid,
                "guids", guids,
                "hero", hero,
                "image", image,
                "index", index,
                "key", key,
                "lastViewedAt", lastViewedAt,
                "leafCount", leafCount,
                "media", media,
                "originallyAvailableAt", originallyAvailableAt,
                "originalTitle", originalTitle,
                "parentGuid", parentGuid,
                "parentHero", parentHero,
                "parentIndex", parentIndex,
                "parentKey", parentKey,
                "parentRatingKey", parentRatingKey,
                "parentThumb", parentThumb,
                "parentTitle", parentTitle,
                "primaryExtraKey", primaryExtraKey,
                "prompt", prompt,
                "rating", rating,
                "ratingArray", ratingArray,
                "ratingCount", ratingCount,
                "ratingImage", ratingImage,
                "ratingKey", ratingKey,
                "role", role,
                "search", search,
                "secondary", secondary,
                "skipChildren", skipChildren,
                "skipParent", skipParent,
                "sort", sort,
                "studio", studio,
                "subtype", subtype,
                "summary", summary,
                "tagline", tagline,
                "theme", theme,
                "thumb", thumb,
                "titleSort", titleSort,
                "updatedAt", updatedAt,
                "userRating", userRating,
                "viewCount", viewCount,
                "viewedLeafCount", viewedLeafCount,
                "viewOffset", viewOffset,
                "writer", writer,
                "year", year,
                "metadataItem", metadataItem,
                "additionalProperties", additionalProperties);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String title;

        private String type;

        private Optional<Integer> absoluteIndex = Optional.empty();

        private Long addedAt;

        private Optional<String> art = Optional.empty();

        private Optional<Float> audienceRating = Optional.empty();

        private Optional<String> audienceRatingImage = Optional.empty();

        private Optional<? extends List<Tag>> autotag = Optional.empty();

        private Optional<String> banner = Optional.empty();

        private Optional<String> chapterSource = Optional.empty();

        private Optional<Integer> childCount = Optional.empty();

        private Optional<String> composite = Optional.empty();

        private Optional<String> contentRating = Optional.empty();

        private Optional<? extends List<Tag>> country = Optional.empty();

        private Optional<? extends List<Tag>> director = Optional.empty();

        private Optional<Integer> duration = Optional.empty();

        private Optional<? extends List<Filter>> filter = Optional.empty();

        private Optional<? extends List<Tag>> genre = Optional.empty();

        private Optional<String> grandparentArt = Optional.empty();

        private Optional<String> grandparentGuid = Optional.empty();

        private Optional<String> grandparentHero = Optional.empty();

        private Optional<String> grandparentKey = Optional.empty();

        private Optional<String> grandparentRatingKey = Optional.empty();

        private Optional<String> grandparentTheme = Optional.empty();

        private Optional<String> grandparentThumb = Optional.empty();

        private Optional<String> grandparentTitle = Optional.empty();

        private Optional<String> guid = Optional.empty();

        private Optional<? extends List<ItemsGuids>> guids = Optional.empty();

        private Optional<String> hero = Optional.empty();

        private Optional<? extends List<Image>> image = Optional.empty();

        private Optional<Integer> index = Optional.empty();

        private String key;

        private Optional<Long> lastViewedAt = Optional.empty();

        private Optional<Integer> leafCount = Optional.empty();

        private Optional<? extends List<Media>> media = Optional.empty();

        private Optional<LocalDate> originallyAvailableAt = Optional.empty();

        private Optional<String> originalTitle = Optional.empty();

        private Optional<String> parentGuid = Optional.empty();

        private Optional<String> parentHero = Optional.empty();

        private Optional<Integer> parentIndex = Optional.empty();

        private Optional<String> parentKey = Optional.empty();

        private Optional<String> parentRatingKey = Optional.empty();

        private Optional<String> parentThumb = Optional.empty();

        private Optional<String> parentTitle = Optional.empty();

        private Optional<String> primaryExtraKey = Optional.empty();

        private Optional<String> prompt = Optional.empty();

        private Optional<Float> rating = Optional.empty();

        private Optional<? extends List<Tag>> ratingArray = Optional.empty();

        private Optional<Integer> ratingCount = Optional.empty();

        private Optional<String> ratingImage = Optional.empty();

        private Optional<String> ratingKey = Optional.empty();

        private Optional<? extends List<Tag>> role = Optional.empty();

        private Optional<Boolean> search = Optional.empty();

        private Optional<Boolean> secondary = Optional.empty();

        private Optional<Boolean> skipChildren = Optional.empty();

        private Optional<Boolean> skipParent = Optional.empty();

        private Optional<? extends List<Sort>> sort = Optional.empty();

        private Optional<String> studio = Optional.empty();

        private Optional<String> subtype = Optional.empty();

        private Optional<String> summary = Optional.empty();

        private Optional<String> tagline = Optional.empty();

        private Optional<String> theme = Optional.empty();

        private Optional<String> thumb = Optional.empty();

        private Optional<String> titleSort = Optional.empty();

        private Optional<Long> updatedAt = Optional.empty();

        private Optional<Float> userRating = Optional.empty();

        private Optional<Integer> viewCount = Optional.empty();

        private Optional<Integer> viewedLeafCount = Optional.empty();

        private Optional<Integer> viewOffset = Optional.empty();

        private Optional<? extends List<Tag>> writer = Optional.empty();

        private Optional<Integer> year = Optional.empty();

        private Optional<? extends List<Items>> metadataItem = Optional.empty();

        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * The title of the item (e.g. “300” or “The Simpsons”)
         */
        public Builder title(String title) {
            Utils.checkNotNull(title, "title");
            this.title = title;
            return this;
        }


        /**
         * The type of the video item, such as `movie`, `episode`, or `clip`.
         */
        public Builder type(String type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }


        /**
         * When present, contains the disc number for a track on multi-disc albums.
         */
        public Builder absoluteIndex(int absoluteIndex) {
            Utils.checkNotNull(absoluteIndex, "absoluteIndex");
            this.absoluteIndex = Optional.ofNullable(absoluteIndex);
            return this;
        }

        /**
         * When present, contains the disc number for a track on multi-disc albums.
         */
        public Builder absoluteIndex(Optional<Integer> absoluteIndex) {
            Utils.checkNotNull(absoluteIndex, "absoluteIndex");
            this.absoluteIndex = absoluteIndex;
            return this;
        }


        /**
         * In units of seconds since the epoch, returns the time at which the item was added to the library.
         */
        public Builder addedAt(long addedAt) {
            Utils.checkNotNull(addedAt, "addedAt");
            this.addedAt = addedAt;
            return this;
        }


        /**
         * When present, the URL for the background artwork for the item.
         */
        public Builder art(String art) {
            Utils.checkNotNull(art, "art");
            this.art = Optional.ofNullable(art);
            return this;
        }

        /**
         * When present, the URL for the background artwork for the item.
         */
        public Builder art(Optional<String> art) {
            Utils.checkNotNull(art, "art");
            this.art = art;
            return this;
        }


        /**
         * Some rating systems separate reviewer ratings from audience ratings
         */
        public Builder audienceRating(float audienceRating) {
            Utils.checkNotNull(audienceRating, "audienceRating");
            this.audienceRating = Optional.ofNullable(audienceRating);
            return this;
        }

        /**
         * Some rating systems separate reviewer ratings from audience ratings
         */
        public Builder audienceRating(Optional<Float> audienceRating) {
            Utils.checkNotNull(audienceRating, "audienceRating");
            this.audienceRating = audienceRating;
            return this;
        }


        /**
         * A URI representing the image to be shown with the audience rating (e.g. rottentomatoes://image.rating.spilled).
         */
        public Builder audienceRatingImage(String audienceRatingImage) {
            Utils.checkNotNull(audienceRatingImage, "audienceRatingImage");
            this.audienceRatingImage = Optional.ofNullable(audienceRatingImage);
            return this;
        }

        /**
         * A URI representing the image to be shown with the audience rating (e.g. rottentomatoes://image.rating.spilled).
         */
        public Builder audienceRatingImage(Optional<String> audienceRatingImage) {
            Utils.checkNotNull(audienceRatingImage, "audienceRatingImage");
            this.audienceRatingImage = audienceRatingImage;
            return this;
        }


        public Builder autotag(List<Tag> autotag) {
            Utils.checkNotNull(autotag, "autotag");
            this.autotag = Optional.ofNullable(autotag);
            return this;
        }

        public Builder autotag(Optional<? extends List<Tag>> autotag) {
            Utils.checkNotNull(autotag, "autotag");
            this.autotag = autotag;
            return this;
        }


        /**
         * When present, the URL for a banner graphic for the item.
         */
        public Builder banner(String banner) {
            Utils.checkNotNull(banner, "banner");
            this.banner = Optional.ofNullable(banner);
            return this;
        }

        /**
         * When present, the URL for a banner graphic for the item.
         */
        public Builder banner(Optional<String> banner) {
            Utils.checkNotNull(banner, "banner");
            this.banner = banner;
            return this;
        }


        /**
         * When present, indicates the source for the chapters in the media file. Can be media (the chapters were embedded in the media itself), agent (a metadata agent computed them), or mixed (a combination of the two).
         */
        public Builder chapterSource(String chapterSource) {
            Utils.checkNotNull(chapterSource, "chapterSource");
            this.chapterSource = Optional.ofNullable(chapterSource);
            return this;
        }

        /**
         * When present, indicates the source for the chapters in the media file. Can be media (the chapters were embedded in the media itself), agent (a metadata agent computed them), or mixed (a combination of the two).
         */
        public Builder chapterSource(Optional<String> chapterSource) {
            Utils.checkNotNull(chapterSource, "chapterSource");
            this.chapterSource = chapterSource;
            return this;
        }


        /**
         * The number of child items associated with this media item.
         */
        public Builder childCount(int childCount) {
            Utils.checkNotNull(childCount, "childCount");
            this.childCount = Optional.ofNullable(childCount);
            return this;
        }

        /**
         * The number of child items associated with this media item.
         */
        public Builder childCount(Optional<Integer> childCount) {
            Utils.checkNotNull(childCount, "childCount");
            this.childCount = childCount;
            return this;
        }


        /**
         * When present, the URL for a composite image for descendent items (e.g. photo albums or playlists).
         */
        public Builder composite(String composite) {
            Utils.checkNotNull(composite, "composite");
            this.composite = Optional.ofNullable(composite);
            return this;
        }

        /**
         * When present, the URL for a composite image for descendent items (e.g. photo albums or playlists).
         */
        public Builder composite(Optional<String> composite) {
            Utils.checkNotNull(composite, "composite");
            this.composite = composite;
            return this;
        }


        /**
         * If known, the content rating (e.g. MPAA) for an item.
         */
        public Builder contentRating(String contentRating) {
            Utils.checkNotNull(contentRating, "contentRating");
            this.contentRating = Optional.ofNullable(contentRating);
            return this;
        }

        /**
         * If known, the content rating (e.g. MPAA) for an item.
         */
        public Builder contentRating(Optional<String> contentRating) {
            Utils.checkNotNull(contentRating, "contentRating");
            this.contentRating = contentRating;
            return this;
        }


        public Builder country(List<Tag> country) {
            Utils.checkNotNull(country, "country");
            this.country = Optional.ofNullable(country);
            return this;
        }

        public Builder country(Optional<? extends List<Tag>> country) {
            Utils.checkNotNull(country, "country");
            this.country = country;
            return this;
        }


        public Builder director(List<Tag> director) {
            Utils.checkNotNull(director, "director");
            this.director = Optional.ofNullable(director);
            return this;
        }

        public Builder director(Optional<? extends List<Tag>> director) {
            Utils.checkNotNull(director, "director");
            this.director = director;
            return this;
        }


        /**
         * When present, the duration for the item, in units of milliseconds.
         */
        public Builder duration(int duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = Optional.ofNullable(duration);
            return this;
        }

        /**
         * When present, the duration for the item, in units of milliseconds.
         */
        public Builder duration(Optional<Integer> duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = duration;
            return this;
        }


        /**
         * Typically only seen in metadata at a library's top level
         */
        public Builder filter(List<Filter> filter) {
            Utils.checkNotNull(filter, "filter");
            this.filter = Optional.ofNullable(filter);
            return this;
        }

        /**
         * Typically only seen in metadata at a library's top level
         */
        public Builder filter(Optional<? extends List<Filter>> filter) {
            Utils.checkNotNull(filter, "filter");
            this.filter = filter;
            return this;
        }


        public Builder genre(List<Tag> genre) {
            Utils.checkNotNull(genre, "genre");
            this.genre = Optional.ofNullable(genre);
            return this;
        }

        public Builder genre(Optional<? extends List<Tag>> genre) {
            Utils.checkNotNull(genre, "genre");
            this.genre = genre;
            return this;
        }


        /**
         * The `art` of the grandparent
         */
        public Builder grandparentArt(String grandparentArt) {
            Utils.checkNotNull(grandparentArt, "grandparentArt");
            this.grandparentArt = Optional.ofNullable(grandparentArt);
            return this;
        }

        /**
         * The `art` of the grandparent
         */
        public Builder grandparentArt(Optional<String> grandparentArt) {
            Utils.checkNotNull(grandparentArt, "grandparentArt");
            this.grandparentArt = grandparentArt;
            return this;
        }


        /**
         * The GUID of the grandparent media item.
         */
        public Builder grandparentGuid(String grandparentGuid) {
            Utils.checkNotNull(grandparentGuid, "grandparentGuid");
            this.grandparentGuid = Optional.ofNullable(grandparentGuid);
            return this;
        }

        /**
         * The GUID of the grandparent media item.
         */
        public Builder grandparentGuid(Optional<String> grandparentGuid) {
            Utils.checkNotNull(grandparentGuid, "grandparentGuid");
            this.grandparentGuid = grandparentGuid;
            return this;
        }


        /**
         * The `hero` of the grandparent
         */
        public Builder grandparentHero(String grandparentHero) {
            Utils.checkNotNull(grandparentHero, "grandparentHero");
            this.grandparentHero = Optional.ofNullable(grandparentHero);
            return this;
        }

        /**
         * The `hero` of the grandparent
         */
        public Builder grandparentHero(Optional<String> grandparentHero) {
            Utils.checkNotNull(grandparentHero, "grandparentHero");
            this.grandparentHero = grandparentHero;
            return this;
        }


        /**
         * The `key` of the grandparent
         */
        public Builder grandparentKey(String grandparentKey) {
            Utils.checkNotNull(grandparentKey, "grandparentKey");
            this.grandparentKey = Optional.ofNullable(grandparentKey);
            return this;
        }

        /**
         * The `key` of the grandparent
         */
        public Builder grandparentKey(Optional<String> grandparentKey) {
            Utils.checkNotNull(grandparentKey, "grandparentKey");
            this.grandparentKey = grandparentKey;
            return this;
        }


        /**
         * The `ratingKey` of the grandparent
         */
        public Builder grandparentRatingKey(String grandparentRatingKey) {
            Utils.checkNotNull(grandparentRatingKey, "grandparentRatingKey");
            this.grandparentRatingKey = Optional.ofNullable(grandparentRatingKey);
            return this;
        }

        /**
         * The `ratingKey` of the grandparent
         */
        public Builder grandparentRatingKey(Optional<String> grandparentRatingKey) {
            Utils.checkNotNull(grandparentRatingKey, "grandparentRatingKey");
            this.grandparentRatingKey = grandparentRatingKey;
            return this;
        }


        /**
         * The `theme` of the grandparent
         */
        public Builder grandparentTheme(String grandparentTheme) {
            Utils.checkNotNull(grandparentTheme, "grandparentTheme");
            this.grandparentTheme = Optional.ofNullable(grandparentTheme);
            return this;
        }

        /**
         * The `theme` of the grandparent
         */
        public Builder grandparentTheme(Optional<String> grandparentTheme) {
            Utils.checkNotNull(grandparentTheme, "grandparentTheme");
            this.grandparentTheme = grandparentTheme;
            return this;
        }


        /**
         * The `thumb` of the grandparent
         */
        public Builder grandparentThumb(String grandparentThumb) {
            Utils.checkNotNull(grandparentThumb, "grandparentThumb");
            this.grandparentThumb = Optional.ofNullable(grandparentThumb);
            return this;
        }

        /**
         * The `thumb` of the grandparent
         */
        public Builder grandparentThumb(Optional<String> grandparentThumb) {
            Utils.checkNotNull(grandparentThumb, "grandparentThumb");
            this.grandparentThumb = grandparentThumb;
            return this;
        }


        /**
         * The `title` of the grandparent
         */
        public Builder grandparentTitle(String grandparentTitle) {
            Utils.checkNotNull(grandparentTitle, "grandparentTitle");
            this.grandparentTitle = Optional.ofNullable(grandparentTitle);
            return this;
        }

        /**
         * The `title` of the grandparent
         */
        public Builder grandparentTitle(Optional<String> grandparentTitle) {
            Utils.checkNotNull(grandparentTitle, "grandparentTitle");
            this.grandparentTitle = grandparentTitle;
            return this;
        }


        /**
         * The globally unique identifier for the media item.
         */
        public Builder guid(String guid) {
            Utils.checkNotNull(guid, "guid");
            this.guid = Optional.ofNullable(guid);
            return this;
        }

        /**
         * The globally unique identifier for the media item.
         */
        public Builder guid(Optional<String> guid) {
            Utils.checkNotNull(guid, "guid");
            this.guid = guid;
            return this;
        }


        public Builder guids(List<ItemsGuids> guids) {
            Utils.checkNotNull(guids, "guids");
            this.guids = Optional.ofNullable(guids);
            return this;
        }

        public Builder guids(Optional<? extends List<ItemsGuids>> guids) {
            Utils.checkNotNull(guids, "guids");
            this.guids = guids;
            return this;
        }


        /**
         * When present, the URL for a hero image for the item.
         */
        public Builder hero(String hero) {
            Utils.checkNotNull(hero, "hero");
            this.hero = Optional.ofNullable(hero);
            return this;
        }

        /**
         * When present, the URL for a hero image for the item.
         */
        public Builder hero(Optional<String> hero) {
            Utils.checkNotNull(hero, "hero");
            this.hero = hero;
            return this;
        }


        public Builder image(List<Image> image) {
            Utils.checkNotNull(image, "image");
            this.image = Optional.ofNullable(image);
            return this;
        }

        public Builder image(Optional<? extends List<Image>> image) {
            Utils.checkNotNull(image, "image");
            this.image = image;
            return this;
        }


        /**
         * When present, this represents the episode number for episodes, season number for seasons, or track number for audio tracks.
         */
        public Builder index(int index) {
            Utils.checkNotNull(index, "index");
            this.index = Optional.ofNullable(index);
            return this;
        }

        /**
         * When present, this represents the episode number for episodes, season number for seasons, or track number for audio tracks.
         */
        public Builder index(Optional<Integer> index) {
            Utils.checkNotNull(index, "index");
            this.index = index;
            return this;
        }


        /**
         * The key at which the item's details can be fetched.  In many cases a metadata item may be passed without all the details (such as in a hub) and this key corresponds to the endpoint to fetch additional details.
         */
        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        public Builder lastViewedAt(long lastViewedAt) {
            Utils.checkNotNull(lastViewedAt, "lastViewedAt");
            this.lastViewedAt = Optional.ofNullable(lastViewedAt);
            return this;
        }

        public Builder lastViewedAt(Optional<Long> lastViewedAt) {
            Utils.checkNotNull(lastViewedAt, "lastViewedAt");
            this.lastViewedAt = lastViewedAt;
            return this;
        }


        /**
         * For shows and seasons, contains the number of total episodes.
         */
        public Builder leafCount(int leafCount) {
            Utils.checkNotNull(leafCount, "leafCount");
            this.leafCount = Optional.ofNullable(leafCount);
            return this;
        }

        /**
         * For shows and seasons, contains the number of total episodes.
         */
        public Builder leafCount(Optional<Integer> leafCount) {
            Utils.checkNotNull(leafCount, "leafCount");
            this.leafCount = leafCount;
            return this;
        }


        public Builder media(List<Media> media) {
            Utils.checkNotNull(media, "media");
            this.media = Optional.ofNullable(media);
            return this;
        }

        public Builder media(Optional<? extends List<Media>> media) {
            Utils.checkNotNull(media, "media");
            this.media = media;
            return this;
        }


        /**
         * When present, in the format YYYY-MM-DD [HH:MM:SS] (the hours/minutes/seconds part is not always present). The air date, or a higher resolution release date for an item, depending on type. For example, episodes usually have air date like 1979-08-10 (we don't use epoch seconds because media existed prior to 1970). In some cases, recorded over-the-air content has higher resolution air date which includes a time component. Albums and movies may have day-resolution release dates as well.
         */
        public Builder originallyAvailableAt(LocalDate originallyAvailableAt) {
            Utils.checkNotNull(originallyAvailableAt, "originallyAvailableAt");
            this.originallyAvailableAt = Optional.ofNullable(originallyAvailableAt);
            return this;
        }

        /**
         * When present, in the format YYYY-MM-DD [HH:MM:SS] (the hours/minutes/seconds part is not always present). The air date, or a higher resolution release date for an item, depending on type. For example, episodes usually have air date like 1979-08-10 (we don't use epoch seconds because media existed prior to 1970). In some cases, recorded over-the-air content has higher resolution air date which includes a time component. Albums and movies may have day-resolution release dates as well.
         */
        public Builder originallyAvailableAt(Optional<LocalDate> originallyAvailableAt) {
            Utils.checkNotNull(originallyAvailableAt, "originallyAvailableAt");
            this.originallyAvailableAt = originallyAvailableAt;
            return this;
        }


        /**
         * When present, used to indicate an item's original title, e.g. a movie's foreign title.
         */
        public Builder originalTitle(String originalTitle) {
            Utils.checkNotNull(originalTitle, "originalTitle");
            this.originalTitle = Optional.ofNullable(originalTitle);
            return this;
        }

        /**
         * When present, used to indicate an item's original title, e.g. a movie's foreign title.
         */
        public Builder originalTitle(Optional<String> originalTitle) {
            Utils.checkNotNull(originalTitle, "originalTitle");
            this.originalTitle = originalTitle;
            return this;
        }


        /**
         * The GUID of the parent media item.
         */
        public Builder parentGuid(String parentGuid) {
            Utils.checkNotNull(parentGuid, "parentGuid");
            this.parentGuid = Optional.ofNullable(parentGuid);
            return this;
        }

        /**
         * The GUID of the parent media item.
         */
        public Builder parentGuid(Optional<String> parentGuid) {
            Utils.checkNotNull(parentGuid, "parentGuid");
            this.parentGuid = parentGuid;
            return this;
        }


        /**
         * The `hero` of the parent
         */
        public Builder parentHero(String parentHero) {
            Utils.checkNotNull(parentHero, "parentHero");
            this.parentHero = Optional.ofNullable(parentHero);
            return this;
        }

        /**
         * The `hero` of the parent
         */
        public Builder parentHero(Optional<String> parentHero) {
            Utils.checkNotNull(parentHero, "parentHero");
            this.parentHero = parentHero;
            return this;
        }


        /**
         * The `index` of the parent
         */
        public Builder parentIndex(int parentIndex) {
            Utils.checkNotNull(parentIndex, "parentIndex");
            this.parentIndex = Optional.ofNullable(parentIndex);
            return this;
        }

        /**
         * The `index` of the parent
         */
        public Builder parentIndex(Optional<Integer> parentIndex) {
            Utils.checkNotNull(parentIndex, "parentIndex");
            this.parentIndex = parentIndex;
            return this;
        }


        /**
         * The `key` of the parent
         */
        public Builder parentKey(String parentKey) {
            Utils.checkNotNull(parentKey, "parentKey");
            this.parentKey = Optional.ofNullable(parentKey);
            return this;
        }

        /**
         * The `key` of the parent
         */
        public Builder parentKey(Optional<String> parentKey) {
            Utils.checkNotNull(parentKey, "parentKey");
            this.parentKey = parentKey;
            return this;
        }


        /**
         * The `ratingKey` of the parent
         */
        public Builder parentRatingKey(String parentRatingKey) {
            Utils.checkNotNull(parentRatingKey, "parentRatingKey");
            this.parentRatingKey = Optional.ofNullable(parentRatingKey);
            return this;
        }

        /**
         * The `ratingKey` of the parent
         */
        public Builder parentRatingKey(Optional<String> parentRatingKey) {
            Utils.checkNotNull(parentRatingKey, "parentRatingKey");
            this.parentRatingKey = parentRatingKey;
            return this;
        }


        /**
         * The `thumb` of the parent
         */
        public Builder parentThumb(String parentThumb) {
            Utils.checkNotNull(parentThumb, "parentThumb");
            this.parentThumb = Optional.ofNullable(parentThumb);
            return this;
        }

        /**
         * The `thumb` of the parent
         */
        public Builder parentThumb(Optional<String> parentThumb) {
            Utils.checkNotNull(parentThumb, "parentThumb");
            this.parentThumb = parentThumb;
            return this;
        }


        /**
         * The `title` of the parent
         */
        public Builder parentTitle(String parentTitle) {
            Utils.checkNotNull(parentTitle, "parentTitle");
            this.parentTitle = Optional.ofNullable(parentTitle);
            return this;
        }

        /**
         * The `title` of the parent
         */
        public Builder parentTitle(Optional<String> parentTitle) {
            Utils.checkNotNull(parentTitle, "parentTitle");
            this.parentTitle = parentTitle;
            return this;
        }


        /**
         * Indicates that the item has a primary extra; for a movie, this is a trailer, and for a music track it is a music video. The URL points to the metadata details endpoint for the item.
         */
        public Builder primaryExtraKey(String primaryExtraKey) {
            Utils.checkNotNull(primaryExtraKey, "primaryExtraKey");
            this.primaryExtraKey = Optional.ofNullable(primaryExtraKey);
            return this;
        }

        /**
         * Indicates that the item has a primary extra; for a movie, this is a trailer, and for a music track it is a music video. The URL points to the metadata details endpoint for the item.
         */
        public Builder primaryExtraKey(Optional<String> primaryExtraKey) {
            Utils.checkNotNull(primaryExtraKey, "primaryExtraKey");
            this.primaryExtraKey = primaryExtraKey;
            return this;
        }


        /**
         * Prompt to give the user for this directory (such as `Search Movies`)
         */
        public Builder prompt(String prompt) {
            Utils.checkNotNull(prompt, "prompt");
            this.prompt = Optional.ofNullable(prompt);
            return this;
        }

        /**
         * Prompt to give the user for this directory (such as `Search Movies`)
         */
        public Builder prompt(Optional<String> prompt) {
            Utils.checkNotNull(prompt, "prompt");
            this.prompt = prompt;
            return this;
        }


        /**
         * When present, the rating for the item. The exact meaning and representation depends on where the rating was sourced from.
         */
        public Builder rating(float rating) {
            Utils.checkNotNull(rating, "rating");
            this.rating = Optional.ofNullable(rating);
            return this;
        }

        /**
         * When present, the rating for the item. The exact meaning and representation depends on where the rating was sourced from.
         */
        public Builder rating(Optional<Float> rating) {
            Utils.checkNotNull(rating, "rating");
            this.rating = rating;
            return this;
        }


        public Builder ratingArray(List<Tag> ratingArray) {
            Utils.checkNotNull(ratingArray, "ratingArray");
            this.ratingArray = Optional.ofNullable(ratingArray);
            return this;
        }

        public Builder ratingArray(Optional<? extends List<Tag>> ratingArray) {
            Utils.checkNotNull(ratingArray, "ratingArray");
            this.ratingArray = ratingArray;
            return this;
        }


        /**
         * Number of ratings under this metadata
         */
        public Builder ratingCount(int ratingCount) {
            Utils.checkNotNull(ratingCount, "ratingCount");
            this.ratingCount = Optional.ofNullable(ratingCount);
            return this;
        }

        /**
         * Number of ratings under this metadata
         */
        public Builder ratingCount(Optional<Integer> ratingCount) {
            Utils.checkNotNull(ratingCount, "ratingCount");
            this.ratingCount = ratingCount;
            return this;
        }


        /**
         * When present, indicates an image to be shown with the rating. This is passed back as a small set of defined URI values, e.g. rottentomatoes://image.rating.rotten.
         */
        public Builder ratingImage(String ratingImage) {
            Utils.checkNotNull(ratingImage, "ratingImage");
            this.ratingImage = Optional.ofNullable(ratingImage);
            return this;
        }

        /**
         * When present, indicates an image to be shown with the rating. This is passed back as a small set of defined URI values, e.g. rottentomatoes://image.rating.rotten.
         */
        public Builder ratingImage(Optional<String> ratingImage) {
            Utils.checkNotNull(ratingImage, "ratingImage");
            this.ratingImage = ratingImage;
            return this;
        }


        /**
         * This is the opaque string to be passed into timeline, scrobble, and rating endpoints to identify them.  While it often appears to be numeric, this is not guaranteed.
         */
        public Builder ratingKey(String ratingKey) {
            Utils.checkNotNull(ratingKey, "ratingKey");
            this.ratingKey = Optional.ofNullable(ratingKey);
            return this;
        }

        /**
         * This is the opaque string to be passed into timeline, scrobble, and rating endpoints to identify them.  While it often appears to be numeric, this is not guaranteed.
         */
        public Builder ratingKey(Optional<String> ratingKey) {
            Utils.checkNotNull(ratingKey, "ratingKey");
            this.ratingKey = ratingKey;
            return this;
        }


        public Builder role(List<Tag> role) {
            Utils.checkNotNull(role, "role");
            this.role = Optional.ofNullable(role);
            return this;
        }

        public Builder role(Optional<? extends List<Tag>> role) {
            Utils.checkNotNull(role, "role");
            this.role = role;
            return this;
        }


        /**
         * Indicates this is a search directory
         */
        public Builder search(boolean search) {
            Utils.checkNotNull(search, "search");
            this.search = Optional.ofNullable(search);
            return this;
        }

        /**
         * Indicates this is a search directory
         */
        public Builder search(Optional<Boolean> search) {
            Utils.checkNotNull(search, "search");
            this.search = search;
            return this;
        }


        /**
         * Used by old clients to provide nested menus allowing for primative (but structured) navigation.
         */
        public Builder secondary(boolean secondary) {
            Utils.checkNotNull(secondary, "secondary");
            this.secondary = Optional.ofNullable(secondary);
            return this;
        }

        /**
         * Used by old clients to provide nested menus allowing for primative (but structured) navigation.
         */
        public Builder secondary(Optional<Boolean> secondary) {
            Utils.checkNotNull(secondary, "secondary");
            this.secondary = secondary;
            return this;
        }


        /**
         * When found on a show item, indicates that the children (seasons) should be skipped in favor of the grandchildren (episodes). Useful for mini-series, etc.
         */
        public Builder skipChildren(boolean skipChildren) {
            Utils.checkNotNull(skipChildren, "skipChildren");
            this.skipChildren = Optional.ofNullable(skipChildren);
            return this;
        }

        /**
         * When found on a show item, indicates that the children (seasons) should be skipped in favor of the grandchildren (episodes). Useful for mini-series, etc.
         */
        public Builder skipChildren(Optional<Boolean> skipChildren) {
            Utils.checkNotNull(skipChildren, "skipChildren");
            this.skipChildren = skipChildren;
            return this;
        }


        /**
         * When present on an episode or track item, indicates parent should be skipped in favor of grandparent (show).
         */
        public Builder skipParent(boolean skipParent) {
            Utils.checkNotNull(skipParent, "skipParent");
            this.skipParent = Optional.ofNullable(skipParent);
            return this;
        }

        /**
         * When present on an episode or track item, indicates parent should be skipped in favor of grandparent (show).
         */
        public Builder skipParent(Optional<Boolean> skipParent) {
            Utils.checkNotNull(skipParent, "skipParent");
            this.skipParent = skipParent;
            return this;
        }


        /**
         * Typically only seen in metadata at a library's top level
         */
        public Builder sort(List<Sort> sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = Optional.ofNullable(sort);
            return this;
        }

        /**
         * Typically only seen in metadata at a library's top level
         */
        public Builder sort(Optional<? extends List<Sort>> sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = sort;
            return this;
        }


        /**
         * When present, the studio or label which produced an item (e.g. movie studio for movies, record label for albums).
         */
        public Builder studio(String studio) {
            Utils.checkNotNull(studio, "studio");
            this.studio = Optional.ofNullable(studio);
            return this;
        }

        /**
         * When present, the studio or label which produced an item (e.g. movie studio for movies, record label for albums).
         */
        public Builder studio(Optional<String> studio) {
            Utils.checkNotNull(studio, "studio");
            this.studio = studio;
            return this;
        }


        /**
         * The subtype of the video item, such as `photo` when the video item is in a photo library
         */
        public Builder subtype(String subtype) {
            Utils.checkNotNull(subtype, "subtype");
            this.subtype = Optional.ofNullable(subtype);
            return this;
        }

        /**
         * The subtype of the video item, such as `photo` when the video item is in a photo library
         */
        public Builder subtype(Optional<String> subtype) {
            Utils.checkNotNull(subtype, "subtype");
            this.subtype = subtype;
            return this;
        }


        /**
         * When present, the extended textual information about the item (e.g. movie plot, artist biography, album review).
         */
        public Builder summary(String summary) {
            Utils.checkNotNull(summary, "summary");
            this.summary = Optional.ofNullable(summary);
            return this;
        }

        /**
         * When present, the extended textual information about the item (e.g. movie plot, artist biography, album review).
         */
        public Builder summary(Optional<String> summary) {
            Utils.checkNotNull(summary, "summary");
            this.summary = summary;
            return this;
        }


        /**
         * When present, a pithy one-liner about the item (usually only seen for movies).
         */
        public Builder tagline(String tagline) {
            Utils.checkNotNull(tagline, "tagline");
            this.tagline = Optional.ofNullable(tagline);
            return this;
        }

        /**
         * When present, a pithy one-liner about the item (usually only seen for movies).
         */
        public Builder tagline(Optional<String> tagline) {
            Utils.checkNotNull(tagline, "tagline");
            this.tagline = tagline;
            return this;
        }


        /**
         * When present, the URL for theme music for the item (usually only for TV shows).
         */
        public Builder theme(String theme) {
            Utils.checkNotNull(theme, "theme");
            this.theme = Optional.ofNullable(theme);
            return this;
        }

        /**
         * When present, the URL for theme music for the item (usually only for TV shows).
         */
        public Builder theme(Optional<String> theme) {
            Utils.checkNotNull(theme, "theme");
            this.theme = theme;
            return this;
        }


        /**
         * When present, the URL for the poster or thumbnail for the item. When available for types like movie, it will be the poster graphic, but fall-back to the extracted media thumbnail.
         */
        public Builder thumb(String thumb) {
            Utils.checkNotNull(thumb, "thumb");
            this.thumb = Optional.ofNullable(thumb);
            return this;
        }

        /**
         * When present, the URL for the poster or thumbnail for the item. When available for types like movie, it will be the poster graphic, but fall-back to the extracted media thumbnail.
         */
        public Builder thumb(Optional<String> thumb) {
            Utils.checkNotNull(thumb, "thumb");
            this.thumb = thumb;
            return this;
        }


        /**
         * Whene present, this is the string used for sorting the item. It's usually the title with any leading articles removed (e.g. “Simpsons”).
         */
        public Builder titleSort(String titleSort) {
            Utils.checkNotNull(titleSort, "titleSort");
            this.titleSort = Optional.ofNullable(titleSort);
            return this;
        }

        /**
         * Whene present, this is the string used for sorting the item. It's usually the title with any leading articles removed (e.g. “Simpsons”).
         */
        public Builder titleSort(Optional<String> titleSort) {
            Utils.checkNotNull(titleSort, "titleSort");
            this.titleSort = titleSort;
            return this;
        }


        /**
         * In units of seconds since the epoch, returns the time at which the item was last changed (e.g. had its metadata updated).
         */
        public Builder updatedAt(long updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = Optional.ofNullable(updatedAt);
            return this;
        }

        /**
         * In units of seconds since the epoch, returns the time at which the item was last changed (e.g. had its metadata updated).
         */
        public Builder updatedAt(Optional<Long> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }


        /**
         * When the user has rated an item, this contains the user rating
         */
        public Builder userRating(float userRating) {
            Utils.checkNotNull(userRating, "userRating");
            this.userRating = Optional.ofNullable(userRating);
            return this;
        }

        /**
         * When the user has rated an item, this contains the user rating
         */
        public Builder userRating(Optional<Float> userRating) {
            Utils.checkNotNull(userRating, "userRating");
            this.userRating = userRating;
            return this;
        }


        /**
         * When a users has completed watched or listened to an item, this attribute contains the number of consumptions.
         */
        public Builder viewCount(int viewCount) {
            Utils.checkNotNull(viewCount, "viewCount");
            this.viewCount = Optional.ofNullable(viewCount);
            return this;
        }

        /**
         * When a users has completed watched or listened to an item, this attribute contains the number of consumptions.
         */
        public Builder viewCount(Optional<Integer> viewCount) {
            Utils.checkNotNull(viewCount, "viewCount");
            this.viewCount = viewCount;
            return this;
        }


        /**
         * For shows and seasons, contains the number of viewed episodes.
         */
        public Builder viewedLeafCount(int viewedLeafCount) {
            Utils.checkNotNull(viewedLeafCount, "viewedLeafCount");
            this.viewedLeafCount = Optional.ofNullable(viewedLeafCount);
            return this;
        }

        /**
         * For shows and seasons, contains the number of viewed episodes.
         */
        public Builder viewedLeafCount(Optional<Integer> viewedLeafCount) {
            Utils.checkNotNull(viewedLeafCount, "viewedLeafCount");
            this.viewedLeafCount = viewedLeafCount;
            return this;
        }


        /**
         * When a user is in the process of viewing or listening to this item, this attribute contains the current offset, in units of milliseconds.
         */
        public Builder viewOffset(int viewOffset) {
            Utils.checkNotNull(viewOffset, "viewOffset");
            this.viewOffset = Optional.ofNullable(viewOffset);
            return this;
        }

        /**
         * When a user is in the process of viewing or listening to this item, this attribute contains the current offset, in units of milliseconds.
         */
        public Builder viewOffset(Optional<Integer> viewOffset) {
            Utils.checkNotNull(viewOffset, "viewOffset");
            this.viewOffset = viewOffset;
            return this;
        }


        public Builder writer(List<Tag> writer) {
            Utils.checkNotNull(writer, "writer");
            this.writer = Optional.ofNullable(writer);
            return this;
        }

        public Builder writer(Optional<? extends List<Tag>> writer) {
            Utils.checkNotNull(writer, "writer");
            this.writer = writer;
            return this;
        }


        /**
         * When present, the year associated with the item's release (e.g. release year for a movie).
         */
        public Builder year(int year) {
            Utils.checkNotNull(year, "year");
            this.year = Optional.ofNullable(year);
            return this;
        }

        /**
         * When present, the year associated with the item's release (e.g. release year for a movie).
         */
        public Builder year(Optional<Integer> year) {
            Utils.checkNotNull(year, "year");
            this.year = year;
            return this;
        }


        public Builder metadataItem(List<Items> metadataItem) {
            Utils.checkNotNull(metadataItem, "metadataItem");
            this.metadataItem = Optional.ofNullable(metadataItem);
            return this;
        }

        public Builder metadataItem(Optional<? extends List<Items>> metadataItem) {
            Utils.checkNotNull(metadataItem, "metadataItem");
            this.metadataItem = metadataItem;
            return this;
        }

        public Builder additionalProperty(String key, Object value) {
            Utils.checkNotNull(key, "key");
            // we could be strict about null values (force the user
            // to pass `JsonNullable.of(null)`) but likely to be a bit 
            // annoying for additional properties building so we'll 
            // relax preconditions.
            this.additionalProperties.put(key, value);
            return this;
        }

        public Builder additionalProperties(Map<String, Object> additionalProperties) {
            Utils.checkNotNull(additionalProperties, "additionalProperties");
            this.additionalProperties = additionalProperties;
            return this;
        }

        public Items build() {

            return new Items(
                title, type, absoluteIndex,
                addedAt, art, audienceRating,
                audienceRatingImage, autotag, banner,
                chapterSource, childCount, composite,
                contentRating, country, director,
                duration, filter, genre,
                grandparentArt, grandparentGuid, grandparentHero,
                grandparentKey, grandparentRatingKey, grandparentTheme,
                grandparentThumb, grandparentTitle, guid,
                guids, hero, image,
                index, key, lastViewedAt,
                leafCount, media, originallyAvailableAt,
                originalTitle, parentGuid, parentHero,
                parentIndex, parentKey, parentRatingKey,
                parentThumb, parentTitle, primaryExtraKey,
                prompt, rating, ratingArray,
                ratingCount, ratingImage, ratingKey,
                role, search, secondary,
                skipChildren, skipParent, sort,
                studio, subtype, summary,
                tagline, theme, thumb,
                titleSort, updatedAt, userRating,
                viewCount, viewedLeafCount, viewOffset,
                writer, year, metadataItem)
                .withAdditionalProperties(additionalProperties);
        }

    }
}
