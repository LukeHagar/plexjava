/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Optional;


public class LibrarySection {
    /**
     * The title of the library
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title")
    private Optional<String> title;

    /**
     * The type of media content in the Plex library. This can represent videos, music, or photos.
     */
    @JsonProperty("type")
    private MediaTypeString type;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("agent")
    private Optional<String> agent;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowSync")
    private Optional<Boolean> allowSync;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("art")
    private Optional<String> art;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("composite")
    private Optional<String> composite;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("content")
    private Optional<Boolean> content;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("contentChangedAt")
    private Optional<Long> contentChangedAt;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<Long> createdAt;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("directory")
    private Optional<Boolean> directory;

    /**
     * Indicates whether this section has filtering capabilities
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("filters")
    private Optional<Boolean> filters;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hidden")
    private Optional<Boolean> hidden;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("key")
    private Optional<String> key;


    @JsonProperty("language")
    private String language;

    /**
     * The universally unique identifier for the library.
     */
    @JsonProperty("uuid")
    private String uuid;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Location")
    private Optional<? extends List<LibrarySectionLocation>> location;

    /**
     * Indicates whether this library section is currently scanning
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("refreshing")
    private Optional<Boolean> refreshing;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("scannedAt")
    private Optional<Long> scannedAt;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("scanner")
    private Optional<String> scanner;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thumb")
    private Optional<String> thumb;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updatedAt")
    private Optional<Long> updatedAt;

    @JsonCreator
    public LibrarySection(
            @JsonProperty("title") Optional<String> title,
            @JsonProperty("type") MediaTypeString type,
            @JsonProperty("agent") Optional<String> agent,
            @JsonProperty("allowSync") Optional<Boolean> allowSync,
            @JsonProperty("art") Optional<String> art,
            @JsonProperty("composite") Optional<String> composite,
            @JsonProperty("content") Optional<Boolean> content,
            @JsonProperty("contentChangedAt") Optional<Long> contentChangedAt,
            @JsonProperty("createdAt") Optional<Long> createdAt,
            @JsonProperty("directory") Optional<Boolean> directory,
            @JsonProperty("filters") Optional<Boolean> filters,
            @JsonProperty("hidden") Optional<Boolean> hidden,
            @JsonProperty("key") Optional<String> key,
            @JsonProperty("language") String language,
            @JsonProperty("uuid") String uuid,
            @JsonProperty("Location") Optional<? extends List<LibrarySectionLocation>> location,
            @JsonProperty("refreshing") Optional<Boolean> refreshing,
            @JsonProperty("scannedAt") Optional<Long> scannedAt,
            @JsonProperty("scanner") Optional<String> scanner,
            @JsonProperty("thumb") Optional<String> thumb,
            @JsonProperty("updatedAt") Optional<Long> updatedAt) {
        Utils.checkNotNull(title, "title");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(agent, "agent");
        Utils.checkNotNull(allowSync, "allowSync");
        Utils.checkNotNull(art, "art");
        Utils.checkNotNull(composite, "composite");
        Utils.checkNotNull(content, "content");
        Utils.checkNotNull(contentChangedAt, "contentChangedAt");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(directory, "directory");
        Utils.checkNotNull(filters, "filters");
        Utils.checkNotNull(hidden, "hidden");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(language, "language");
        Utils.checkNotNull(uuid, "uuid");
        Utils.checkNotNull(location, "location");
        Utils.checkNotNull(refreshing, "refreshing");
        Utils.checkNotNull(scannedAt, "scannedAt");
        Utils.checkNotNull(scanner, "scanner");
        Utils.checkNotNull(thumb, "thumb");
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.title = title;
        this.type = type;
        this.agent = agent;
        this.allowSync = allowSync;
        this.art = art;
        this.composite = composite;
        this.content = content;
        this.contentChangedAt = contentChangedAt;
        this.createdAt = createdAt;
        this.directory = directory;
        this.filters = filters;
        this.hidden = hidden;
        this.key = key;
        this.language = language;
        this.uuid = uuid;
        this.location = location;
        this.refreshing = refreshing;
        this.scannedAt = scannedAt;
        this.scanner = scanner;
        this.thumb = thumb;
        this.updatedAt = updatedAt;
    }
    
    public LibrarySection(
            MediaTypeString type,
            String language,
            String uuid) {
        this(Optional.empty(), type, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), language, uuid,
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The title of the library
     */
    @JsonIgnore
    public Optional<String> title() {
        return title;
    }

    /**
     * The type of media content in the Plex library. This can represent videos, music, or photos.
     */
    @JsonIgnore
    public MediaTypeString type() {
        return type;
    }

    @JsonIgnore
    public Optional<String> agent() {
        return agent;
    }

    @JsonIgnore
    public Optional<Boolean> allowSync() {
        return allowSync;
    }

    @JsonIgnore
    public Optional<String> art() {
        return art;
    }

    @JsonIgnore
    public Optional<String> composite() {
        return composite;
    }

    @JsonIgnore
    public Optional<Boolean> content() {
        return content;
    }

    @JsonIgnore
    public Optional<Long> contentChangedAt() {
        return contentChangedAt;
    }

    @JsonIgnore
    public Optional<Long> createdAt() {
        return createdAt;
    }

    @JsonIgnore
    public Optional<Boolean> directory() {
        return directory;
    }

    /**
     * Indicates whether this section has filtering capabilities
     */
    @JsonIgnore
    public Optional<Boolean> filters() {
        return filters;
    }

    @JsonIgnore
    public Optional<Boolean> hidden() {
        return hidden;
    }

    @JsonIgnore
    public Optional<String> key() {
        return key;
    }

    @JsonIgnore
    public String language() {
        return language;
    }

    /**
     * The universally unique identifier for the library.
     */
    @JsonIgnore
    public String uuid() {
        return uuid;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<LibrarySectionLocation>> location() {
        return (Optional<List<LibrarySectionLocation>>) location;
    }

    /**
     * Indicates whether this library section is currently scanning
     */
    @JsonIgnore
    public Optional<Boolean> refreshing() {
        return refreshing;
    }

    @JsonIgnore
    public Optional<Long> scannedAt() {
        return scannedAt;
    }

    @JsonIgnore
    public Optional<String> scanner() {
        return scanner;
    }

    @JsonIgnore
    public Optional<String> thumb() {
        return thumb;
    }

    @JsonIgnore
    public Optional<Long> updatedAt() {
        return updatedAt;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The title of the library
     */
    public LibrarySection withTitle(String title) {
        Utils.checkNotNull(title, "title");
        this.title = Optional.ofNullable(title);
        return this;
    }


    /**
     * The title of the library
     */
    public LibrarySection withTitle(Optional<String> title) {
        Utils.checkNotNull(title, "title");
        this.title = title;
        return this;
    }

    /**
     * The type of media content in the Plex library. This can represent videos, music, or photos.
     */
    public LibrarySection withType(MediaTypeString type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    public LibrarySection withAgent(String agent) {
        Utils.checkNotNull(agent, "agent");
        this.agent = Optional.ofNullable(agent);
        return this;
    }


    public LibrarySection withAgent(Optional<String> agent) {
        Utils.checkNotNull(agent, "agent");
        this.agent = agent;
        return this;
    }

    public LibrarySection withAllowSync(boolean allowSync) {
        Utils.checkNotNull(allowSync, "allowSync");
        this.allowSync = Optional.ofNullable(allowSync);
        return this;
    }


    public LibrarySection withAllowSync(Optional<Boolean> allowSync) {
        Utils.checkNotNull(allowSync, "allowSync");
        this.allowSync = allowSync;
        return this;
    }

    public LibrarySection withArt(String art) {
        Utils.checkNotNull(art, "art");
        this.art = Optional.ofNullable(art);
        return this;
    }


    public LibrarySection withArt(Optional<String> art) {
        Utils.checkNotNull(art, "art");
        this.art = art;
        return this;
    }

    public LibrarySection withComposite(String composite) {
        Utils.checkNotNull(composite, "composite");
        this.composite = Optional.ofNullable(composite);
        return this;
    }


    public LibrarySection withComposite(Optional<String> composite) {
        Utils.checkNotNull(composite, "composite");
        this.composite = composite;
        return this;
    }

    public LibrarySection withContent(boolean content) {
        Utils.checkNotNull(content, "content");
        this.content = Optional.ofNullable(content);
        return this;
    }


    public LibrarySection withContent(Optional<Boolean> content) {
        Utils.checkNotNull(content, "content");
        this.content = content;
        return this;
    }

    public LibrarySection withContentChangedAt(long contentChangedAt) {
        Utils.checkNotNull(contentChangedAt, "contentChangedAt");
        this.contentChangedAt = Optional.ofNullable(contentChangedAt);
        return this;
    }


    public LibrarySection withContentChangedAt(Optional<Long> contentChangedAt) {
        Utils.checkNotNull(contentChangedAt, "contentChangedAt");
        this.contentChangedAt = contentChangedAt;
        return this;
    }

    public LibrarySection withCreatedAt(long createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }


    public LibrarySection withCreatedAt(Optional<Long> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    public LibrarySection withDirectory(boolean directory) {
        Utils.checkNotNull(directory, "directory");
        this.directory = Optional.ofNullable(directory);
        return this;
    }


    public LibrarySection withDirectory(Optional<Boolean> directory) {
        Utils.checkNotNull(directory, "directory");
        this.directory = directory;
        return this;
    }

    /**
     * Indicates whether this section has filtering capabilities
     */
    public LibrarySection withFilters(boolean filters) {
        Utils.checkNotNull(filters, "filters");
        this.filters = Optional.ofNullable(filters);
        return this;
    }


    /**
     * Indicates whether this section has filtering capabilities
     */
    public LibrarySection withFilters(Optional<Boolean> filters) {
        Utils.checkNotNull(filters, "filters");
        this.filters = filters;
        return this;
    }

    public LibrarySection withHidden(boolean hidden) {
        Utils.checkNotNull(hidden, "hidden");
        this.hidden = Optional.ofNullable(hidden);
        return this;
    }


    public LibrarySection withHidden(Optional<Boolean> hidden) {
        Utils.checkNotNull(hidden, "hidden");
        this.hidden = hidden;
        return this;
    }

    public LibrarySection withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = Optional.ofNullable(key);
        return this;
    }


    public LibrarySection withKey(Optional<String> key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    public LibrarySection withLanguage(String language) {
        Utils.checkNotNull(language, "language");
        this.language = language;
        return this;
    }

    /**
     * The universally unique identifier for the library.
     */
    public LibrarySection withUuid(String uuid) {
        Utils.checkNotNull(uuid, "uuid");
        this.uuid = uuid;
        return this;
    }

    public LibrarySection withLocation(List<LibrarySectionLocation> location) {
        Utils.checkNotNull(location, "location");
        this.location = Optional.ofNullable(location);
        return this;
    }


    public LibrarySection withLocation(Optional<? extends List<LibrarySectionLocation>> location) {
        Utils.checkNotNull(location, "location");
        this.location = location;
        return this;
    }

    /**
     * Indicates whether this library section is currently scanning
     */
    public LibrarySection withRefreshing(boolean refreshing) {
        Utils.checkNotNull(refreshing, "refreshing");
        this.refreshing = Optional.ofNullable(refreshing);
        return this;
    }


    /**
     * Indicates whether this library section is currently scanning
     */
    public LibrarySection withRefreshing(Optional<Boolean> refreshing) {
        Utils.checkNotNull(refreshing, "refreshing");
        this.refreshing = refreshing;
        return this;
    }

    public LibrarySection withScannedAt(long scannedAt) {
        Utils.checkNotNull(scannedAt, "scannedAt");
        this.scannedAt = Optional.ofNullable(scannedAt);
        return this;
    }


    public LibrarySection withScannedAt(Optional<Long> scannedAt) {
        Utils.checkNotNull(scannedAt, "scannedAt");
        this.scannedAt = scannedAt;
        return this;
    }

    public LibrarySection withScanner(String scanner) {
        Utils.checkNotNull(scanner, "scanner");
        this.scanner = Optional.ofNullable(scanner);
        return this;
    }


    public LibrarySection withScanner(Optional<String> scanner) {
        Utils.checkNotNull(scanner, "scanner");
        this.scanner = scanner;
        return this;
    }

    public LibrarySection withThumb(String thumb) {
        Utils.checkNotNull(thumb, "thumb");
        this.thumb = Optional.ofNullable(thumb);
        return this;
    }


    public LibrarySection withThumb(Optional<String> thumb) {
        Utils.checkNotNull(thumb, "thumb");
        this.thumb = thumb;
        return this;
    }

    public LibrarySection withUpdatedAt(long updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = Optional.ofNullable(updatedAt);
        return this;
    }


    public LibrarySection withUpdatedAt(Optional<Long> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        LibrarySection other = (LibrarySection) o;
        return 
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.agent, other.agent) &&
            Utils.enhancedDeepEquals(this.allowSync, other.allowSync) &&
            Utils.enhancedDeepEquals(this.art, other.art) &&
            Utils.enhancedDeepEquals(this.composite, other.composite) &&
            Utils.enhancedDeepEquals(this.content, other.content) &&
            Utils.enhancedDeepEquals(this.contentChangedAt, other.contentChangedAt) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.directory, other.directory) &&
            Utils.enhancedDeepEquals(this.filters, other.filters) &&
            Utils.enhancedDeepEquals(this.hidden, other.hidden) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.language, other.language) &&
            Utils.enhancedDeepEquals(this.uuid, other.uuid) &&
            Utils.enhancedDeepEquals(this.location, other.location) &&
            Utils.enhancedDeepEquals(this.refreshing, other.refreshing) &&
            Utils.enhancedDeepEquals(this.scannedAt, other.scannedAt) &&
            Utils.enhancedDeepEquals(this.scanner, other.scanner) &&
            Utils.enhancedDeepEquals(this.thumb, other.thumb) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            title, type, agent,
            allowSync, art, composite,
            content, contentChangedAt, createdAt,
            directory, filters, hidden,
            key, language, uuid,
            location, refreshing, scannedAt,
            scanner, thumb, updatedAt);
    }
    
    @Override
    public String toString() {
        return Utils.toString(LibrarySection.class,
                "title", title,
                "type", type,
                "agent", agent,
                "allowSync", allowSync,
                "art", art,
                "composite", composite,
                "content", content,
                "contentChangedAt", contentChangedAt,
                "createdAt", createdAt,
                "directory", directory,
                "filters", filters,
                "hidden", hidden,
                "key", key,
                "language", language,
                "uuid", uuid,
                "location", location,
                "refreshing", refreshing,
                "scannedAt", scannedAt,
                "scanner", scanner,
                "thumb", thumb,
                "updatedAt", updatedAt);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> title = Optional.empty();

        private MediaTypeString type;

        private Optional<String> agent = Optional.empty();

        private Optional<Boolean> allowSync = Optional.empty();

        private Optional<String> art = Optional.empty();

        private Optional<String> composite = Optional.empty();

        private Optional<Boolean> content = Optional.empty();

        private Optional<Long> contentChangedAt = Optional.empty();

        private Optional<Long> createdAt = Optional.empty();

        private Optional<Boolean> directory = Optional.empty();

        private Optional<Boolean> filters = Optional.empty();

        private Optional<Boolean> hidden = Optional.empty();

        private Optional<String> key = Optional.empty();

        private String language;

        private String uuid;

        private Optional<? extends List<LibrarySectionLocation>> location = Optional.empty();

        private Optional<Boolean> refreshing = Optional.empty();

        private Optional<Long> scannedAt = Optional.empty();

        private Optional<String> scanner = Optional.empty();

        private Optional<String> thumb = Optional.empty();

        private Optional<Long> updatedAt = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * The title of the library
         */
        public Builder title(String title) {
            Utils.checkNotNull(title, "title");
            this.title = Optional.ofNullable(title);
            return this;
        }

        /**
         * The title of the library
         */
        public Builder title(Optional<String> title) {
            Utils.checkNotNull(title, "title");
            this.title = title;
            return this;
        }


        /**
         * The type of media content in the Plex library. This can represent videos, music, or photos.
         */
        public Builder type(MediaTypeString type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }


        public Builder agent(String agent) {
            Utils.checkNotNull(agent, "agent");
            this.agent = Optional.ofNullable(agent);
            return this;
        }

        public Builder agent(Optional<String> agent) {
            Utils.checkNotNull(agent, "agent");
            this.agent = agent;
            return this;
        }


        public Builder allowSync(boolean allowSync) {
            Utils.checkNotNull(allowSync, "allowSync");
            this.allowSync = Optional.ofNullable(allowSync);
            return this;
        }

        public Builder allowSync(Optional<Boolean> allowSync) {
            Utils.checkNotNull(allowSync, "allowSync");
            this.allowSync = allowSync;
            return this;
        }


        public Builder art(String art) {
            Utils.checkNotNull(art, "art");
            this.art = Optional.ofNullable(art);
            return this;
        }

        public Builder art(Optional<String> art) {
            Utils.checkNotNull(art, "art");
            this.art = art;
            return this;
        }


        public Builder composite(String composite) {
            Utils.checkNotNull(composite, "composite");
            this.composite = Optional.ofNullable(composite);
            return this;
        }

        public Builder composite(Optional<String> composite) {
            Utils.checkNotNull(composite, "composite");
            this.composite = composite;
            return this;
        }


        public Builder content(boolean content) {
            Utils.checkNotNull(content, "content");
            this.content = Optional.ofNullable(content);
            return this;
        }

        public Builder content(Optional<Boolean> content) {
            Utils.checkNotNull(content, "content");
            this.content = content;
            return this;
        }


        public Builder contentChangedAt(long contentChangedAt) {
            Utils.checkNotNull(contentChangedAt, "contentChangedAt");
            this.contentChangedAt = Optional.ofNullable(contentChangedAt);
            return this;
        }

        public Builder contentChangedAt(Optional<Long> contentChangedAt) {
            Utils.checkNotNull(contentChangedAt, "contentChangedAt");
            this.contentChangedAt = contentChangedAt;
            return this;
        }


        public Builder createdAt(long createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        public Builder createdAt(Optional<Long> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        public Builder directory(boolean directory) {
            Utils.checkNotNull(directory, "directory");
            this.directory = Optional.ofNullable(directory);
            return this;
        }

        public Builder directory(Optional<Boolean> directory) {
            Utils.checkNotNull(directory, "directory");
            this.directory = directory;
            return this;
        }


        /**
         * Indicates whether this section has filtering capabilities
         */
        public Builder filters(boolean filters) {
            Utils.checkNotNull(filters, "filters");
            this.filters = Optional.ofNullable(filters);
            return this;
        }

        /**
         * Indicates whether this section has filtering capabilities
         */
        public Builder filters(Optional<Boolean> filters) {
            Utils.checkNotNull(filters, "filters");
            this.filters = filters;
            return this;
        }


        public Builder hidden(boolean hidden) {
            Utils.checkNotNull(hidden, "hidden");
            this.hidden = Optional.ofNullable(hidden);
            return this;
        }

        public Builder hidden(Optional<Boolean> hidden) {
            Utils.checkNotNull(hidden, "hidden");
            this.hidden = hidden;
            return this;
        }


        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = Optional.ofNullable(key);
            return this;
        }

        public Builder key(Optional<String> key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        public Builder language(String language) {
            Utils.checkNotNull(language, "language");
            this.language = language;
            return this;
        }


        /**
         * The universally unique identifier for the library.
         */
        public Builder uuid(String uuid) {
            Utils.checkNotNull(uuid, "uuid");
            this.uuid = uuid;
            return this;
        }


        public Builder location(List<LibrarySectionLocation> location) {
            Utils.checkNotNull(location, "location");
            this.location = Optional.ofNullable(location);
            return this;
        }

        public Builder location(Optional<? extends List<LibrarySectionLocation>> location) {
            Utils.checkNotNull(location, "location");
            this.location = location;
            return this;
        }


        /**
         * Indicates whether this library section is currently scanning
         */
        public Builder refreshing(boolean refreshing) {
            Utils.checkNotNull(refreshing, "refreshing");
            this.refreshing = Optional.ofNullable(refreshing);
            return this;
        }

        /**
         * Indicates whether this library section is currently scanning
         */
        public Builder refreshing(Optional<Boolean> refreshing) {
            Utils.checkNotNull(refreshing, "refreshing");
            this.refreshing = refreshing;
            return this;
        }


        public Builder scannedAt(long scannedAt) {
            Utils.checkNotNull(scannedAt, "scannedAt");
            this.scannedAt = Optional.ofNullable(scannedAt);
            return this;
        }

        public Builder scannedAt(Optional<Long> scannedAt) {
            Utils.checkNotNull(scannedAt, "scannedAt");
            this.scannedAt = scannedAt;
            return this;
        }


        public Builder scanner(String scanner) {
            Utils.checkNotNull(scanner, "scanner");
            this.scanner = Optional.ofNullable(scanner);
            return this;
        }

        public Builder scanner(Optional<String> scanner) {
            Utils.checkNotNull(scanner, "scanner");
            this.scanner = scanner;
            return this;
        }


        public Builder thumb(String thumb) {
            Utils.checkNotNull(thumb, "thumb");
            this.thumb = Optional.ofNullable(thumb);
            return this;
        }

        public Builder thumb(Optional<String> thumb) {
            Utils.checkNotNull(thumb, "thumb");
            this.thumb = thumb;
            return this;
        }


        public Builder updatedAt(long updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = Optional.ofNullable(updatedAt);
            return this;
        }

        public Builder updatedAt(Optional<Long> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }

        public LibrarySection build() {

            return new LibrarySection(
                title, type, agent,
                allowSync, art, composite,
                content, contentChangedAt, createdAt,
                directory, filters, hidden,
                key, language, uuid,
                location, refreshing, scannedAt,
                scanner, thumb, updatedAt);
        }

    }
}
