/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * MediaContainerWithDecisionPart
 * 
 * <p>`Part` represents a particular file or "part" of a media item. The part is the playable unit of the media hierarchy. Suppose that a movie library contains a movie that is broken up into files, reminiscent of a movie split across two BDs. The metadata item represents information about the movie, the media item represents this instance of the movie at this resolution and quality, and the part items represent the two playable files.  If another media were added which contained the joining of these two parts transcoded down to a lower resolution, then this metadata would contain 2 medias, one with 2 parts and one with 1 part.
 */
public class MediaContainerWithDecisionPart {
    /**
     * Indicates if the part is accessible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessible")
    private Optional<Boolean> accessible;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("audioProfile")
    private Optional<String> audioProfile;

    /**
     * The container of the media file, such as `mp4` or `mkv`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("container")
    private Optional<String> container;

    /**
     * The duration of the media item, in milliseconds
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("duration")
    private Optional<Integer> duration;

    /**
     * Indicates if the part exists.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("exists")
    private Optional<Boolean> exists;

    /**
     * The local file path at which the part is stored on the server
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("file")
    private Optional<String> file;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("has64bitOffsets")
    private Optional<Boolean> has64bitOffsets;


    @JsonProperty("id")
    private long id;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("indexes")
    private Optional<String> indexes;

    /**
     * The key from which the media can be streamed
     */
    @JsonProperty("key")
    private String key;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("optimizedForStreaming")
    private Optional<Boolean> optimizedForStreaming;

    /**
     * The size of the media, in bytes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("size")
    private Optional<Long> size;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Stream")
    private Optional<? extends List<MediaContainerWithDecisionStream>> stream;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("videoProfile")
    private Optional<String> videoProfile;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("decision")
    private Optional<? extends Decision> decision;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("selected")
    private Optional<Boolean> selected;


    @JsonIgnore
    private Map<String, Object> additionalProperties;

    @JsonCreator
    public MediaContainerWithDecisionPart(
            @JsonProperty("accessible") Optional<Boolean> accessible,
            @JsonProperty("audioProfile") Optional<String> audioProfile,
            @JsonProperty("container") Optional<String> container,
            @JsonProperty("duration") Optional<Integer> duration,
            @JsonProperty("exists") Optional<Boolean> exists,
            @JsonProperty("file") Optional<String> file,
            @JsonProperty("has64bitOffsets") Optional<Boolean> has64bitOffsets,
            @JsonProperty("id") long id,
            @JsonProperty("indexes") Optional<String> indexes,
            @JsonProperty("key") String key,
            @JsonProperty("optimizedForStreaming") Optional<Boolean> optimizedForStreaming,
            @JsonProperty("size") Optional<Long> size,
            @JsonProperty("Stream") Optional<? extends List<MediaContainerWithDecisionStream>> stream,
            @JsonProperty("videoProfile") Optional<String> videoProfile,
            @JsonProperty("decision") Optional<? extends Decision> decision,
            @JsonProperty("selected") Optional<Boolean> selected) {
        Utils.checkNotNull(accessible, "accessible");
        Utils.checkNotNull(audioProfile, "audioProfile");
        Utils.checkNotNull(container, "container");
        Utils.checkNotNull(duration, "duration");
        Utils.checkNotNull(exists, "exists");
        Utils.checkNotNull(file, "file");
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(indexes, "indexes");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        Utils.checkNotNull(size, "size");
        Utils.checkNotNull(stream, "stream");
        Utils.checkNotNull(videoProfile, "videoProfile");
        Utils.checkNotNull(decision, "decision");
        Utils.checkNotNull(selected, "selected");
        this.accessible = accessible;
        this.audioProfile = audioProfile;
        this.container = container;
        this.duration = duration;
        this.exists = exists;
        this.file = file;
        this.has64bitOffsets = has64bitOffsets;
        this.id = id;
        this.indexes = indexes;
        this.key = key;
        this.optimizedForStreaming = optimizedForStreaming;
        this.size = size;
        this.stream = stream;
        this.videoProfile = videoProfile;
        this.decision = decision;
        this.selected = selected;
        this.additionalProperties = new HashMap<>();
    }
    
    public MediaContainerWithDecisionPart(
            long id,
            String key) {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), id, Optional.empty(),
            key, Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty());
    }

    /**
     * Indicates if the part is accessible.
     */
    @JsonIgnore
    public Optional<Boolean> accessible() {
        return accessible;
    }

    @JsonIgnore
    public Optional<String> audioProfile() {
        return audioProfile;
    }

    /**
     * The container of the media file, such as `mp4` or `mkv`
     */
    @JsonIgnore
    public Optional<String> container() {
        return container;
    }

    /**
     * The duration of the media item, in milliseconds
     */
    @JsonIgnore
    public Optional<Integer> duration() {
        return duration;
    }

    /**
     * Indicates if the part exists.
     */
    @JsonIgnore
    public Optional<Boolean> exists() {
        return exists;
    }

    /**
     * The local file path at which the part is stored on the server
     */
    @JsonIgnore
    public Optional<String> file() {
        return file;
    }

    @JsonIgnore
    public Optional<Boolean> has64bitOffsets() {
        return has64bitOffsets;
    }

    @JsonIgnore
    public long id() {
        return id;
    }

    @JsonIgnore
    public Optional<String> indexes() {
        return indexes;
    }

    /**
     * The key from which the media can be streamed
     */
    @JsonIgnore
    public String key() {
        return key;
    }

    @JsonIgnore
    public Optional<Boolean> optimizedForStreaming() {
        return optimizedForStreaming;
    }

    /**
     * The size of the media, in bytes
     */
    @JsonIgnore
    public Optional<Long> size() {
        return size;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<MediaContainerWithDecisionStream>> stream() {
        return (Optional<List<MediaContainerWithDecisionStream>>) stream;
    }

    @JsonIgnore
    public Optional<String> videoProfile() {
        return videoProfile;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Decision> decision() {
        return (Optional<Decision>) decision;
    }

    @JsonIgnore
    public Optional<Boolean> selected() {
        return selected;
    }

    @JsonAnyGetter
    public Map<String, Object> additionalProperties() {
        return additionalProperties;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates if the part is accessible.
     */
    public MediaContainerWithDecisionPart withAccessible(boolean accessible) {
        Utils.checkNotNull(accessible, "accessible");
        this.accessible = Optional.ofNullable(accessible);
        return this;
    }


    /**
     * Indicates if the part is accessible.
     */
    public MediaContainerWithDecisionPart withAccessible(Optional<Boolean> accessible) {
        Utils.checkNotNull(accessible, "accessible");
        this.accessible = accessible;
        return this;
    }

    public MediaContainerWithDecisionPart withAudioProfile(String audioProfile) {
        Utils.checkNotNull(audioProfile, "audioProfile");
        this.audioProfile = Optional.ofNullable(audioProfile);
        return this;
    }


    public MediaContainerWithDecisionPart withAudioProfile(Optional<String> audioProfile) {
        Utils.checkNotNull(audioProfile, "audioProfile");
        this.audioProfile = audioProfile;
        return this;
    }

    /**
     * The container of the media file, such as `mp4` or `mkv`
     */
    public MediaContainerWithDecisionPart withContainer(String container) {
        Utils.checkNotNull(container, "container");
        this.container = Optional.ofNullable(container);
        return this;
    }


    /**
     * The container of the media file, such as `mp4` or `mkv`
     */
    public MediaContainerWithDecisionPart withContainer(Optional<String> container) {
        Utils.checkNotNull(container, "container");
        this.container = container;
        return this;
    }

    /**
     * The duration of the media item, in milliseconds
     */
    public MediaContainerWithDecisionPart withDuration(int duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = Optional.ofNullable(duration);
        return this;
    }


    /**
     * The duration of the media item, in milliseconds
     */
    public MediaContainerWithDecisionPart withDuration(Optional<Integer> duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = duration;
        return this;
    }

    /**
     * Indicates if the part exists.
     */
    public MediaContainerWithDecisionPart withExists(boolean exists) {
        Utils.checkNotNull(exists, "exists");
        this.exists = Optional.ofNullable(exists);
        return this;
    }


    /**
     * Indicates if the part exists.
     */
    public MediaContainerWithDecisionPart withExists(Optional<Boolean> exists) {
        Utils.checkNotNull(exists, "exists");
        this.exists = exists;
        return this;
    }

    /**
     * The local file path at which the part is stored on the server
     */
    public MediaContainerWithDecisionPart withFile(String file) {
        Utils.checkNotNull(file, "file");
        this.file = Optional.ofNullable(file);
        return this;
    }


    /**
     * The local file path at which the part is stored on the server
     */
    public MediaContainerWithDecisionPart withFile(Optional<String> file) {
        Utils.checkNotNull(file, "file");
        this.file = file;
        return this;
    }

    public MediaContainerWithDecisionPart withHas64bitOffsets(boolean has64bitOffsets) {
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        this.has64bitOffsets = Optional.ofNullable(has64bitOffsets);
        return this;
    }


    public MediaContainerWithDecisionPart withHas64bitOffsets(Optional<Boolean> has64bitOffsets) {
        Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
        this.has64bitOffsets = has64bitOffsets;
        return this;
    }

    public MediaContainerWithDecisionPart withId(long id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    public MediaContainerWithDecisionPart withIndexes(String indexes) {
        Utils.checkNotNull(indexes, "indexes");
        this.indexes = Optional.ofNullable(indexes);
        return this;
    }


    public MediaContainerWithDecisionPart withIndexes(Optional<String> indexes) {
        Utils.checkNotNull(indexes, "indexes");
        this.indexes = indexes;
        return this;
    }

    /**
     * The key from which the media can be streamed
     */
    public MediaContainerWithDecisionPart withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    public MediaContainerWithDecisionPart withOptimizedForStreaming(boolean optimizedForStreaming) {
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        this.optimizedForStreaming = Optional.ofNullable(optimizedForStreaming);
        return this;
    }


    public MediaContainerWithDecisionPart withOptimizedForStreaming(Optional<Boolean> optimizedForStreaming) {
        Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
        this.optimizedForStreaming = optimizedForStreaming;
        return this;
    }

    /**
     * The size of the media, in bytes
     */
    public MediaContainerWithDecisionPart withSize(long size) {
        Utils.checkNotNull(size, "size");
        this.size = Optional.ofNullable(size);
        return this;
    }


    /**
     * The size of the media, in bytes
     */
    public MediaContainerWithDecisionPart withSize(Optional<Long> size) {
        Utils.checkNotNull(size, "size");
        this.size = size;
        return this;
    }

    public MediaContainerWithDecisionPart withStream(List<MediaContainerWithDecisionStream> stream) {
        Utils.checkNotNull(stream, "stream");
        this.stream = Optional.ofNullable(stream);
        return this;
    }


    public MediaContainerWithDecisionPart withStream(Optional<? extends List<MediaContainerWithDecisionStream>> stream) {
        Utils.checkNotNull(stream, "stream");
        this.stream = stream;
        return this;
    }

    public MediaContainerWithDecisionPart withVideoProfile(String videoProfile) {
        Utils.checkNotNull(videoProfile, "videoProfile");
        this.videoProfile = Optional.ofNullable(videoProfile);
        return this;
    }


    public MediaContainerWithDecisionPart withVideoProfile(Optional<String> videoProfile) {
        Utils.checkNotNull(videoProfile, "videoProfile");
        this.videoProfile = videoProfile;
        return this;
    }

    public MediaContainerWithDecisionPart withDecision(Decision decision) {
        Utils.checkNotNull(decision, "decision");
        this.decision = Optional.ofNullable(decision);
        return this;
    }


    public MediaContainerWithDecisionPart withDecision(Optional<? extends Decision> decision) {
        Utils.checkNotNull(decision, "decision");
        this.decision = decision;
        return this;
    }

    public MediaContainerWithDecisionPart withSelected(boolean selected) {
        Utils.checkNotNull(selected, "selected");
        this.selected = Optional.ofNullable(selected);
        return this;
    }


    public MediaContainerWithDecisionPart withSelected(Optional<Boolean> selected) {
        Utils.checkNotNull(selected, "selected");
        this.selected = selected;
        return this;
    }

    @JsonAnySetter
    public MediaContainerWithDecisionPart withAdditionalProperty(String key, Object value) {
        // note that value can be null because of the way JsonAnySetter works
        Utils.checkNotNull(key, "key");
        additionalProperties.put(key, value); 
        return this;
    }
    public MediaContainerWithDecisionPart withAdditionalProperties(Map<String, Object> additionalProperties) {
        Utils.checkNotNull(additionalProperties, "additionalProperties");
        this.additionalProperties = additionalProperties;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        MediaContainerWithDecisionPart other = (MediaContainerWithDecisionPart) o;
        return 
            Utils.enhancedDeepEquals(this.accessible, other.accessible) &&
            Utils.enhancedDeepEquals(this.audioProfile, other.audioProfile) &&
            Utils.enhancedDeepEquals(this.container, other.container) &&
            Utils.enhancedDeepEquals(this.duration, other.duration) &&
            Utils.enhancedDeepEquals(this.exists, other.exists) &&
            Utils.enhancedDeepEquals(this.file, other.file) &&
            Utils.enhancedDeepEquals(this.has64bitOffsets, other.has64bitOffsets) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.indexes, other.indexes) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.optimizedForStreaming, other.optimizedForStreaming) &&
            Utils.enhancedDeepEquals(this.size, other.size) &&
            Utils.enhancedDeepEquals(this.stream, other.stream) &&
            Utils.enhancedDeepEquals(this.videoProfile, other.videoProfile) &&
            Utils.enhancedDeepEquals(this.decision, other.decision) &&
            Utils.enhancedDeepEquals(this.selected, other.selected) &&
            Utils.enhancedDeepEquals(this.additionalProperties, other.additionalProperties);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            accessible, audioProfile, container,
            duration, exists, file,
            has64bitOffsets, id, indexes,
            key, optimizedForStreaming, size,
            stream, videoProfile, decision,
            selected, additionalProperties);
    }
    
    @Override
    public String toString() {
        return Utils.toString(MediaContainerWithDecisionPart.class,
                "accessible", accessible,
                "audioProfile", audioProfile,
                "container", container,
                "duration", duration,
                "exists", exists,
                "file", file,
                "has64bitOffsets", has64bitOffsets,
                "id", id,
                "indexes", indexes,
                "key", key,
                "optimizedForStreaming", optimizedForStreaming,
                "size", size,
                "stream", stream,
                "videoProfile", videoProfile,
                "decision", decision,
                "selected", selected,
                "additionalProperties", additionalProperties);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<Boolean> accessible = Optional.empty();

        private Optional<String> audioProfile = Optional.empty();

        private Optional<String> container = Optional.empty();

        private Optional<Integer> duration = Optional.empty();

        private Optional<Boolean> exists = Optional.empty();

        private Optional<String> file = Optional.empty();

        private Optional<Boolean> has64bitOffsets = Optional.empty();

        private Long id;

        private Optional<String> indexes = Optional.empty();

        private String key;

        private Optional<Boolean> optimizedForStreaming = Optional.empty();

        private Optional<Long> size = Optional.empty();

        private Optional<? extends List<MediaContainerWithDecisionStream>> stream = Optional.empty();

        private Optional<String> videoProfile = Optional.empty();

        private Optional<? extends Decision> decision = Optional.empty();

        private Optional<Boolean> selected = Optional.empty();

        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates if the part is accessible.
         */
        public Builder accessible(boolean accessible) {
            Utils.checkNotNull(accessible, "accessible");
            this.accessible = Optional.ofNullable(accessible);
            return this;
        }

        /**
         * Indicates if the part is accessible.
         */
        public Builder accessible(Optional<Boolean> accessible) {
            Utils.checkNotNull(accessible, "accessible");
            this.accessible = accessible;
            return this;
        }


        public Builder audioProfile(String audioProfile) {
            Utils.checkNotNull(audioProfile, "audioProfile");
            this.audioProfile = Optional.ofNullable(audioProfile);
            return this;
        }

        public Builder audioProfile(Optional<String> audioProfile) {
            Utils.checkNotNull(audioProfile, "audioProfile");
            this.audioProfile = audioProfile;
            return this;
        }


        /**
         * The container of the media file, such as `mp4` or `mkv`
         */
        public Builder container(String container) {
            Utils.checkNotNull(container, "container");
            this.container = Optional.ofNullable(container);
            return this;
        }

        /**
         * The container of the media file, such as `mp4` or `mkv`
         */
        public Builder container(Optional<String> container) {
            Utils.checkNotNull(container, "container");
            this.container = container;
            return this;
        }


        /**
         * The duration of the media item, in milliseconds
         */
        public Builder duration(int duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = Optional.ofNullable(duration);
            return this;
        }

        /**
         * The duration of the media item, in milliseconds
         */
        public Builder duration(Optional<Integer> duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = duration;
            return this;
        }


        /**
         * Indicates if the part exists.
         */
        public Builder exists(boolean exists) {
            Utils.checkNotNull(exists, "exists");
            this.exists = Optional.ofNullable(exists);
            return this;
        }

        /**
         * Indicates if the part exists.
         */
        public Builder exists(Optional<Boolean> exists) {
            Utils.checkNotNull(exists, "exists");
            this.exists = exists;
            return this;
        }


        /**
         * The local file path at which the part is stored on the server
         */
        public Builder file(String file) {
            Utils.checkNotNull(file, "file");
            this.file = Optional.ofNullable(file);
            return this;
        }

        /**
         * The local file path at which the part is stored on the server
         */
        public Builder file(Optional<String> file) {
            Utils.checkNotNull(file, "file");
            this.file = file;
            return this;
        }


        public Builder has64bitOffsets(boolean has64bitOffsets) {
            Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
            this.has64bitOffsets = Optional.ofNullable(has64bitOffsets);
            return this;
        }

        public Builder has64bitOffsets(Optional<Boolean> has64bitOffsets) {
            Utils.checkNotNull(has64bitOffsets, "has64bitOffsets");
            this.has64bitOffsets = has64bitOffsets;
            return this;
        }


        public Builder id(long id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        public Builder indexes(String indexes) {
            Utils.checkNotNull(indexes, "indexes");
            this.indexes = Optional.ofNullable(indexes);
            return this;
        }

        public Builder indexes(Optional<String> indexes) {
            Utils.checkNotNull(indexes, "indexes");
            this.indexes = indexes;
            return this;
        }


        /**
         * The key from which the media can be streamed
         */
        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        public Builder optimizedForStreaming(boolean optimizedForStreaming) {
            Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
            this.optimizedForStreaming = Optional.ofNullable(optimizedForStreaming);
            return this;
        }

        public Builder optimizedForStreaming(Optional<Boolean> optimizedForStreaming) {
            Utils.checkNotNull(optimizedForStreaming, "optimizedForStreaming");
            this.optimizedForStreaming = optimizedForStreaming;
            return this;
        }


        /**
         * The size of the media, in bytes
         */
        public Builder size(long size) {
            Utils.checkNotNull(size, "size");
            this.size = Optional.ofNullable(size);
            return this;
        }

        /**
         * The size of the media, in bytes
         */
        public Builder size(Optional<Long> size) {
            Utils.checkNotNull(size, "size");
            this.size = size;
            return this;
        }


        public Builder stream(List<MediaContainerWithDecisionStream> stream) {
            Utils.checkNotNull(stream, "stream");
            this.stream = Optional.ofNullable(stream);
            return this;
        }

        public Builder stream(Optional<? extends List<MediaContainerWithDecisionStream>> stream) {
            Utils.checkNotNull(stream, "stream");
            this.stream = stream;
            return this;
        }


        public Builder videoProfile(String videoProfile) {
            Utils.checkNotNull(videoProfile, "videoProfile");
            this.videoProfile = Optional.ofNullable(videoProfile);
            return this;
        }

        public Builder videoProfile(Optional<String> videoProfile) {
            Utils.checkNotNull(videoProfile, "videoProfile");
            this.videoProfile = videoProfile;
            return this;
        }


        public Builder decision(Decision decision) {
            Utils.checkNotNull(decision, "decision");
            this.decision = Optional.ofNullable(decision);
            return this;
        }

        public Builder decision(Optional<? extends Decision> decision) {
            Utils.checkNotNull(decision, "decision");
            this.decision = decision;
            return this;
        }


        public Builder selected(boolean selected) {
            Utils.checkNotNull(selected, "selected");
            this.selected = Optional.ofNullable(selected);
            return this;
        }

        public Builder selected(Optional<Boolean> selected) {
            Utils.checkNotNull(selected, "selected");
            this.selected = selected;
            return this;
        }

        public Builder additionalProperty(String key, Object value) {
            Utils.checkNotNull(key, "key");
            // we could be strict about null values (force the user
            // to pass `JsonNullable.of(null)`) but likely to be a bit 
            // annoying for additional properties building so we'll 
            // relax preconditions.
            this.additionalProperties.put(key, value);
            return this;
        }

        public Builder additionalProperties(Map<String, Object> additionalProperties) {
            Utils.checkNotNull(additionalProperties, "additionalProperties");
            this.additionalProperties = additionalProperties;
            return this;
        }

        public MediaContainerWithDecisionPart build() {

            return new MediaContainerWithDecisionPart(
                accessible, audioProfile, container,
                duration, exists, file,
                has64bitOffsets, id, indexes,
                key, optimizedForStreaming, size,
                stream, videoProfile, decision,
                selected)
                .withAdditionalProperties(additionalProperties);
        }

    }
}
