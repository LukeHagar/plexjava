/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Filter
 * 
 * <p>Each `Filter` object contains a description of the filter. Note that it is not an exhaustive list of the full media query language, but an important subset useful for top-level API.
 */
public class Filter {
    /**
     * The title for the filter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title")
    private Optional<String> title;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private Optional<String> type;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("art")
    private Optional<String> art;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("content")
    private Optional<Boolean> content;

    /**
     * This represents the filter name used for the filter, which can be used to construct complex media queries with.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("filter")
    private Optional<String> filter;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hasPrefs")
    private Optional<Boolean> hasPrefs;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hasStoreServices")
    private Optional<Boolean> hasStoreServices;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hubKey")
    private Optional<String> hubKey;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("identifier")
    private Optional<String> identifier;

    /**
     * This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a "Genre" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("key")
    private Optional<String> key;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastAccessedAt")
    private Optional<Long> lastAccessedAt;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Pivot")
    private Optional<? extends List<FilterPivot>> pivot;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("share")
    private Optional<Long> share;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thumb")
    private Optional<String> thumb;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("titleBar")
    private Optional<String> titleBar;

    /**
     * This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("filterType")
    private Optional<String> filterType;


    @JsonIgnore
    private Map<String, Object> additionalProperties;

    @JsonCreator
    public Filter(
            @JsonProperty("title") Optional<String> title,
            @JsonProperty("type") Optional<String> type,
            @JsonProperty("art") Optional<String> art,
            @JsonProperty("content") Optional<Boolean> content,
            @JsonProperty("filter") Optional<String> filter,
            @JsonProperty("hasPrefs") Optional<Boolean> hasPrefs,
            @JsonProperty("hasStoreServices") Optional<Boolean> hasStoreServices,
            @JsonProperty("hubKey") Optional<String> hubKey,
            @JsonProperty("identifier") Optional<String> identifier,
            @JsonProperty("key") Optional<String> key,
            @JsonProperty("lastAccessedAt") Optional<Long> lastAccessedAt,
            @JsonProperty("Pivot") Optional<? extends List<FilterPivot>> pivot,
            @JsonProperty("share") Optional<Long> share,
            @JsonProperty("thumb") Optional<String> thumb,
            @JsonProperty("titleBar") Optional<String> titleBar,
            @JsonProperty("filterType") Optional<String> filterType) {
        Utils.checkNotNull(title, "title");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(art, "art");
        Utils.checkNotNull(content, "content");
        Utils.checkNotNull(filter, "filter");
        Utils.checkNotNull(hasPrefs, "hasPrefs");
        Utils.checkNotNull(hasStoreServices, "hasStoreServices");
        Utils.checkNotNull(hubKey, "hubKey");
        Utils.checkNotNull(identifier, "identifier");
        Utils.checkNotNull(key, "key");
        Utils.checkNotNull(lastAccessedAt, "lastAccessedAt");
        Utils.checkNotNull(pivot, "pivot");
        Utils.checkNotNull(share, "share");
        Utils.checkNotNull(thumb, "thumb");
        Utils.checkNotNull(titleBar, "titleBar");
        Utils.checkNotNull(filterType, "filterType");
        this.title = title;
        this.type = type;
        this.art = art;
        this.content = content;
        this.filter = filter;
        this.hasPrefs = hasPrefs;
        this.hasStoreServices = hasStoreServices;
        this.hubKey = hubKey;
        this.identifier = identifier;
        this.key = key;
        this.lastAccessedAt = lastAccessedAt;
        this.pivot = pivot;
        this.share = share;
        this.thumb = thumb;
        this.titleBar = titleBar;
        this.filterType = filterType;
        this.additionalProperties = new HashMap<>();
    }
    
    public Filter() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty());
    }

    /**
     * The title for the filter.
     */
    @JsonIgnore
    public Optional<String> title() {
        return title;
    }

    @JsonIgnore
    public Optional<String> type() {
        return type;
    }

    @JsonIgnore
    public Optional<String> art() {
        return art;
    }

    @JsonIgnore
    public Optional<Boolean> content() {
        return content;
    }

    /**
     * This represents the filter name used for the filter, which can be used to construct complex media queries with.
     */
    @JsonIgnore
    public Optional<String> filter() {
        return filter;
    }

    @JsonIgnore
    public Optional<Boolean> hasPrefs() {
        return hasPrefs;
    }

    @JsonIgnore
    public Optional<Boolean> hasStoreServices() {
        return hasStoreServices;
    }

    @JsonIgnore
    public Optional<String> hubKey() {
        return hubKey;
    }

    @JsonIgnore
    public Optional<String> identifier() {
        return identifier;
    }

    /**
     * This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a "Genre" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.
     */
    @JsonIgnore
    public Optional<String> key() {
        return key;
    }

    @JsonIgnore
    public Optional<Long> lastAccessedAt() {
        return lastAccessedAt;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FilterPivot>> pivot() {
        return (Optional<List<FilterPivot>>) pivot;
    }

    @JsonIgnore
    public Optional<Long> share() {
        return share;
    }

    @JsonIgnore
    public Optional<String> thumb() {
        return thumb;
    }

    @JsonIgnore
    public Optional<String> titleBar() {
        return titleBar;
    }

    /**
     * This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.
     */
    @JsonIgnore
    public Optional<String> filterType() {
        return filterType;
    }

    @JsonAnyGetter
    public Map<String, Object> additionalProperties() {
        return additionalProperties;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The title for the filter.
     */
    public Filter withTitle(String title) {
        Utils.checkNotNull(title, "title");
        this.title = Optional.ofNullable(title);
        return this;
    }


    /**
     * The title for the filter.
     */
    public Filter withTitle(Optional<String> title) {
        Utils.checkNotNull(title, "title");
        this.title = title;
        return this;
    }

    public Filter withType(String type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }


    public Filter withType(Optional<String> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    public Filter withArt(String art) {
        Utils.checkNotNull(art, "art");
        this.art = Optional.ofNullable(art);
        return this;
    }


    public Filter withArt(Optional<String> art) {
        Utils.checkNotNull(art, "art");
        this.art = art;
        return this;
    }

    public Filter withContent(boolean content) {
        Utils.checkNotNull(content, "content");
        this.content = Optional.ofNullable(content);
        return this;
    }


    public Filter withContent(Optional<Boolean> content) {
        Utils.checkNotNull(content, "content");
        this.content = content;
        return this;
    }

    /**
     * This represents the filter name used for the filter, which can be used to construct complex media queries with.
     */
    public Filter withFilter(String filter) {
        Utils.checkNotNull(filter, "filter");
        this.filter = Optional.ofNullable(filter);
        return this;
    }


    /**
     * This represents the filter name used for the filter, which can be used to construct complex media queries with.
     */
    public Filter withFilter(Optional<String> filter) {
        Utils.checkNotNull(filter, "filter");
        this.filter = filter;
        return this;
    }

    public Filter withHasPrefs(boolean hasPrefs) {
        Utils.checkNotNull(hasPrefs, "hasPrefs");
        this.hasPrefs = Optional.ofNullable(hasPrefs);
        return this;
    }


    public Filter withHasPrefs(Optional<Boolean> hasPrefs) {
        Utils.checkNotNull(hasPrefs, "hasPrefs");
        this.hasPrefs = hasPrefs;
        return this;
    }

    public Filter withHasStoreServices(boolean hasStoreServices) {
        Utils.checkNotNull(hasStoreServices, "hasStoreServices");
        this.hasStoreServices = Optional.ofNullable(hasStoreServices);
        return this;
    }


    public Filter withHasStoreServices(Optional<Boolean> hasStoreServices) {
        Utils.checkNotNull(hasStoreServices, "hasStoreServices");
        this.hasStoreServices = hasStoreServices;
        return this;
    }

    public Filter withHubKey(String hubKey) {
        Utils.checkNotNull(hubKey, "hubKey");
        this.hubKey = Optional.ofNullable(hubKey);
        return this;
    }


    public Filter withHubKey(Optional<String> hubKey) {
        Utils.checkNotNull(hubKey, "hubKey");
        this.hubKey = hubKey;
        return this;
    }

    public Filter withIdentifier(String identifier) {
        Utils.checkNotNull(identifier, "identifier");
        this.identifier = Optional.ofNullable(identifier);
        return this;
    }


    public Filter withIdentifier(Optional<String> identifier) {
        Utils.checkNotNull(identifier, "identifier");
        this.identifier = identifier;
        return this;
    }

    /**
     * This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a "Genre" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.
     */
    public Filter withKey(String key) {
        Utils.checkNotNull(key, "key");
        this.key = Optional.ofNullable(key);
        return this;
    }


    /**
     * This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a "Genre" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.
     */
    public Filter withKey(Optional<String> key) {
        Utils.checkNotNull(key, "key");
        this.key = key;
        return this;
    }

    public Filter withLastAccessedAt(long lastAccessedAt) {
        Utils.checkNotNull(lastAccessedAt, "lastAccessedAt");
        this.lastAccessedAt = Optional.ofNullable(lastAccessedAt);
        return this;
    }


    public Filter withLastAccessedAt(Optional<Long> lastAccessedAt) {
        Utils.checkNotNull(lastAccessedAt, "lastAccessedAt");
        this.lastAccessedAt = lastAccessedAt;
        return this;
    }

    public Filter withPivot(List<FilterPivot> pivot) {
        Utils.checkNotNull(pivot, "pivot");
        this.pivot = Optional.ofNullable(pivot);
        return this;
    }


    public Filter withPivot(Optional<? extends List<FilterPivot>> pivot) {
        Utils.checkNotNull(pivot, "pivot");
        this.pivot = pivot;
        return this;
    }

    public Filter withShare(long share) {
        Utils.checkNotNull(share, "share");
        this.share = Optional.ofNullable(share);
        return this;
    }


    public Filter withShare(Optional<Long> share) {
        Utils.checkNotNull(share, "share");
        this.share = share;
        return this;
    }

    public Filter withThumb(String thumb) {
        Utils.checkNotNull(thumb, "thumb");
        this.thumb = Optional.ofNullable(thumb);
        return this;
    }


    public Filter withThumb(Optional<String> thumb) {
        Utils.checkNotNull(thumb, "thumb");
        this.thumb = thumb;
        return this;
    }

    public Filter withTitleBar(String titleBar) {
        Utils.checkNotNull(titleBar, "titleBar");
        this.titleBar = Optional.ofNullable(titleBar);
        return this;
    }


    public Filter withTitleBar(Optional<String> titleBar) {
        Utils.checkNotNull(titleBar, "titleBar");
        this.titleBar = titleBar;
        return this;
    }

    /**
     * This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.
     */
    public Filter withFilterType(String filterType) {
        Utils.checkNotNull(filterType, "filterType");
        this.filterType = Optional.ofNullable(filterType);
        return this;
    }


    /**
     * This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.
     */
    public Filter withFilterType(Optional<String> filterType) {
        Utils.checkNotNull(filterType, "filterType");
        this.filterType = filterType;
        return this;
    }

    @JsonAnySetter
    public Filter withAdditionalProperty(String key, Object value) {
        // note that value can be null because of the way JsonAnySetter works
        Utils.checkNotNull(key, "key");
        additionalProperties.put(key, value); 
        return this;
    }
    public Filter withAdditionalProperties(Map<String, Object> additionalProperties) {
        Utils.checkNotNull(additionalProperties, "additionalProperties");
        this.additionalProperties = additionalProperties;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Filter other = (Filter) o;
        return 
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.art, other.art) &&
            Utils.enhancedDeepEquals(this.content, other.content) &&
            Utils.enhancedDeepEquals(this.filter, other.filter) &&
            Utils.enhancedDeepEquals(this.hasPrefs, other.hasPrefs) &&
            Utils.enhancedDeepEquals(this.hasStoreServices, other.hasStoreServices) &&
            Utils.enhancedDeepEquals(this.hubKey, other.hubKey) &&
            Utils.enhancedDeepEquals(this.identifier, other.identifier) &&
            Utils.enhancedDeepEquals(this.key, other.key) &&
            Utils.enhancedDeepEquals(this.lastAccessedAt, other.lastAccessedAt) &&
            Utils.enhancedDeepEquals(this.pivot, other.pivot) &&
            Utils.enhancedDeepEquals(this.share, other.share) &&
            Utils.enhancedDeepEquals(this.thumb, other.thumb) &&
            Utils.enhancedDeepEquals(this.titleBar, other.titleBar) &&
            Utils.enhancedDeepEquals(this.filterType, other.filterType) &&
            Utils.enhancedDeepEquals(this.additionalProperties, other.additionalProperties);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            title, type, art,
            content, filter, hasPrefs,
            hasStoreServices, hubKey, identifier,
            key, lastAccessedAt, pivot,
            share, thumb, titleBar,
            filterType, additionalProperties);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Filter.class,
                "title", title,
                "type", type,
                "art", art,
                "content", content,
                "filter", filter,
                "hasPrefs", hasPrefs,
                "hasStoreServices", hasStoreServices,
                "hubKey", hubKey,
                "identifier", identifier,
                "key", key,
                "lastAccessedAt", lastAccessedAt,
                "pivot", pivot,
                "share", share,
                "thumb", thumb,
                "titleBar", titleBar,
                "filterType", filterType,
                "additionalProperties", additionalProperties);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> title = Optional.empty();

        private Optional<String> type = Optional.empty();

        private Optional<String> art = Optional.empty();

        private Optional<Boolean> content = Optional.empty();

        private Optional<String> filter = Optional.empty();

        private Optional<Boolean> hasPrefs = Optional.empty();

        private Optional<Boolean> hasStoreServices = Optional.empty();

        private Optional<String> hubKey = Optional.empty();

        private Optional<String> identifier = Optional.empty();

        private Optional<String> key = Optional.empty();

        private Optional<Long> lastAccessedAt = Optional.empty();

        private Optional<? extends List<FilterPivot>> pivot = Optional.empty();

        private Optional<Long> share = Optional.empty();

        private Optional<String> thumb = Optional.empty();

        private Optional<String> titleBar = Optional.empty();

        private Optional<String> filterType = Optional.empty();

        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * The title for the filter.
         */
        public Builder title(String title) {
            Utils.checkNotNull(title, "title");
            this.title = Optional.ofNullable(title);
            return this;
        }

        /**
         * The title for the filter.
         */
        public Builder title(Optional<String> title) {
            Utils.checkNotNull(title, "title");
            this.title = title;
            return this;
        }


        public Builder type(String type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        public Builder type(Optional<String> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }


        public Builder art(String art) {
            Utils.checkNotNull(art, "art");
            this.art = Optional.ofNullable(art);
            return this;
        }

        public Builder art(Optional<String> art) {
            Utils.checkNotNull(art, "art");
            this.art = art;
            return this;
        }


        public Builder content(boolean content) {
            Utils.checkNotNull(content, "content");
            this.content = Optional.ofNullable(content);
            return this;
        }

        public Builder content(Optional<Boolean> content) {
            Utils.checkNotNull(content, "content");
            this.content = content;
            return this;
        }


        /**
         * This represents the filter name used for the filter, which can be used to construct complex media queries with.
         */
        public Builder filter(String filter) {
            Utils.checkNotNull(filter, "filter");
            this.filter = Optional.ofNullable(filter);
            return this;
        }

        /**
         * This represents the filter name used for the filter, which can be used to construct complex media queries with.
         */
        public Builder filter(Optional<String> filter) {
            Utils.checkNotNull(filter, "filter");
            this.filter = filter;
            return this;
        }


        public Builder hasPrefs(boolean hasPrefs) {
            Utils.checkNotNull(hasPrefs, "hasPrefs");
            this.hasPrefs = Optional.ofNullable(hasPrefs);
            return this;
        }

        public Builder hasPrefs(Optional<Boolean> hasPrefs) {
            Utils.checkNotNull(hasPrefs, "hasPrefs");
            this.hasPrefs = hasPrefs;
            return this;
        }


        public Builder hasStoreServices(boolean hasStoreServices) {
            Utils.checkNotNull(hasStoreServices, "hasStoreServices");
            this.hasStoreServices = Optional.ofNullable(hasStoreServices);
            return this;
        }

        public Builder hasStoreServices(Optional<Boolean> hasStoreServices) {
            Utils.checkNotNull(hasStoreServices, "hasStoreServices");
            this.hasStoreServices = hasStoreServices;
            return this;
        }


        public Builder hubKey(String hubKey) {
            Utils.checkNotNull(hubKey, "hubKey");
            this.hubKey = Optional.ofNullable(hubKey);
            return this;
        }

        public Builder hubKey(Optional<String> hubKey) {
            Utils.checkNotNull(hubKey, "hubKey");
            this.hubKey = hubKey;
            return this;
        }


        public Builder identifier(String identifier) {
            Utils.checkNotNull(identifier, "identifier");
            this.identifier = Optional.ofNullable(identifier);
            return this;
        }

        public Builder identifier(Optional<String> identifier) {
            Utils.checkNotNull(identifier, "identifier");
            this.identifier = identifier;
            return this;
        }


        /**
         * This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a "Genre" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.
         */
        public Builder key(String key) {
            Utils.checkNotNull(key, "key");
            this.key = Optional.ofNullable(key);
            return this;
        }

        /**
         * This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a "Genre" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.
         */
        public Builder key(Optional<String> key) {
            Utils.checkNotNull(key, "key");
            this.key = key;
            return this;
        }


        public Builder lastAccessedAt(long lastAccessedAt) {
            Utils.checkNotNull(lastAccessedAt, "lastAccessedAt");
            this.lastAccessedAt = Optional.ofNullable(lastAccessedAt);
            return this;
        }

        public Builder lastAccessedAt(Optional<Long> lastAccessedAt) {
            Utils.checkNotNull(lastAccessedAt, "lastAccessedAt");
            this.lastAccessedAt = lastAccessedAt;
            return this;
        }


        public Builder pivot(List<FilterPivot> pivot) {
            Utils.checkNotNull(pivot, "pivot");
            this.pivot = Optional.ofNullable(pivot);
            return this;
        }

        public Builder pivot(Optional<? extends List<FilterPivot>> pivot) {
            Utils.checkNotNull(pivot, "pivot");
            this.pivot = pivot;
            return this;
        }


        public Builder share(long share) {
            Utils.checkNotNull(share, "share");
            this.share = Optional.ofNullable(share);
            return this;
        }

        public Builder share(Optional<Long> share) {
            Utils.checkNotNull(share, "share");
            this.share = share;
            return this;
        }


        public Builder thumb(String thumb) {
            Utils.checkNotNull(thumb, "thumb");
            this.thumb = Optional.ofNullable(thumb);
            return this;
        }

        public Builder thumb(Optional<String> thumb) {
            Utils.checkNotNull(thumb, "thumb");
            this.thumb = thumb;
            return this;
        }


        public Builder titleBar(String titleBar) {
            Utils.checkNotNull(titleBar, "titleBar");
            this.titleBar = Optional.ofNullable(titleBar);
            return this;
        }

        public Builder titleBar(Optional<String> titleBar) {
            Utils.checkNotNull(titleBar, "titleBar");
            this.titleBar = titleBar;
            return this;
        }


        /**
         * This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.
         */
        public Builder filterType(String filterType) {
            Utils.checkNotNull(filterType, "filterType");
            this.filterType = Optional.ofNullable(filterType);
            return this;
        }

        /**
         * This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.
         */
        public Builder filterType(Optional<String> filterType) {
            Utils.checkNotNull(filterType, "filterType");
            this.filterType = filterType;
            return this;
        }

        public Builder additionalProperty(String key, Object value) {
            Utils.checkNotNull(key, "key");
            // we could be strict about null values (force the user
            // to pass `JsonNullable.of(null)`) but likely to be a bit 
            // annoying for additional properties building so we'll 
            // relax preconditions.
            this.additionalProperties.put(key, value);
            return this;
        }

        public Builder additionalProperties(Map<String, Object> additionalProperties) {
            Utils.checkNotNull(additionalProperties, "additionalProperties");
            this.additionalProperties = additionalProperties;
            return this;
        }

        public Filter build() {

            return new Filter(
                title, type, art,
                content, filter, hasPrefs,
                hasStoreServices, hubKey, identifier,
                key, lastAccessedAt, pivot,
                share, thumb, titleBar,
                filterType)
                .withAdditionalProperties(additionalProperties);
        }

    }
}
