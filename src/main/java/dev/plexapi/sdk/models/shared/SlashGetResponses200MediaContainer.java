/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.plexapi.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Optional;


public class SlashGetResponses200MediaContainer {
    /**
     * The flavors of directory found here:
     *   - Primary: (e.g. all, On Deck) These are still used in some clients to provide "shortcuts" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.
     *   - Secondary: These are marked with `"secondary": true` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.
     *   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there's a completely obsolete entry marked `"search": true` which used to be used to allow clients to build search dialogs on the fly.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("content")
    private Optional<String> content;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowSync")
    private Optional<Boolean> allowSync;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("art")
    private Optional<String> art;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("Directory")
    private Optional<? extends List<Metadata>> directory;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("identifier")
    private Optional<String> identifier;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("librarySectionID")
    private Optional<Long> librarySectionID;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mediaTagPrefix")
    private Optional<String> mediaTagPrefix;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mediaTagVersion")
    private Optional<Long> mediaTagVersion;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("size")
    private Optional<Long> size;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sortAsc")
    private Optional<Boolean> sortAsc;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thumb")
    private Optional<String> thumb;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title1")
    private Optional<String> title1;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("viewGroup")
    private Optional<String> viewGroup;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("viewMode")
    private Optional<Long> viewMode;

    @JsonCreator
    public SlashGetResponses200MediaContainer(
            @JsonProperty("content") Optional<String> content,
            @JsonProperty("allowSync") Optional<Boolean> allowSync,
            @JsonProperty("art") Optional<String> art,
            @JsonProperty("Directory") Optional<? extends List<Metadata>> directory,
            @JsonProperty("identifier") Optional<String> identifier,
            @JsonProperty("librarySectionID") Optional<Long> librarySectionID,
            @JsonProperty("mediaTagPrefix") Optional<String> mediaTagPrefix,
            @JsonProperty("mediaTagVersion") Optional<Long> mediaTagVersion,
            @JsonProperty("size") Optional<Long> size,
            @JsonProperty("sortAsc") Optional<Boolean> sortAsc,
            @JsonProperty("thumb") Optional<String> thumb,
            @JsonProperty("title1") Optional<String> title1,
            @JsonProperty("viewGroup") Optional<String> viewGroup,
            @JsonProperty("viewMode") Optional<Long> viewMode) {
        Utils.checkNotNull(content, "content");
        Utils.checkNotNull(allowSync, "allowSync");
        Utils.checkNotNull(art, "art");
        Utils.checkNotNull(directory, "directory");
        Utils.checkNotNull(identifier, "identifier");
        Utils.checkNotNull(librarySectionID, "librarySectionID");
        Utils.checkNotNull(mediaTagPrefix, "mediaTagPrefix");
        Utils.checkNotNull(mediaTagVersion, "mediaTagVersion");
        Utils.checkNotNull(size, "size");
        Utils.checkNotNull(sortAsc, "sortAsc");
        Utils.checkNotNull(thumb, "thumb");
        Utils.checkNotNull(title1, "title1");
        Utils.checkNotNull(viewGroup, "viewGroup");
        Utils.checkNotNull(viewMode, "viewMode");
        this.content = content;
        this.allowSync = allowSync;
        this.art = art;
        this.directory = directory;
        this.identifier = identifier;
        this.librarySectionID = librarySectionID;
        this.mediaTagPrefix = mediaTagPrefix;
        this.mediaTagVersion = mediaTagVersion;
        this.size = size;
        this.sortAsc = sortAsc;
        this.thumb = thumb;
        this.title1 = title1;
        this.viewGroup = viewGroup;
        this.viewMode = viewMode;
    }
    
    public SlashGetResponses200MediaContainer() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty());
    }

    /**
     * The flavors of directory found here:
     *   - Primary: (e.g. all, On Deck) These are still used in some clients to provide "shortcuts" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.
     *   - Secondary: These are marked with `"secondary": true` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.
     *   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there's a completely obsolete entry marked `"search": true` which used to be used to allow clients to build search dialogs on the fly.
     */
    @JsonIgnore
    public Optional<String> content() {
        return content;
    }

    @JsonIgnore
    public Optional<Boolean> allowSync() {
        return allowSync;
    }

    @JsonIgnore
    public Optional<String> art() {
        return art;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Metadata>> directory() {
        return (Optional<List<Metadata>>) directory;
    }

    @JsonIgnore
    public Optional<String> identifier() {
        return identifier;
    }

    @JsonIgnore
    public Optional<Long> librarySectionID() {
        return librarySectionID;
    }

    @JsonIgnore
    public Optional<String> mediaTagPrefix() {
        return mediaTagPrefix;
    }

    @JsonIgnore
    public Optional<Long> mediaTagVersion() {
        return mediaTagVersion;
    }

    @JsonIgnore
    public Optional<Long> size() {
        return size;
    }

    @JsonIgnore
    public Optional<Boolean> sortAsc() {
        return sortAsc;
    }

    @JsonIgnore
    public Optional<String> thumb() {
        return thumb;
    }

    @JsonIgnore
    public Optional<String> title1() {
        return title1;
    }

    @JsonIgnore
    public Optional<String> viewGroup() {
        return viewGroup;
    }

    @JsonIgnore
    public Optional<Long> viewMode() {
        return viewMode;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The flavors of directory found here:
     *   - Primary: (e.g. all, On Deck) These are still used in some clients to provide "shortcuts" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.
     *   - Secondary: These are marked with `"secondary": true` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.
     *   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there's a completely obsolete entry marked `"search": true` which used to be used to allow clients to build search dialogs on the fly.
     */
    public SlashGetResponses200MediaContainer withContent(String content) {
        Utils.checkNotNull(content, "content");
        this.content = Optional.ofNullable(content);
        return this;
    }


    /**
     * The flavors of directory found here:
     *   - Primary: (e.g. all, On Deck) These are still used in some clients to provide "shortcuts" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.
     *   - Secondary: These are marked with `"secondary": true` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.
     *   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there's a completely obsolete entry marked `"search": true` which used to be used to allow clients to build search dialogs on the fly.
     */
    public SlashGetResponses200MediaContainer withContent(Optional<String> content) {
        Utils.checkNotNull(content, "content");
        this.content = content;
        return this;
    }

    public SlashGetResponses200MediaContainer withAllowSync(boolean allowSync) {
        Utils.checkNotNull(allowSync, "allowSync");
        this.allowSync = Optional.ofNullable(allowSync);
        return this;
    }


    public SlashGetResponses200MediaContainer withAllowSync(Optional<Boolean> allowSync) {
        Utils.checkNotNull(allowSync, "allowSync");
        this.allowSync = allowSync;
        return this;
    }

    public SlashGetResponses200MediaContainer withArt(String art) {
        Utils.checkNotNull(art, "art");
        this.art = Optional.ofNullable(art);
        return this;
    }


    public SlashGetResponses200MediaContainer withArt(Optional<String> art) {
        Utils.checkNotNull(art, "art");
        this.art = art;
        return this;
    }

    public SlashGetResponses200MediaContainer withDirectory(List<Metadata> directory) {
        Utils.checkNotNull(directory, "directory");
        this.directory = Optional.ofNullable(directory);
        return this;
    }


    public SlashGetResponses200MediaContainer withDirectory(Optional<? extends List<Metadata>> directory) {
        Utils.checkNotNull(directory, "directory");
        this.directory = directory;
        return this;
    }

    public SlashGetResponses200MediaContainer withIdentifier(String identifier) {
        Utils.checkNotNull(identifier, "identifier");
        this.identifier = Optional.ofNullable(identifier);
        return this;
    }


    public SlashGetResponses200MediaContainer withIdentifier(Optional<String> identifier) {
        Utils.checkNotNull(identifier, "identifier");
        this.identifier = identifier;
        return this;
    }

    public SlashGetResponses200MediaContainer withLibrarySectionID(long librarySectionID) {
        Utils.checkNotNull(librarySectionID, "librarySectionID");
        this.librarySectionID = Optional.ofNullable(librarySectionID);
        return this;
    }


    public SlashGetResponses200MediaContainer withLibrarySectionID(Optional<Long> librarySectionID) {
        Utils.checkNotNull(librarySectionID, "librarySectionID");
        this.librarySectionID = librarySectionID;
        return this;
    }

    public SlashGetResponses200MediaContainer withMediaTagPrefix(String mediaTagPrefix) {
        Utils.checkNotNull(mediaTagPrefix, "mediaTagPrefix");
        this.mediaTagPrefix = Optional.ofNullable(mediaTagPrefix);
        return this;
    }


    public SlashGetResponses200MediaContainer withMediaTagPrefix(Optional<String> mediaTagPrefix) {
        Utils.checkNotNull(mediaTagPrefix, "mediaTagPrefix");
        this.mediaTagPrefix = mediaTagPrefix;
        return this;
    }

    public SlashGetResponses200MediaContainer withMediaTagVersion(long mediaTagVersion) {
        Utils.checkNotNull(mediaTagVersion, "mediaTagVersion");
        this.mediaTagVersion = Optional.ofNullable(mediaTagVersion);
        return this;
    }


    public SlashGetResponses200MediaContainer withMediaTagVersion(Optional<Long> mediaTagVersion) {
        Utils.checkNotNull(mediaTagVersion, "mediaTagVersion");
        this.mediaTagVersion = mediaTagVersion;
        return this;
    }

    public SlashGetResponses200MediaContainer withSize(long size) {
        Utils.checkNotNull(size, "size");
        this.size = Optional.ofNullable(size);
        return this;
    }


    public SlashGetResponses200MediaContainer withSize(Optional<Long> size) {
        Utils.checkNotNull(size, "size");
        this.size = size;
        return this;
    }

    public SlashGetResponses200MediaContainer withSortAsc(boolean sortAsc) {
        Utils.checkNotNull(sortAsc, "sortAsc");
        this.sortAsc = Optional.ofNullable(sortAsc);
        return this;
    }


    public SlashGetResponses200MediaContainer withSortAsc(Optional<Boolean> sortAsc) {
        Utils.checkNotNull(sortAsc, "sortAsc");
        this.sortAsc = sortAsc;
        return this;
    }

    public SlashGetResponses200MediaContainer withThumb(String thumb) {
        Utils.checkNotNull(thumb, "thumb");
        this.thumb = Optional.ofNullable(thumb);
        return this;
    }


    public SlashGetResponses200MediaContainer withThumb(Optional<String> thumb) {
        Utils.checkNotNull(thumb, "thumb");
        this.thumb = thumb;
        return this;
    }

    public SlashGetResponses200MediaContainer withTitle1(String title1) {
        Utils.checkNotNull(title1, "title1");
        this.title1 = Optional.ofNullable(title1);
        return this;
    }


    public SlashGetResponses200MediaContainer withTitle1(Optional<String> title1) {
        Utils.checkNotNull(title1, "title1");
        this.title1 = title1;
        return this;
    }

    public SlashGetResponses200MediaContainer withViewGroup(String viewGroup) {
        Utils.checkNotNull(viewGroup, "viewGroup");
        this.viewGroup = Optional.ofNullable(viewGroup);
        return this;
    }


    public SlashGetResponses200MediaContainer withViewGroup(Optional<String> viewGroup) {
        Utils.checkNotNull(viewGroup, "viewGroup");
        this.viewGroup = viewGroup;
        return this;
    }

    public SlashGetResponses200MediaContainer withViewMode(long viewMode) {
        Utils.checkNotNull(viewMode, "viewMode");
        this.viewMode = Optional.ofNullable(viewMode);
        return this;
    }


    public SlashGetResponses200MediaContainer withViewMode(Optional<Long> viewMode) {
        Utils.checkNotNull(viewMode, "viewMode");
        this.viewMode = viewMode;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SlashGetResponses200MediaContainer other = (SlashGetResponses200MediaContainer) o;
        return 
            Utils.enhancedDeepEquals(this.content, other.content) &&
            Utils.enhancedDeepEquals(this.allowSync, other.allowSync) &&
            Utils.enhancedDeepEquals(this.art, other.art) &&
            Utils.enhancedDeepEquals(this.directory, other.directory) &&
            Utils.enhancedDeepEquals(this.identifier, other.identifier) &&
            Utils.enhancedDeepEquals(this.librarySectionID, other.librarySectionID) &&
            Utils.enhancedDeepEquals(this.mediaTagPrefix, other.mediaTagPrefix) &&
            Utils.enhancedDeepEquals(this.mediaTagVersion, other.mediaTagVersion) &&
            Utils.enhancedDeepEquals(this.size, other.size) &&
            Utils.enhancedDeepEquals(this.sortAsc, other.sortAsc) &&
            Utils.enhancedDeepEquals(this.thumb, other.thumb) &&
            Utils.enhancedDeepEquals(this.title1, other.title1) &&
            Utils.enhancedDeepEquals(this.viewGroup, other.viewGroup) &&
            Utils.enhancedDeepEquals(this.viewMode, other.viewMode);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            content, allowSync, art,
            directory, identifier, librarySectionID,
            mediaTagPrefix, mediaTagVersion, size,
            sortAsc, thumb, title1,
            viewGroup, viewMode);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SlashGetResponses200MediaContainer.class,
                "content", content,
                "allowSync", allowSync,
                "art", art,
                "directory", directory,
                "identifier", identifier,
                "librarySectionID", librarySectionID,
                "mediaTagPrefix", mediaTagPrefix,
                "mediaTagVersion", mediaTagVersion,
                "size", size,
                "sortAsc", sortAsc,
                "thumb", thumb,
                "title1", title1,
                "viewGroup", viewGroup,
                "viewMode", viewMode);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> content = Optional.empty();

        private Optional<Boolean> allowSync = Optional.empty();

        private Optional<String> art = Optional.empty();

        private Optional<? extends List<Metadata>> directory = Optional.empty();

        private Optional<String> identifier = Optional.empty();

        private Optional<Long> librarySectionID = Optional.empty();

        private Optional<String> mediaTagPrefix = Optional.empty();

        private Optional<Long> mediaTagVersion = Optional.empty();

        private Optional<Long> size = Optional.empty();

        private Optional<Boolean> sortAsc = Optional.empty();

        private Optional<String> thumb = Optional.empty();

        private Optional<String> title1 = Optional.empty();

        private Optional<String> viewGroup = Optional.empty();

        private Optional<Long> viewMode = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * The flavors of directory found here:
         *   - Primary: (e.g. all, On Deck) These are still used in some clients to provide "shortcuts" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.
         *   - Secondary: These are marked with `"secondary": true` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.
         *   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there's a completely obsolete entry marked `"search": true` which used to be used to allow clients to build search dialogs on the fly.
         */
        public Builder content(String content) {
            Utils.checkNotNull(content, "content");
            this.content = Optional.ofNullable(content);
            return this;
        }

        /**
         * The flavors of directory found here:
         *   - Primary: (e.g. all, On Deck) These are still used in some clients to provide "shortcuts" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.
         *   - Secondary: These are marked with `"secondary": true` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.
         *   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there's a completely obsolete entry marked `"search": true` which used to be used to allow clients to build search dialogs on the fly.
         */
        public Builder content(Optional<String> content) {
            Utils.checkNotNull(content, "content");
            this.content = content;
            return this;
        }


        public Builder allowSync(boolean allowSync) {
            Utils.checkNotNull(allowSync, "allowSync");
            this.allowSync = Optional.ofNullable(allowSync);
            return this;
        }

        public Builder allowSync(Optional<Boolean> allowSync) {
            Utils.checkNotNull(allowSync, "allowSync");
            this.allowSync = allowSync;
            return this;
        }


        public Builder art(String art) {
            Utils.checkNotNull(art, "art");
            this.art = Optional.ofNullable(art);
            return this;
        }

        public Builder art(Optional<String> art) {
            Utils.checkNotNull(art, "art");
            this.art = art;
            return this;
        }


        public Builder directory(List<Metadata> directory) {
            Utils.checkNotNull(directory, "directory");
            this.directory = Optional.ofNullable(directory);
            return this;
        }

        public Builder directory(Optional<? extends List<Metadata>> directory) {
            Utils.checkNotNull(directory, "directory");
            this.directory = directory;
            return this;
        }


        public Builder identifier(String identifier) {
            Utils.checkNotNull(identifier, "identifier");
            this.identifier = Optional.ofNullable(identifier);
            return this;
        }

        public Builder identifier(Optional<String> identifier) {
            Utils.checkNotNull(identifier, "identifier");
            this.identifier = identifier;
            return this;
        }


        public Builder librarySectionID(long librarySectionID) {
            Utils.checkNotNull(librarySectionID, "librarySectionID");
            this.librarySectionID = Optional.ofNullable(librarySectionID);
            return this;
        }

        public Builder librarySectionID(Optional<Long> librarySectionID) {
            Utils.checkNotNull(librarySectionID, "librarySectionID");
            this.librarySectionID = librarySectionID;
            return this;
        }


        public Builder mediaTagPrefix(String mediaTagPrefix) {
            Utils.checkNotNull(mediaTagPrefix, "mediaTagPrefix");
            this.mediaTagPrefix = Optional.ofNullable(mediaTagPrefix);
            return this;
        }

        public Builder mediaTagPrefix(Optional<String> mediaTagPrefix) {
            Utils.checkNotNull(mediaTagPrefix, "mediaTagPrefix");
            this.mediaTagPrefix = mediaTagPrefix;
            return this;
        }


        public Builder mediaTagVersion(long mediaTagVersion) {
            Utils.checkNotNull(mediaTagVersion, "mediaTagVersion");
            this.mediaTagVersion = Optional.ofNullable(mediaTagVersion);
            return this;
        }

        public Builder mediaTagVersion(Optional<Long> mediaTagVersion) {
            Utils.checkNotNull(mediaTagVersion, "mediaTagVersion");
            this.mediaTagVersion = mediaTagVersion;
            return this;
        }


        public Builder size(long size) {
            Utils.checkNotNull(size, "size");
            this.size = Optional.ofNullable(size);
            return this;
        }

        public Builder size(Optional<Long> size) {
            Utils.checkNotNull(size, "size");
            this.size = size;
            return this;
        }


        public Builder sortAsc(boolean sortAsc) {
            Utils.checkNotNull(sortAsc, "sortAsc");
            this.sortAsc = Optional.ofNullable(sortAsc);
            return this;
        }

        public Builder sortAsc(Optional<Boolean> sortAsc) {
            Utils.checkNotNull(sortAsc, "sortAsc");
            this.sortAsc = sortAsc;
            return this;
        }


        public Builder thumb(String thumb) {
            Utils.checkNotNull(thumb, "thumb");
            this.thumb = Optional.ofNullable(thumb);
            return this;
        }

        public Builder thumb(Optional<String> thumb) {
            Utils.checkNotNull(thumb, "thumb");
            this.thumb = thumb;
            return this;
        }


        public Builder title1(String title1) {
            Utils.checkNotNull(title1, "title1");
            this.title1 = Optional.ofNullable(title1);
            return this;
        }

        public Builder title1(Optional<String> title1) {
            Utils.checkNotNull(title1, "title1");
            this.title1 = title1;
            return this;
        }


        public Builder viewGroup(String viewGroup) {
            Utils.checkNotNull(viewGroup, "viewGroup");
            this.viewGroup = Optional.ofNullable(viewGroup);
            return this;
        }

        public Builder viewGroup(Optional<String> viewGroup) {
            Utils.checkNotNull(viewGroup, "viewGroup");
            this.viewGroup = viewGroup;
            return this;
        }


        public Builder viewMode(long viewMode) {
            Utils.checkNotNull(viewMode, "viewMode");
            this.viewMode = Optional.ofNullable(viewMode);
            return this;
        }

        public Builder viewMode(Optional<Long> viewMode) {
            Utils.checkNotNull(viewMode, "viewMode");
            this.viewMode = viewMode;
            return this;
        }

        public SlashGetResponses200MediaContainer build() {

            return new SlashGetResponses200MediaContainer(
                content, allowSync, art,
                directory, identifier, librarySectionID,
                mediaTagPrefix, mediaTagVersion, size,
                sortAsc, thumb, title1,
                viewGroup, viewMode);
        }

    }
}
