/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.plexapi.sdk;
public class AsyncPlexAPI {
    /**
     * General endpoints for basic PMS operation not specific to any media provider
     */
    private final AsyncGeneral general;
    /**
     * The server can notify clients in real-time of a wide range of events, from library scanning, to preferences being modified, to changes to media, and many other things. This is also the mechanism by which activity progress is reported.
     * 
     * <p>Two protocols for receiving the events are available: EventSource (also known as SSE), and WebSocket.
     */
    private final AsyncEvents events;
    /**
     * API Operations against the Preferences
     */
    private final AsyncPreferences preferences;
    /**
     * Operations for rating media items (thumbs up/down, star ratings, etc.)
     */
    private final AsyncRate rate;
    /**
     * The actions feature within a media provider
     */
    private final AsyncTimeline timeline;
    /**
     * Activities provide a way to monitor and control asynchronous operations on the server. In order to receive real-time updates for activities, a client would normally subscribe via either EventSource or Websocket endpoints.
     * 
     * <p>Activities are associated with HTTP replies via a special `X-Plex-Activity` header which contains the UUID of the activity.
     * 
     * <p>Activities are optional cancellable. If cancellable, they may be cancelled via the `DELETE` endpoint.
     */
    private final AsyncActivities activities;
    /**
     * The butler is responsible for running periodic tasks.  Some tasks run daily, others every few days, and some weekly.  These includes database maintenance, metadata updating, thumbnail generation, media analysis, and other tasks.
     */
    private final AsyncButler butler;
    /**
     * API Operations against the Download Queue
     */
    private final AsyncDownloadQueue downloadQueue;
    /**
     * The hubs within a media provider
     */
    private final AsyncHubs hubs;
    /**
     * The search feature within a media provider
     */
    private final AsyncSearch search;
    /**
     * Library endpoints which are outside of the Media Provider API.  Typically this is manipulation of the library (adding/removing sections, modifying preferences, etc).
     */
    private final AsyncLibrary library;
    /**
     * API Operations against the Collections
     */
    private final AsyncCollections collections;
    /**
     * The DVR provides means to watch and record live TV.  This section of endpoints describes how to setup the DVR itself
     */
    private final AsyncDVRs dvRs;
    /**
     * The EPG (Electronic Program Guide) is responsible for obtaining metadata for what is airing on each channel and when
     */
    private final AsyncEpg epg;
    /**
     * LiveTV contains the playback sessions of a channel from a DVR device
     */
    private final AsyncLiveTV liveTV;
    /**
     * Logging mechanism to allow clients to log to the server
     */
    private final AsyncLog log;
    /**
     * Media grabbers provide ways for media to be obtained for a given protocol. The simplest ones are `stream` and `download`. More complex grabbers can have associated devices
     * 
     * <p>Network tuners can present themselves on the network using the Simple Service Discovery Protocol and Plex Media Server will discover them. The following XML is an example of the data returned from SSDP. The `deviceType`, `serviceType`, and `serviceId` values must remain as they are in the example in order for PMS to properly discover the device. Other less-obvious fields are described in the parameters section below.
     * 
     * <p>Example SSDP output
     * ```
     * &lt;root xmlns="urn:schemas-upnp-org:device-1-0"&gt;
     *     &lt;specVersion&gt;
     *         &lt;major&gt;1&lt;/major&gt;
     *         &lt;minor&gt;0&lt;/minor&gt;
     *     &lt;/specVersion&gt;
     *     &lt;device&gt;
     *         &lt;deviceType&gt;urn:plex-tv:device:Media:1&lt;/deviceType&gt;
     *         &lt;friendlyName&gt;Turing Hopper 3000&lt;/friendlyName&gt;
     *         &lt;manufacturer&gt;Plex, Inc.&lt;/manufacturer&gt;
     *         &lt;manufacturerURL&gt;https://plex.tv/&lt;/manufacturerURL&gt;
     *         &lt;modelDescription&gt;Turing Hopper 3000 Media Grabber&lt;/modelDescription&gt;
     *         &lt;modelName&gt;Plex Media Grabber&lt;/modelName&gt;
     *         &lt;modelNumber&gt;1&lt;/modelNumber&gt;
     *         &lt;modelURL&gt;https://plex.tv&lt;/modelURL&gt;
     *         &lt;UDN&gt;uuid:42fde8e4-93b6-41e5-8a63-12d848655811&lt;/UDN&gt;
     *         &lt;serviceList&gt;
     *             &lt;service&gt;
     *                 &lt;URLBase&gt;http://10.0.0.5:8088&lt;/URLBase&gt;
     *                 &lt;serviceType&gt;urn:plex-tv:service:MediaGrabber:1&lt;/serviceType&gt;
     *                 &lt;serviceId&gt;urn:plex-tv:serviceId:MediaGrabber&lt;/serviceId&gt;
     *             &lt;/service&gt;
     *         &lt;/serviceList&gt;
     *     &lt;/device&gt;
     * &lt;/root&gt;
     * ```
     * 
     * <p>  - UDN: (string) A UUID for the device. This should be unique across models of a device at minimum.
     *   - URLBase: (string) The base HTTP URL for the device from which all of the other endpoints are hosted.
     */
    private final AsyncDevices devices;
    /**
     * Media providers are the starting points for the entire Plex Media Server media library API.  It defines the paths for the groups of endpoints.  The `/media/providers` should be the only hard-coded path in clients when accessing the media library.  Non-media library endpoints are outside the scope of the media provider.  See the description in See [the section in API Info](#section/API-Info/Media-Providers) for more information on how to use media providers.
     */
    private final AsyncProvider provider;
    /**
     * Subscriptions determine which media will be recorded and the criteria for selecting an airing when multiple are available
     */
    private final AsyncSubscriptions subscriptions;
    /**
     * API Operations against the Transcoder
     */
    private final AsyncTranscoder transcoder;
    /**
     * Media playlists that can be created and played back
     */
    private final AsyncPlaylist playlist;
    /**
     * Endpoints for manipulating playlists.
     */
    private final AsyncLibraryPlaylists libraryPlaylists;
    /**
     * The playqueue feature within a media provider
     * A play queue represents the current list of media for playback. Although queues are persisted by the server, they should be regarded by the user as a fairly lightweight, an ephemeral list of items queued up for playback in a session.  There is generally one active queue for each type of media (music, video, photos) that can be added to or destroyed and replaced with a fresh queue.
     * Play Queues has a region, which we refer to in this doc (partially for historical reasons) as "Up Next". This region is defined by `playQueueLastAddedItemID` existing on the media container. This follows iTunes' terminology. It is a special region after the currently playing item but before the originally-played items. This enables "Party Mode" listening/viewing, where items can be added on-the-fly, and normal queue playback resumed when completed. 
     * You can visualize the play queue as a sliding window in the complete list of media queued for playback. This model is important when scaling to larger play queues (e.g. shuffling 40,000 audio tracks). The client only needs visibility into small areas of the queue at any given time, and the server can optimize access in this fashion.
     * All created play queues will have an empty "Up Next" area - unless the item is an album and no `key` is provided. In this case the "Up Next" area will be populated by the contents of the album. This is to allow queueing of multiple albums - since the 'Add to Up Next' will insert after all the tracks. This means that If you're creating a PQ from an album, you can only shuffle it if you set `key`. This is due to the above implicit queueing of albums when no `key` is provided as well as the current limitation that you cannot shuffle a PQ with an "Up Next" area.
     * The play queue window advances as the server receives timeline requests. The client needs to retrieve the play queue as the “now playing” item changes. There is no play queue API to update the playing item.
     */
    private final AsyncPlayQueue playQueue;
    /**
     * Service provided to compute UltraBlur colors and images.
     */
    private final AsyncUltraBlur ultraBlur;
    /**
     * The status endpoints give you information about current playbacks, play history, and even terminating sessions.
     */
    private final AsyncStatus status;
    /**
     * This describes the API for searching and applying updates to the Plex Media Server.
     * Updates to the status can be observed via the Event API.
     */
    private final AsyncUpdater updater;
    /**
     * The actual content of the media provider
     */
    private final AsyncContent content;
    /**
     * Endpoints for manipulating collections.  In addition to these endpoints, `/library/collections/:collectionId/X` will be rerouted to `/library/metadata/:collectionId/X` and respond to those endpoints as well.
     */
    private final AsyncLibraryCollections libraryCollections;
    /**
     * General endpoints for basic PMS operation not specific to any media provider
     */
    public AsyncGeneral general() {
        return general;
    }
    /**
     * The server can notify clients in real-time of a wide range of events, from library scanning, to preferences being modified, to changes to media, and many other things. This is also the mechanism by which activity progress is reported.
     * 
     * <p>Two protocols for receiving the events are available: EventSource (also known as SSE), and WebSocket.
     */
    public AsyncEvents events() {
        return events;
    }
    /**
     * API Operations against the Preferences
     */
    public AsyncPreferences preferences() {
        return preferences;
    }
    /**
     * Operations for rating media items (thumbs up/down, star ratings, etc.)
     */
    public AsyncRate rate() {
        return rate;
    }
    /**
     * The actions feature within a media provider
     */
    public AsyncTimeline timeline() {
        return timeline;
    }
    /**
     * Activities provide a way to monitor and control asynchronous operations on the server. In order to receive real-time updates for activities, a client would normally subscribe via either EventSource or Websocket endpoints.
     * 
     * <p>Activities are associated with HTTP replies via a special `X-Plex-Activity` header which contains the UUID of the activity.
     * 
     * <p>Activities are optional cancellable. If cancellable, they may be cancelled via the `DELETE` endpoint.
     */
    public AsyncActivities activities() {
        return activities;
    }
    /**
     * The butler is responsible for running periodic tasks.  Some tasks run daily, others every few days, and some weekly.  These includes database maintenance, metadata updating, thumbnail generation, media analysis, and other tasks.
     */
    public AsyncButler butler() {
        return butler;
    }
    /**
     * API Operations against the Download Queue
     */
    public AsyncDownloadQueue downloadQueue() {
        return downloadQueue;
    }
    /**
     * The hubs within a media provider
     */
    public AsyncHubs hubs() {
        return hubs;
    }
    /**
     * The search feature within a media provider
     */
    public AsyncSearch search() {
        return search;
    }
    /**
     * Library endpoints which are outside of the Media Provider API.  Typically this is manipulation of the library (adding/removing sections, modifying preferences, etc).
     */
    public AsyncLibrary library() {
        return library;
    }
    /**
     * API Operations against the Collections
     */
    public AsyncCollections collections() {
        return collections;
    }
    /**
     * The DVR provides means to watch and record live TV.  This section of endpoints describes how to setup the DVR itself
     */
    public AsyncDVRs dvRs() {
        return dvRs;
    }
    /**
     * The EPG (Electronic Program Guide) is responsible for obtaining metadata for what is airing on each channel and when
     */
    public AsyncEpg epg() {
        return epg;
    }
    /**
     * LiveTV contains the playback sessions of a channel from a DVR device
     */
    public AsyncLiveTV liveTV() {
        return liveTV;
    }
    /**
     * Logging mechanism to allow clients to log to the server
     */
    public AsyncLog log() {
        return log;
    }
    /**
     * Media grabbers provide ways for media to be obtained for a given protocol. The simplest ones are `stream` and `download`. More complex grabbers can have associated devices
     * 
     * <p>Network tuners can present themselves on the network using the Simple Service Discovery Protocol and Plex Media Server will discover them. The following XML is an example of the data returned from SSDP. The `deviceType`, `serviceType`, and `serviceId` values must remain as they are in the example in order for PMS to properly discover the device. Other less-obvious fields are described in the parameters section below.
     * 
     * <p>Example SSDP output
     * ```
     * &lt;root xmlns="urn:schemas-upnp-org:device-1-0"&gt;
     *     &lt;specVersion&gt;
     *         &lt;major&gt;1&lt;/major&gt;
     *         &lt;minor&gt;0&lt;/minor&gt;
     *     &lt;/specVersion&gt;
     *     &lt;device&gt;
     *         &lt;deviceType&gt;urn:plex-tv:device:Media:1&lt;/deviceType&gt;
     *         &lt;friendlyName&gt;Turing Hopper 3000&lt;/friendlyName&gt;
     *         &lt;manufacturer&gt;Plex, Inc.&lt;/manufacturer&gt;
     *         &lt;manufacturerURL&gt;https://plex.tv/&lt;/manufacturerURL&gt;
     *         &lt;modelDescription&gt;Turing Hopper 3000 Media Grabber&lt;/modelDescription&gt;
     *         &lt;modelName&gt;Plex Media Grabber&lt;/modelName&gt;
     *         &lt;modelNumber&gt;1&lt;/modelNumber&gt;
     *         &lt;modelURL&gt;https://plex.tv&lt;/modelURL&gt;
     *         &lt;UDN&gt;uuid:42fde8e4-93b6-41e5-8a63-12d848655811&lt;/UDN&gt;
     *         &lt;serviceList&gt;
     *             &lt;service&gt;
     *                 &lt;URLBase&gt;http://10.0.0.5:8088&lt;/URLBase&gt;
     *                 &lt;serviceType&gt;urn:plex-tv:service:MediaGrabber:1&lt;/serviceType&gt;
     *                 &lt;serviceId&gt;urn:plex-tv:serviceId:MediaGrabber&lt;/serviceId&gt;
     *             &lt;/service&gt;
     *         &lt;/serviceList&gt;
     *     &lt;/device&gt;
     * &lt;/root&gt;
     * ```
     * 
     * <p>  - UDN: (string) A UUID for the device. This should be unique across models of a device at minimum.
     *   - URLBase: (string) The base HTTP URL for the device from which all of the other endpoints are hosted.
     */
    public AsyncDevices devices() {
        return devices;
    }
    /**
     * Media providers are the starting points for the entire Plex Media Server media library API.  It defines the paths for the groups of endpoints.  The `/media/providers` should be the only hard-coded path in clients when accessing the media library.  Non-media library endpoints are outside the scope of the media provider.  See the description in See [the section in API Info](#section/API-Info/Media-Providers) for more information on how to use media providers.
     */
    public AsyncProvider provider() {
        return provider;
    }
    /**
     * Subscriptions determine which media will be recorded and the criteria for selecting an airing when multiple are available
     */
    public AsyncSubscriptions subscriptions() {
        return subscriptions;
    }
    /**
     * API Operations against the Transcoder
     */
    public AsyncTranscoder transcoder() {
        return transcoder;
    }
    /**
     * Media playlists that can be created and played back
     */
    public AsyncPlaylist playlist() {
        return playlist;
    }
    /**
     * Endpoints for manipulating playlists.
     */
    public AsyncLibraryPlaylists libraryPlaylists() {
        return libraryPlaylists;
    }
    /**
     * The playqueue feature within a media provider
     * A play queue represents the current list of media for playback. Although queues are persisted by the server, they should be regarded by the user as a fairly lightweight, an ephemeral list of items queued up for playback in a session.  There is generally one active queue for each type of media (music, video, photos) that can be added to or destroyed and replaced with a fresh queue.
     * Play Queues has a region, which we refer to in this doc (partially for historical reasons) as "Up Next". This region is defined by `playQueueLastAddedItemID` existing on the media container. This follows iTunes' terminology. It is a special region after the currently playing item but before the originally-played items. This enables "Party Mode" listening/viewing, where items can be added on-the-fly, and normal queue playback resumed when completed. 
     * You can visualize the play queue as a sliding window in the complete list of media queued for playback. This model is important when scaling to larger play queues (e.g. shuffling 40,000 audio tracks). The client only needs visibility into small areas of the queue at any given time, and the server can optimize access in this fashion.
     * All created play queues will have an empty "Up Next" area - unless the item is an album and no `key` is provided. In this case the "Up Next" area will be populated by the contents of the album. This is to allow queueing of multiple albums - since the 'Add to Up Next' will insert after all the tracks. This means that If you're creating a PQ from an album, you can only shuffle it if you set `key`. This is due to the above implicit queueing of albums when no `key` is provided as well as the current limitation that you cannot shuffle a PQ with an "Up Next" area.
     * The play queue window advances as the server receives timeline requests. The client needs to retrieve the play queue as the “now playing” item changes. There is no play queue API to update the playing item.
     */
    public AsyncPlayQueue playQueue() {
        return playQueue;
    }
    /**
     * Service provided to compute UltraBlur colors and images.
     */
    public AsyncUltraBlur ultraBlur() {
        return ultraBlur;
    }
    /**
     * The status endpoints give you information about current playbacks, play history, and even terminating sessions.
     */
    public AsyncStatus status() {
        return status;
    }
    /**
     * This describes the API for searching and applying updates to the Plex Media Server.
     * Updates to the status can be observed via the Event API.
     */
    public AsyncUpdater updater() {
        return updater;
    }
    /**
     * The actual content of the media provider
     */
    public AsyncContent content() {
        return content;
    }
    /**
     * Endpoints for manipulating collections.  In addition to these endpoints, `/library/collections/:collectionId/X` will be rerouted to `/library/metadata/:collectionId/X` and respond to those endpoints as well.
     */
    public AsyncLibraryCollections libraryCollections() {
        return libraryCollections;
    }

    private final SDKConfiguration sdkConfiguration;
    private final PlexAPI syncSDK;

    AsyncPlexAPI(PlexAPI syncSDK, SDKConfiguration sdkConfiguration) {
        this.syncSDK = syncSDK;
        this.sdkConfiguration = sdkConfiguration;
        this.general = new AsyncGeneral(syncSDK.general(), sdkConfiguration);
        this.events = new AsyncEvents(syncSDK.events(), sdkConfiguration);
        this.preferences = new AsyncPreferences(syncSDK.preferences(), sdkConfiguration);
        this.rate = new AsyncRate(syncSDK.rate(), sdkConfiguration);
        this.timeline = new AsyncTimeline(syncSDK.timeline(), sdkConfiguration);
        this.activities = new AsyncActivities(syncSDK.activities(), sdkConfiguration);
        this.butler = new AsyncButler(syncSDK.butler(), sdkConfiguration);
        this.downloadQueue = new AsyncDownloadQueue(syncSDK.downloadQueue(), sdkConfiguration);
        this.hubs = new AsyncHubs(syncSDK.hubs(), sdkConfiguration);
        this.search = new AsyncSearch(syncSDK.search(), sdkConfiguration);
        this.library = new AsyncLibrary(syncSDK.library(), sdkConfiguration);
        this.collections = new AsyncCollections(syncSDK.collections(), sdkConfiguration);
        this.dvRs = new AsyncDVRs(syncSDK.dvRs(), sdkConfiguration);
        this.epg = new AsyncEpg(syncSDK.epg(), sdkConfiguration);
        this.liveTV = new AsyncLiveTV(syncSDK.liveTV(), sdkConfiguration);
        this.log = new AsyncLog(syncSDK.log(), sdkConfiguration);
        this.devices = new AsyncDevices(syncSDK.devices(), sdkConfiguration);
        this.provider = new AsyncProvider(syncSDK.provider(), sdkConfiguration);
        this.subscriptions = new AsyncSubscriptions(syncSDK.subscriptions(), sdkConfiguration);
        this.transcoder = new AsyncTranscoder(syncSDK.transcoder(), sdkConfiguration);
        this.playlist = new AsyncPlaylist(syncSDK.playlist(), sdkConfiguration);
        this.libraryPlaylists = new AsyncLibraryPlaylists(syncSDK.libraryPlaylists(), sdkConfiguration);
        this.playQueue = new AsyncPlayQueue(syncSDK.playQueue(), sdkConfiguration);
        this.ultraBlur = new AsyncUltraBlur(syncSDK.ultraBlur(), sdkConfiguration);
        this.status = new AsyncStatus(syncSDK.status(), sdkConfiguration);
        this.updater = new AsyncUpdater(syncSDK.updater(), sdkConfiguration);
        this.content = new AsyncContent(syncSDK.content(), sdkConfiguration);
        this.libraryCollections = new AsyncLibraryCollections(syncSDK.libraryCollections(), sdkConfiguration);
    }

    /**
     * Switches to the sync SDK.
     * 
     * @return The sync SDK
     */
    public PlexAPI sync() {
        return syncSDK;
    }
}
